{"version":3,"file":"chart.umd.js","sources":["../src/helpers/helpers.core.ts","../src/helpers/helpers.math.ts","../src/helpers/helpers.collection.ts","../src/helpers/helpers.extras.ts","../src/core/core.animator.js","../node_modules/.pnpm/@kurkle+color@0.3.0/node_modules/@kurkle/color/dist/color.esm.js","../src/helpers/helpers.color.ts","../src/core/core.animations.defaults.js","../src/helpers/helpers.intl.ts","../src/core/core.ticks.js","../src/core/core.defaults.js","../src/core/core.layouts.defaults.js","../src/core/core.scale.defaults.js","../src/helpers/helpers.dom.ts","../src/helpers/helpers.canvas.ts","../src/helpers/helpers.config.js","../src/helpers/helpers.curve.ts","../src/helpers/helpers.easing.ts","../src/helpers/helpers.interpolation.ts","../src/helpers/helpers.options.ts","../src/helpers/helpers.rtl.ts","../src/helpers/helpers.segment.js","../src/core/core.interaction.js","../src/core/core.layouts.js","../src/platform/platform.base.js","../src/platform/platform.basic.js","../src/platform/platform.dom.js","../src/platform/index.js","../src/core/core.animation.js","../src/core/core.animations.js","../src/core/core.datasetController.js","../src/core/core.element.ts","../src/core/core.scale.autoskip.js","../src/core/core.scale.js","../src/core/core.typedRegistry.js","../src/core/core.registry.js","../src/core/core.plugins.js","../src/core/core.config.js","../src/core/core.controller.js","../src/core/core.adapters.ts","../src/controllers/controller.bar.js","../src/controllers/controller.doughnut.js","../src/controllers/controller.polarArea.js","../src/controllers/controller.bubble.js","../src/controllers/controller.line.js","../src/controllers/controller.pie.js","../src/controllers/controller.radar.js","../src/controllers/controller.scatter.js","../src/elements/element.arc.ts","../src/elements/element.line.js","../src/elements/element.point.ts","../src/elements/element.bar.js","../src/scales/scale.category.js","../src/scales/scale.linearbase.js","../src/scales/scale.linear.js","../src/scales/scale.logarithmic.js","../src/scales/scale.radialLinear.js","../src/scales/scale.time.js","../src/scales/scale.timeseries.js","../src/plugins/plugin.colors.ts","../src/plugins/plugin.decimation.js","../src/plugins/plugin.filler/filler.segment.js","../src/plugins/plugin.filler/filler.helper.js","../src/plugins/plugin.filler/filler.options.js","../src/plugins/plugin.filler/filler.target.stack.js","../src/plugins/plugin.filler/simpleArc.js","../src/plugins/plugin.filler/filler.target.js","../src/plugins/plugin.filler/filler.drawing.js","../src/plugins/plugin.filler/index.js","../src/plugins/plugin.legend.js","../src/plugins/plugin.title.js","../src/plugins/plugin.subtitle.js","../src/plugins/plugin.tooltip.js","../src/index.umd.ts"],"sourcesContent":["/**\r\n * @namespace Chart.helpers\r\n */\r\n\r\nimport type {AnyObject} from '../types/basic.js';\r\nimport type {ActiveDataPoint, ChartEvent} from '../types/index.js';\r\n\r\n/**\r\n * An empty function that can be used, for example, for optional callback.\r\n */\r\nexport function noop() {\r\n  /* noop */\r\n}\r\n\r\n/**\r\n * Returns a unique id, sequentially generated from a global variable.\r\n */\r\nexport const uid = (() => {\r\n  let id = 0;\r\n  return () => id++;\r\n})();\r\n\r\n/**\r\n * Returns true if `value` is neither null nor undefined, else returns false.\r\n * @param value - The value to test.\r\n * @since 2.7.0\r\n */\r\nexport function isNullOrUndef(value: unknown): value is null | undefined {\r\n  return value === null || typeof value === 'undefined';\r\n}\r\n\r\n/**\r\n * Returns true if `value` is an array (including typed arrays), else returns false.\r\n * @param value - The value to test.\r\n * @function\r\n */\r\nexport function isArray<T = unknown>(value: unknown): value is T[] {\r\n  if (Array.isArray && Array.isArray(value)) {\r\n    return true;\r\n  }\r\n  const type = Object.prototype.toString.call(value);\r\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Returns true if `value` is an object (excluding null), else returns false.\r\n * @param value - The value to test.\r\n * @since 2.7.0\r\n */\r\nexport function isObject(value: unknown): value is AnyObject {\r\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\r\n}\r\n\r\n/**\r\n * Returns true if `value` is a finite number, else returns false\r\n * @param value  - The value to test.\r\n */\r\nfunction isNumberFinite(value: unknown): value is number {\r\n  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\r\n}\r\nexport {\r\n  isNumberFinite as isFinite,\r\n};\r\n\r\n/**\r\n * Returns `value` if finite, else returns `defaultValue`.\r\n * @param value - The value to return if defined.\r\n * @param defaultValue - The value to return if `value` is not finite.\r\n */\r\nexport function finiteOrDefault(value: unknown, defaultValue: number) {\r\n  return isNumberFinite(value) ? value : defaultValue;\r\n}\r\n\r\n/**\r\n * Returns `value` if defined, else returns `defaultValue`.\r\n * @param value - The value to return if defined.\r\n * @param defaultValue - The value to return if `value` is undefined.\r\n */\r\nexport function valueOrDefault<T>(value: T | undefined, defaultValue: T) {\r\n  return typeof value === 'undefined' ? defaultValue : value;\r\n}\r\n\r\nexport const toPercentage = (value: number | string, dimension: number) =>\r\n  typeof value === 'string' && value.endsWith('%') ?\r\n    parseFloat(value) / 100\r\n    : +value / dimension;\r\n\r\nexport const toDimension = (value: number | string, dimension: number) =>\r\n  typeof value === 'string' && value.endsWith('%') ?\r\n    parseFloat(value) / 100 * dimension\r\n    : +value;\r\n\r\n/**\r\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\r\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\r\n * @param fn - The function to call.\r\n * @param args - The arguments with which `fn` should be called.\r\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\r\n */\r\nexport function callback<T extends (this: TA, ...restArgs: unknown[]) => R, TA, R>(\r\n  fn: T | undefined,\r\n  args: unknown[],\r\n  thisArg?: TA\r\n): R | undefined {\r\n  if (fn && typeof fn.call === 'function') {\r\n    return fn.apply(thisArg, args);\r\n  }\r\n}\r\n\r\n/**\r\n * Note(SB) for performance sake, this method should only be used when loopable type\r\n * is unknown or in none intensive code (not called often and small loopable). Else\r\n * it's preferable to use a regular for() loop and save extra function calls.\r\n * @param loopable - The object or array to be iterated.\r\n * @param fn - The function to call for each item.\r\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\r\n * @param [reverse] - If true, iterates backward on the loopable.\r\n */\r\nexport function each<T, TA>(\r\n  loopable: Record<string, T>,\r\n  fn: (this: TA, v: T, i: string) => void,\r\n  thisArg?: TA,\r\n  reverse?: boolean\r\n): void;\r\nexport function each<T, TA>(\r\n  loopable: T[],\r\n  fn: (this: TA, v: T, i: number) => void,\r\n  thisArg?: TA,\r\n  reverse?: boolean\r\n): void;\r\nexport function each<T, TA>(\r\n  loopable: T[] | Record<string, T>,\r\n  fn: (this: TA, v: T, i: any) => void,\r\n  thisArg?: TA,\r\n  reverse?: boolean\r\n) {\r\n  let i: number, len: number, keys: string[];\r\n  if (isArray(loopable)) {\r\n    len = loopable.length;\r\n    if (reverse) {\r\n      for (i = len - 1; i >= 0; i--) {\r\n        fn.call(thisArg, loopable[i], i);\r\n      }\r\n    } else {\r\n      for (i = 0; i < len; i++) {\r\n        fn.call(thisArg, loopable[i], i);\r\n      }\r\n    }\r\n  } else if (isObject(loopable)) {\r\n    keys = Object.keys(loopable);\r\n    len = keys.length;\r\n    for (i = 0; i < len; i++) {\r\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\r\n * @param a0 - The array to compare\r\n * @param a1 - The array to compare\r\n * @private\r\n */\r\nexport function _elementsEqual(a0: ActiveDataPoint[], a1: ActiveDataPoint[]) {\r\n  let i: number, ilen: number, v0: ActiveDataPoint, v1: ActiveDataPoint;\r\n\r\n  if (!a0 || !a1 || a0.length !== a1.length) {\r\n    return false;\r\n  }\r\n\r\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\r\n    v0 = a0[i];\r\n    v1 = a1[i];\r\n\r\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Returns a deep copy of `source` without keeping references on objects and arrays.\r\n * @param source - The value to clone.\r\n */\r\nexport function clone<T>(source: T): T {\r\n  if (isArray(source)) {\r\n    return source.map(clone) as unknown as T;\r\n  }\r\n\r\n  if (isObject(source)) {\r\n    const target = Object.create(null);\r\n    const keys = Object.keys(source);\r\n    const klen = keys.length;\r\n    let k = 0;\r\n\r\n    for (; k < klen; ++k) {\r\n      target[keys[k]] = clone(source[keys[k]]);\r\n    }\r\n\r\n    return target;\r\n  }\r\n\r\n  return source;\r\n}\r\n\r\nfunction isValidKey(key: string) {\r\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\r\n}\r\n\r\n/**\r\n * The default merger when Chart.helpers.merge is called without merger option.\r\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\r\n * @private\r\n */\r\nexport function _merger(key: string, target: AnyObject, source: AnyObject, options: AnyObject) {\r\n  if (!isValidKey(key)) {\r\n    return;\r\n  }\r\n\r\n  const tval = target[key];\r\n  const sval = source[key];\r\n\r\n  if (isObject(tval) && isObject(sval)) {\r\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n    merge(tval, sval, options);\r\n  } else {\r\n    target[key] = clone(sval);\r\n  }\r\n}\r\n\r\nexport interface MergeOptions {\r\n  merger?: (key: string, target: AnyObject, source: AnyObject, options?: AnyObject) => void;\r\n}\r\n\r\n/**\r\n * Recursively deep copies `source` properties into `target` with the given `options`.\r\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\r\n * @param target - The target object in which all sources are merged into.\r\n * @param source - Object(s) to merge into `target`.\r\n * @param [options] - Merging options:\r\n * @param [options.merger] - The merge method (key, target, source, options)\r\n * @returns The `target` object.\r\n */\r\nexport function merge<T>(target: T, source: [], options?: MergeOptions): T;\r\nexport function merge<T, S1>(target: T, source: S1, options?: MergeOptions): T & S1;\r\nexport function merge<T, S1>(target: T, source: [S1], options?: MergeOptions): T & S1;\r\nexport function merge<T, S1, S2>(target: T, source: [S1, S2], options?: MergeOptions): T & S1 & S2;\r\nexport function merge<T, S1, S2, S3>(target: T, source: [S1, S2, S3], options?: MergeOptions): T & S1 & S2 & S3;\r\nexport function merge<T, S1, S2, S3, S4>(\r\n  target: T,\r\n  source: [S1, S2, S3, S4],\r\n  options?: MergeOptions\r\n): T & S1 & S2 & S3 & S4;\r\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject;\r\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject {\r\n  const sources = isArray(source) ? source : [source];\r\n  const ilen = sources.length;\r\n\r\n  if (!isObject(target)) {\r\n    return target as AnyObject;\r\n  }\r\n\r\n  options = options || {};\r\n  const merger = options.merger || _merger;\r\n  let current: AnyObject;\r\n\r\n  for (let i = 0; i < ilen; ++i) {\r\n    current = sources[i];\r\n    if (!isObject(current)) {\r\n      continue;\r\n    }\r\n\r\n    const keys = Object.keys(current);\r\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\r\n      merger(keys[k], target, current, options as AnyObject);\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\n/**\r\n * Recursively deep copies `source` properties into `target` *only* if not defined in target.\r\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\r\n * @param target - The target object in which all sources are merged into.\r\n * @param source - Object(s) to merge into `target`.\r\n * @returns The `target` object.\r\n */\r\nexport function mergeIf<T>(target: T, source: []): T;\r\nexport function mergeIf<T, S1>(target: T, source: S1): T & S1;\r\nexport function mergeIf<T, S1>(target: T, source: [S1]): T & S1;\r\nexport function mergeIf<T, S1, S2>(target: T, source: [S1, S2]): T & S1 & S2;\r\nexport function mergeIf<T, S1, S2, S3>(target: T, source: [S1, S2, S3]): T & S1 & S2 & S3;\r\nexport function mergeIf<T, S1, S2, S3, S4>(target: T, source: [S1, S2, S3, S4]): T & S1 & S2 & S3 & S4;\r\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject;\r\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject {\r\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n  return merge<T>(target, source, {merger: _mergerIf});\r\n}\r\n\r\n/**\r\n * Merges source[key] in target[key] only if target[key] is undefined.\r\n * @private\r\n */\r\nexport function _mergerIf(key: string, target: AnyObject, source: AnyObject) {\r\n  if (!isValidKey(key)) {\r\n    return;\r\n  }\r\n\r\n  const tval = target[key];\r\n  const sval = source[key];\r\n\r\n  if (isObject(tval) && isObject(sval)) {\r\n    mergeIf(tval, sval);\r\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\r\n    target[key] = clone(sval);\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function _deprecated(scope: string, value: unknown, previous: string, current: string) {\r\n  if (value !== undefined) {\r\n    console.warn(scope + ': \"' + previous +\r\n      '\" is deprecated. Please use \"' + current + '\" instead');\r\n  }\r\n}\r\n\r\n// resolveObjectKey resolver cache\r\nconst keyResolvers = {\r\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\r\n  '': v => v,\r\n  // default resolvers\r\n  x: o => o.x,\r\n  y: o => o.y\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nexport function _splitKey(key: string) {\r\n  const parts = key.split('.');\r\n  const keys: string[] = [];\r\n  let tmp = '';\r\n  for (const part of parts) {\r\n    tmp += part;\r\n    if (tmp.endsWith('\\\\')) {\r\n      tmp = tmp.slice(0, -1) + '.';\r\n    } else {\r\n      keys.push(tmp);\r\n      tmp = '';\r\n    }\r\n  }\r\n  return keys;\r\n}\r\n\r\nfunction _getKeyResolver(key: string) {\r\n  const keys = _splitKey(key);\r\n  return obj => {\r\n    for (const k of keys) {\r\n      if (k === '') {\r\n        // For backward compatibility:\r\n        // Chart.helpers.core resolveObjectKey should break at empty key\r\n        break;\r\n      }\r\n      obj = obj && obj[k];\r\n    }\r\n    return obj;\r\n  };\r\n}\r\n\r\nexport function resolveObjectKey(obj: AnyObject, key: string): AnyObject {\r\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\r\n  return resolver(obj);\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function _capitalize(str: string) {\r\n  return str.charAt(0).toUpperCase() + str.slice(1);\r\n}\r\n\r\n\r\nexport const defined = (value: unknown) => typeof value !== 'undefined';\r\n\r\nexport const isFunction = (value: unknown): value is (...args: any[]) => any => typeof value === 'function';\r\n\r\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\r\nexport const setsEqual = <T>(a: Set<T>, b: Set<T>) => {\r\n  if (a.size !== b.size) {\r\n    return false;\r\n  }\r\n\r\n  for (const item of a) {\r\n    if (!b.has(item)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n/**\r\n * @param e - The event\r\n * @private\r\n */\r\nexport function _isClickEvent(e: ChartEvent) {\r\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\r\n}\r\n","import type {Point} from '../types/geometric.js';\r\nimport {isFinite as isFiniteNumber} from './helpers.core.js';\r\n\r\n/**\r\n * @alias Chart.helpers.math\r\n * @namespace\r\n */\r\n\r\nexport const PI = Math.PI;\r\nexport const TAU = 2 * PI;\r\nexport const PITAU = TAU + PI;\r\nexport const INFINITY = Number.POSITIVE_INFINITY;\r\nexport const RAD_PER_DEG = PI / 180;\r\nexport const HALF_PI = PI / 2;\r\nexport const QUARTER_PI = PI / 4;\r\nexport const TWO_THIRDS_PI = PI * 2 / 3;\r\n\r\nexport const log10 = Math.log10;\r\nexport const sign = Math.sign;\r\n\r\nexport function almostEquals(x: number, y: number, epsilon: number) {\r\n  return Math.abs(x - y) < epsilon;\r\n}\r\n\r\n/**\r\n * Implementation of the nice number algorithm used in determining where axis labels will go\r\n */\r\nexport function niceNum(range: number) {\r\n  const roundedRange = Math.round(range);\r\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\r\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\r\n  const fraction = range / niceRange;\r\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\r\n  return niceFraction * niceRange;\r\n}\r\n\r\n/**\r\n * Returns an array of factors sorted from 1 to sqrt(value)\r\n * @private\r\n */\r\nexport function _factorize(value: number) {\r\n  const result: number[] = [];\r\n  const sqrt = Math.sqrt(value);\r\n  let i: number;\r\n\r\n  for (i = 1; i < sqrt; i++) {\r\n    if (value % i === 0) {\r\n      result.push(i);\r\n      result.push(value / i);\r\n    }\r\n  }\r\n  if (sqrt === (sqrt | 0)) { // if value is a square number\r\n    result.push(sqrt);\r\n  }\r\n\r\n  result.sort((a, b) => a - b).pop();\r\n  return result;\r\n}\r\n\r\nexport function isNumber(n: unknown): n is number {\r\n  return !isNaN(parseFloat(n as string)) && isFinite(n as number);\r\n}\r\n\r\nexport function almostWhole(x: number, epsilon: number) {\r\n  const rounded = Math.round(x);\r\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function _setMinAndMaxByKey(\r\n  array: Record<string, number>[],\r\n  target: { min: number, max: number },\r\n  property: string\r\n) {\r\n  let i: number, ilen: number, value: number;\r\n\r\n  for (i = 0, ilen = array.length; i < ilen; i++) {\r\n    value = array[i][property];\r\n    if (!isNaN(value)) {\r\n      target.min = Math.min(target.min, value);\r\n      target.max = Math.max(target.max, value);\r\n    }\r\n  }\r\n}\r\n\r\nexport function toRadians(degrees: number) {\r\n  return degrees * (PI / 180);\r\n}\r\n\r\nexport function toDegrees(radians: number) {\r\n  return radians * (180 / PI);\r\n}\r\n\r\n/**\r\n * Returns the number of decimal places\r\n * i.e. the number of digits after the decimal point, of the value of this Number.\r\n * @param x - A number.\r\n * @returns The number of decimal places.\r\n * @private\r\n */\r\nexport function _decimalPlaces(x: number) {\r\n  if (!isFiniteNumber(x)) {\r\n    return;\r\n  }\r\n  let e = 1;\r\n  let p = 0;\r\n  while (Math.round(x * e) / e !== x) {\r\n    e *= 10;\r\n    p++;\r\n  }\r\n  return p;\r\n}\r\n\r\n// Gets the angle from vertical upright to the point about a centre.\r\nexport function getAngleFromPoint(\r\n  centrePoint: Point,\r\n  anglePoint: Point\r\n) {\r\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\r\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\r\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\r\n\r\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\r\n\r\n  if (angle < (-0.5 * PI)) {\r\n    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\r\n  }\r\n\r\n  return {\r\n    angle,\r\n    distance: radialDistanceFromCenter\r\n  };\r\n}\r\n\r\nexport function distanceBetweenPoints(pt1: Point, pt2: Point) {\r\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\r\n}\r\n\r\n/**\r\n * Shortest distance between angles, in either direction.\r\n * @private\r\n */\r\nexport function _angleDiff(a: number, b: number) {\r\n  return (a - b + PITAU) % TAU - PI;\r\n}\r\n\r\n/**\r\n * Normalize angle to be between 0 and 2*PI\r\n * @private\r\n */\r\nexport function _normalizeAngle(a: number) {\r\n  return (a % TAU + TAU) % TAU;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function _angleBetween(angle: number, start: number, end: number, sameAngleIsFullCircle?: boolean) {\r\n  const a = _normalizeAngle(angle);\r\n  const s = _normalizeAngle(start);\r\n  const e = _normalizeAngle(end);\r\n  const angleToStart = _normalizeAngle(s - a);\r\n  const angleToEnd = _normalizeAngle(e - a);\r\n  const startToAngle = _normalizeAngle(a - s);\r\n  const endToAngle = _normalizeAngle(a - e);\r\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\r\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\r\n}\r\n\r\n/**\r\n * Limit `value` between `min` and `max`\r\n * @param value\r\n * @param min\r\n * @param max\r\n * @private\r\n */\r\nexport function _limitValue(value: number, min: number, max: number) {\r\n  return Math.max(min, Math.min(max, value));\r\n}\r\n\r\n/**\r\n * @param {number} value\r\n * @private\r\n */\r\nexport function _int16Range(value: number) {\r\n  return _limitValue(value, -32768, 32767);\r\n}\r\n\r\n/**\r\n * @param value\r\n * @param start\r\n * @param end\r\n * @param [epsilon]\r\n * @private\r\n */\r\nexport function _isBetween(value: number, start: number, end: number, epsilon = 1e-6) {\r\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\r\n}\r\n","import {_capitalize} from './helpers.core.js';\r\n\r\n/**\r\n * Binary search\r\n * @param table - the table search. must be sorted!\r\n * @param value - value to find\r\n * @param cmp\r\n * @private\r\n */\r\nexport function _lookup(\r\n  table: number[],\r\n  value: number,\r\n  cmp?: (value: number) => boolean\r\n): {lo: number, hi: number};\r\nexport function _lookup<T>(\r\n  table: T[],\r\n  value: number,\r\n  cmp: (value: number) => boolean\r\n): {lo: number, hi: number};\r\nexport function _lookup(\r\n  table: unknown[],\r\n  value: number,\r\n  cmp?: (value: number) => boolean\r\n) {\r\n  cmp = cmp || ((index) => table[index] < value);\r\n  let hi = table.length - 1;\r\n  let lo = 0;\r\n  let mid: number;\r\n\r\n  while (hi - lo > 1) {\r\n    mid = (lo + hi) >> 1;\r\n    if (cmp(mid)) {\r\n      lo = mid;\r\n    } else {\r\n      hi = mid;\r\n    }\r\n  }\r\n\r\n  return {lo, hi};\r\n}\r\n\r\n/**\r\n * Binary search\r\n * @param table - the table search. must be sorted!\r\n * @param key - property name for the value in each entry\r\n * @param value - value to find\r\n * @param last - lookup last index\r\n * @private\r\n */\r\nexport const _lookupByKey = (\r\n  table: Record<string, number>[],\r\n  key: string,\r\n  value: number,\r\n  last?: boolean\r\n) =>\r\n  _lookup(table, value, last\r\n    ? index => {\r\n      const ti = table[index][key];\r\n      return ti < value || ti === value && table[index + 1][key] === value;\r\n    }\r\n    : index => table[index][key] < value);\r\n\r\n/**\r\n * Reverse binary search\r\n * @param table - the table search. must be sorted!\r\n * @param key - property name for the value in each entry\r\n * @param value - value to find\r\n * @private\r\n */\r\nexport const _rlookupByKey = (\r\n  table: Record<string, number>[],\r\n  key: string,\r\n  value: number\r\n) =>\r\n  _lookup(table, value, index => table[index][key] >= value);\r\n\r\n/**\r\n * Return subset of `values` between `min` and `max` inclusive.\r\n * Values are assumed to be in sorted order.\r\n * @param values - sorted array of values\r\n * @param min - min value\r\n * @param max - max value\r\n */\r\nexport function _filterBetween(values: number[], min: number, max: number) {\r\n  let start = 0;\r\n  let end = values.length;\r\n\r\n  while (start < end && values[start] < min) {\r\n    start++;\r\n  }\r\n  while (end > start && values[end - 1] > max) {\r\n    end--;\r\n  }\r\n\r\n  return start > 0 || end < values.length\r\n    ? values.slice(start, end)\r\n    : values;\r\n}\r\n\r\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'] as const;\r\n\r\nexport interface ArrayListener<T> {\r\n  _onDataPush?(...item: T[]): void;\r\n  _onDataPop?(): void;\r\n  _onDataShift?(): void;\r\n  _onDataSplice?(index: number, deleteCount: number, ...items: T[]): void;\r\n  _onDataUnshift?(...item: T[]): void;\r\n}\r\n\r\n/**\r\n * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\r\n * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\r\n * called on the '_onData*' callbacks (e.g. _onDataPush, etc.) with same arguments.\r\n */\r\nexport function listenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\r\nexport function listenArrayEvents(array, listener) {\r\n  if (array._chartjs) {\r\n    array._chartjs.listeners.push(listener);\r\n    return;\r\n  }\r\n\r\n  Object.defineProperty(array, '_chartjs', {\r\n    configurable: true,\r\n    enumerable: false,\r\n    value: {\r\n      listeners: [listener]\r\n    }\r\n  });\r\n\r\n  arrayEvents.forEach((key) => {\r\n    const method = '_onData' + _capitalize(key);\r\n    const base = array[key];\r\n\r\n    Object.defineProperty(array, key, {\r\n      configurable: true,\r\n      enumerable: false,\r\n      value(...args) {\r\n        const res = base.apply(this, args);\r\n\r\n        array._chartjs.listeners.forEach((object) => {\r\n          if (typeof object[method] === 'function') {\r\n            object[method](...args);\r\n          }\r\n        });\r\n\r\n        return res;\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n\r\n/**\r\n * Removes the given array event listener and cleanup extra attached properties (such as\r\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\r\n */\r\nexport function unlistenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\r\nexport function unlistenArrayEvents(array, listener) {\r\n  const stub = array._chartjs;\r\n  if (!stub) {\r\n    return;\r\n  }\r\n\r\n  const listeners = stub.listeners;\r\n  const index = listeners.indexOf(listener);\r\n  if (index !== -1) {\r\n    listeners.splice(index, 1);\r\n  }\r\n\r\n  if (listeners.length > 0) {\r\n    return;\r\n  }\r\n\r\n  arrayEvents.forEach((key) => {\r\n    delete array[key];\r\n  });\r\n\r\n  delete array._chartjs;\r\n}\r\n\r\n/**\r\n * @param items\r\n */\r\nexport function _arrayUnique<T>(items: T[]) {\r\n  const set = new Set<T>(items);\r\n\r\n  if (set.size === items.length) {\r\n    return items;\r\n  }\r\n\r\n  return Array.from(set);\r\n}\r\n","import type {ChartMeta, PointElement} from '../types/index.js';\r\n\r\nimport {_limitValue} from './helpers.math.js';\r\nimport {_lookupByKey} from './helpers.collection.js';\r\n\r\nexport function fontString(pixelSize: number, fontStyle: string, fontFamily: string) {\r\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\r\n}\r\n\r\n/**\r\n* Request animation polyfill\r\n*/\r\nexport const requestAnimFrame = (function() {\r\n  if (typeof window === 'undefined') {\r\n    return function(callback) {\r\n      return callback();\r\n    };\r\n  }\r\n  return window.requestAnimationFrame;\r\n}());\r\n\r\n/**\r\n * Throttles calling `fn` once per animation frame\r\n * Latest arguments are used on the actual call\r\n */\r\nexport function throttled<TArgs extends Array<any>>(\r\n  fn: (...args: TArgs) => void,\r\n  thisArg: any,\r\n) {\r\n  let argsToUse = [] as TArgs;\r\n  let ticking = false;\r\n\r\n  return function(...args: TArgs) {\r\n    // Save the args for use later\r\n    argsToUse = args;\r\n    if (!ticking) {\r\n      ticking = true;\r\n      requestAnimFrame.call(window, () => {\r\n        ticking = false;\r\n        fn.apply(thisArg, argsToUse);\r\n      });\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Debounces calling `fn` for `delay` ms\r\n */\r\nexport function debounce<TArgs extends Array<any>>(fn: (...args: TArgs) => void, delay: number) {\r\n  let timeout;\r\n  return function(...args: TArgs) {\r\n    if (delay) {\r\n      clearTimeout(timeout);\r\n      timeout = setTimeout(fn, delay, args);\r\n    } else {\r\n      fn.apply(this, args);\r\n    }\r\n    return delay;\r\n  };\r\n}\r\n\r\n/**\r\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\r\n * @private\r\n */\r\nexport const _toLeftRightCenter = (align: 'start' | 'end' | 'center') => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\r\n\r\n/**\r\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\r\n * @private\r\n */\r\nexport const _alignStartEnd = (align: 'start' | 'end' | 'center', start: number, end: number) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\r\n\r\n/**\r\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\r\n * @private\r\n */\r\nexport const _textX = (align: 'left' | 'right' | 'center', left: number, right: number, rtl: boolean) => {\r\n  const check = rtl ? 'left' : 'right';\r\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\r\n};\r\n\r\n/**\r\n * Return start and count of visible points.\r\n * @private\r\n */\r\nexport function _getStartAndCountOfVisiblePoints(meta: ChartMeta<'line' | 'scatter'>, points: PointElement[], animationsDisabled: boolean) {\r\n  const pointCount = points.length;\r\n\r\n  let start = 0;\r\n  let count = pointCount;\r\n\r\n  if (meta._sorted) {\r\n    const {iScale, _parsed} = meta;\r\n    const axis = iScale.axis;\r\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\r\n\r\n    if (minDefined) {\r\n      start = _limitValue(Math.min(\r\n        // @ts-expect-error Need to type _parsed\r\n        _lookupByKey(_parsed, iScale.axis, min).lo,\r\n        // @ts-expect-error Need to fix types on _lookupByKey\r\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\r\n      0, pointCount - 1);\r\n    }\r\n    if (maxDefined) {\r\n      count = _limitValue(Math.max(\r\n        // @ts-expect-error Need to type _parsed\r\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\r\n        // @ts-expect-error Need to fix types on _lookupByKey\r\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1),\r\n      start, pointCount) - start;\r\n    } else {\r\n      count = pointCount - start;\r\n    }\r\n  }\r\n\r\n  return {start, count};\r\n}\r\n\r\n/**\r\n * Checks if the scale ranges have changed.\r\n * @param {object} meta - dataset meta.\r\n * @returns {boolean}\r\n * @private\r\n */\r\nexport function _scaleRangesChanged(meta) {\r\n  const {xScale, yScale, _scaleRanges} = meta;\r\n  const newRanges = {\r\n    xmin: xScale.min,\r\n    xmax: xScale.max,\r\n    ymin: yScale.min,\r\n    ymax: yScale.max\r\n  };\r\n  if (!_scaleRanges) {\r\n    meta._scaleRanges = newRanges;\r\n    return true;\r\n  }\r\n  const changed = _scaleRanges.xmin !== xScale.min\r\n\t\t|| _scaleRanges.xmax !== xScale.max\r\n\t\t|| _scaleRanges.ymin !== yScale.min\r\n\t\t|| _scaleRanges.ymax !== yScale.max;\r\n\r\n  Object.assign(_scaleRanges, newRanges);\r\n  return changed;\r\n}\r\n","import {requestAnimFrame} from '../helpers/helpers.extras.js';\r\n\r\n/**\r\n * @typedef { import('./core.animation.js').default } Animation\r\n * @typedef { import('./core.controller.js').default } Chart\r\n */\r\n\r\n/**\r\n * Please use the module's default export which provides a singleton instance\r\n * Note: class is export for typedoc\r\n */\r\nexport class Animator {\r\n  constructor() {\r\n    this._request = null;\r\n    this._charts = new Map();\r\n    this._running = false;\r\n    this._lastDate = undefined;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _notify(chart, anims, date, type) {\r\n    const callbacks = anims.listeners[type];\r\n    const numSteps = anims.duration;\r\n\r\n    callbacks.forEach(fn => fn({\r\n      chart,\r\n      initial: anims.initial,\r\n      numSteps,\r\n      currentStep: Math.min(date - anims.start, numSteps)\r\n    }));\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _refresh() {\r\n    if (this._request) {\r\n      return;\r\n    }\r\n    this._running = true;\r\n\r\n    this._request = requestAnimFrame.call(window, () => {\r\n      this._update();\r\n      this._request = null;\r\n\r\n      if (this._running) {\r\n        this._refresh();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _update(date = Date.now()) {\r\n    let remaining = 0;\r\n\r\n    this._charts.forEach((anims, chart) => {\r\n      if (!anims.running || !anims.items.length) {\r\n        return;\r\n      }\r\n      const items = anims.items;\r\n      let i = items.length - 1;\r\n      let draw = false;\r\n      let item;\r\n\r\n      for (; i >= 0; --i) {\r\n        item = items[i];\r\n\r\n        if (item._active) {\r\n          if (item._total > anims.duration) {\r\n            // if the animation has been updated and its duration prolonged,\r\n            // update to total duration of current animations run (for progress event)\r\n            anims.duration = item._total;\r\n          }\r\n          item.tick(date);\r\n          draw = true;\r\n        } else {\r\n          // Remove the item by replacing it with last item and removing the last\r\n          // A lot faster than splice.\r\n          items[i] = items[items.length - 1];\r\n          items.pop();\r\n        }\r\n      }\r\n\r\n      if (draw) {\r\n        chart.draw();\r\n        this._notify(chart, anims, date, 'progress');\r\n      }\r\n\r\n      if (!items.length) {\r\n        anims.running = false;\r\n        this._notify(chart, anims, date, 'complete');\r\n        anims.initial = false;\r\n      }\r\n\r\n      remaining += items.length;\r\n    });\r\n\r\n    this._lastDate = date;\r\n\r\n    if (remaining === 0) {\r\n      this._running = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getAnims(chart) {\r\n    const charts = this._charts;\r\n    let anims = charts.get(chart);\r\n    if (!anims) {\r\n      anims = {\r\n        running: false,\r\n        initial: true,\r\n        items: [],\r\n        listeners: {\r\n          complete: [],\r\n          progress: []\r\n        }\r\n      };\r\n      charts.set(chart, anims);\r\n    }\r\n    return anims;\r\n  }\r\n\r\n  /**\r\n\t * @param {Chart} chart\r\n\t * @param {string} event - event name\r\n\t * @param {Function} cb - callback\r\n\t */\r\n  listen(chart, event, cb) {\r\n    this._getAnims(chart).listeners[event].push(cb);\r\n  }\r\n\r\n  /**\r\n\t * Add animations\r\n\t * @param {Chart} chart\r\n\t * @param {Animation[]} items - animations\r\n\t */\r\n  add(chart, items) {\r\n    if (!items || !items.length) {\r\n      return;\r\n    }\r\n    this._getAnims(chart).items.push(...items);\r\n  }\r\n\r\n  /**\r\n\t * Counts number of active animations for the chart\r\n\t * @param {Chart} chart\r\n\t */\r\n  has(chart) {\r\n    return this._getAnims(chart).items.length > 0;\r\n  }\r\n\r\n  /**\r\n\t * Start animating (all charts)\r\n\t * @param {Chart} chart\r\n\t */\r\n  start(chart) {\r\n    const anims = this._charts.get(chart);\r\n    if (!anims) {\r\n      return;\r\n    }\r\n    anims.running = true;\r\n    anims.start = Date.now();\r\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\r\n    this._refresh();\r\n  }\r\n\r\n  running(chart) {\r\n    if (!this._running) {\r\n      return false;\r\n    }\r\n    const anims = this._charts.get(chart);\r\n    if (!anims || !anims.running || !anims.items.length) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n\t * Stop all animations for the chart\r\n\t * @param {Chart} chart\r\n\t */\r\n  stop(chart) {\r\n    const anims = this._charts.get(chart);\r\n    if (!anims || !anims.items.length) {\r\n      return;\r\n    }\r\n    const items = anims.items;\r\n    let i = items.length - 1;\r\n\r\n    for (; i >= 0; --i) {\r\n      items[i].cancel();\r\n    }\r\n    anims.items = [];\r\n    this._notify(chart, anims, Date.now(), 'complete');\r\n  }\r\n\r\n  /**\r\n\t * Remove chart from Animator\r\n\t * @param {Chart} chart\r\n\t */\r\n  remove(chart) {\r\n    return this._charts.delete(chart);\r\n  }\r\n}\r\n\r\n// singleton instance\r\nexport default /* #__PURE__ */ new Animator();\r\n","/*!\n * @kurkle/color v0.3.0\n * https://github.com/kurkle/color#readme\n * (c) 2022 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n  x: 'dark',\n  Z: 'light',\n  Y: 're',\n  X: 'blu',\n  W: 'gr',\n  V: 'medium',\n  U: 'slate',\n  A: 'ee',\n  T: 'ol',\n  S: 'or',\n  B: 'ra',\n  C: 'lateg',\n  D: 'ights',\n  R: 'in',\n  Q: 'turquois',\n  E: 'hi',\n  P: 'ro',\n  O: 'al',\n  N: 'le',\n  M: 'de',\n  L: 'yello',\n  F: 'en',\n  K: 'ch',\n  G: 'arks',\n  H: 'ea',\n  I: 'ightg',\n  J: 'wh'\n};\nconst names$1 = {\n  OiceXe: 'f0f8ff',\n  antiquewEte: 'faebd7',\n  aqua: 'ffff',\n  aquamarRe: '7fffd4',\n  azuY: 'f0ffff',\n  beige: 'f5f5dc',\n  bisque: 'ffe4c4',\n  black: '0',\n  blanKedOmond: 'ffebcd',\n  Xe: 'ff',\n  XeviTet: '8a2be2',\n  bPwn: 'a52a2a',\n  burlywood: 'deb887',\n  caMtXe: '5f9ea0',\n  KartYuse: '7fff00',\n  KocTate: 'd2691e',\n  cSO: 'ff7f50',\n  cSnflowerXe: '6495ed',\n  cSnsilk: 'fff8dc',\n  crimson: 'dc143c',\n  cyan: 'ffff',\n  xXe: '8b',\n  xcyan: '8b8b',\n  xgTMnPd: 'b8860b',\n  xWay: 'a9a9a9',\n  xgYF: '6400',\n  xgYy: 'a9a9a9',\n  xkhaki: 'bdb76b',\n  xmagFta: '8b008b',\n  xTivegYF: '556b2f',\n  xSange: 'ff8c00',\n  xScEd: '9932cc',\n  xYd: '8b0000',\n  xsOmon: 'e9967a',\n  xsHgYF: '8fbc8f',\n  xUXe: '483d8b',\n  xUWay: '2f4f4f',\n  xUgYy: '2f4f4f',\n  xQe: 'ced1',\n  xviTet: '9400d3',\n  dAppRk: 'ff1493',\n  dApskyXe: 'bfff',\n  dimWay: '696969',\n  dimgYy: '696969',\n  dodgerXe: '1e90ff',\n  fiYbrick: 'b22222',\n  flSOwEte: 'fffaf0',\n  foYstWAn: '228b22',\n  fuKsia: 'ff00ff',\n  gaRsbSo: 'dcdcdc',\n  ghostwEte: 'f8f8ff',\n  gTd: 'ffd700',\n  gTMnPd: 'daa520',\n  Way: '808080',\n  gYF: '8000',\n  gYFLw: 'adff2f',\n  gYy: '808080',\n  honeyMw: 'f0fff0',\n  hotpRk: 'ff69b4',\n  RdianYd: 'cd5c5c',\n  Rdigo: '4b0082',\n  ivSy: 'fffff0',\n  khaki: 'f0e68c',\n  lavFMr: 'e6e6fa',\n  lavFMrXsh: 'fff0f5',\n  lawngYF: '7cfc00',\n  NmoncEffon: 'fffacd',\n  ZXe: 'add8e6',\n  ZcSO: 'f08080',\n  Zcyan: 'e0ffff',\n  ZgTMnPdLw: 'fafad2',\n  ZWay: 'd3d3d3',\n  ZgYF: '90ee90',\n  ZgYy: 'd3d3d3',\n  ZpRk: 'ffb6c1',\n  ZsOmon: 'ffa07a',\n  ZsHgYF: '20b2aa',\n  ZskyXe: '87cefa',\n  ZUWay: '778899',\n  ZUgYy: '778899',\n  ZstAlXe: 'b0c4de',\n  ZLw: 'ffffe0',\n  lime: 'ff00',\n  limegYF: '32cd32',\n  lRF: 'faf0e6',\n  magFta: 'ff00ff',\n  maPon: '800000',\n  VaquamarRe: '66cdaa',\n  VXe: 'cd',\n  VScEd: 'ba55d3',\n  VpurpN: '9370db',\n  VsHgYF: '3cb371',\n  VUXe: '7b68ee',\n  VsprRggYF: 'fa9a',\n  VQe: '48d1cc',\n  VviTetYd: 'c71585',\n  midnightXe: '191970',\n  mRtcYam: 'f5fffa',\n  mistyPse: 'ffe4e1',\n  moccasR: 'ffe4b5',\n  navajowEte: 'ffdead',\n  navy: '80',\n  Tdlace: 'fdf5e6',\n  Tive: '808000',\n  TivedBb: '6b8e23',\n  Sange: 'ffa500',\n  SangeYd: 'ff4500',\n  ScEd: 'da70d6',\n  pOegTMnPd: 'eee8aa',\n  pOegYF: '98fb98',\n  pOeQe: 'afeeee',\n  pOeviTetYd: 'db7093',\n  papayawEp: 'ffefd5',\n  pHKpuff: 'ffdab9',\n  peru: 'cd853f',\n  pRk: 'ffc0cb',\n  plum: 'dda0dd',\n  powMrXe: 'b0e0e6',\n  purpN: '800080',\n  YbeccapurpN: '663399',\n  Yd: 'ff0000',\n  Psybrown: 'bc8f8f',\n  PyOXe: '4169e1',\n  saddNbPwn: '8b4513',\n  sOmon: 'fa8072',\n  sandybPwn: 'f4a460',\n  sHgYF: '2e8b57',\n  sHshell: 'fff5ee',\n  siFna: 'a0522d',\n  silver: 'c0c0c0',\n  skyXe: '87ceeb',\n  UXe: '6a5acd',\n  UWay: '708090',\n  UgYy: '708090',\n  snow: 'fffafa',\n  sprRggYF: 'ff7f',\n  stAlXe: '4682b4',\n  tan: 'd2b48c',\n  teO: '8080',\n  tEstN: 'd8bfd8',\n  tomato: 'ff6347',\n  Qe: '40e0d0',\n  viTet: 'ee82ee',\n  JHt: 'f5deb3',\n  wEte: 'ffffff',\n  wEtesmoke: 'f5f5f5',\n  Lw: 'ffff00',\n  LwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nexport { Color, b2n, b2p, index_esm as default, hexParse, hexString, hsl2rgb, hslString, hsv2rgb, hueParse, hwb2rgb, lim, n2b, n2p, nameParse, p2b, rgb2hsl, rgbParse, rgbString, rotate, round };\n","import {Color} from '@kurkle/color';\r\n\r\nexport function isPatternOrGradient(value: unknown): value is CanvasPattern | CanvasGradient {\r\n  if (value && typeof value === 'object') {\r\n    const type = value.toString();\r\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport function color(value: CanvasGradient): CanvasGradient;\r\nexport function color(value: CanvasPattern): CanvasPattern;\r\nexport function color(\r\n  value:\r\n  | string\r\n  | { r: number; g: number; b: number; a: number }\r\n  | [number, number, number]\r\n  | [number, number, number, number]\r\n): Color;\r\nexport function color(value) {\r\n  return isPatternOrGradient(value) ? value : new Color(value);\r\n}\r\n\r\nexport function getHoverColor(value: CanvasGradient): CanvasGradient;\r\nexport function getHoverColor(value: CanvasPattern): CanvasPattern;\r\nexport function getHoverColor(value: string): string;\r\nexport function getHoverColor(value) {\r\n  return isPatternOrGradient(value)\r\n    ? value\r\n    : new Color(value).saturate(0.5).darken(0.1).hexString();\r\n}\r\n","const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\r\nconst colors = ['color', 'borderColor', 'backgroundColor'];\r\n\r\nexport function applyAnimationsDefaults(defaults) {\r\n  defaults.set('animation', {\r\n    delay: undefined,\r\n    duration: 1000,\r\n    easing: 'easeOutQuart',\r\n    fn: undefined,\r\n    from: undefined,\r\n    loop: undefined,\r\n    to: undefined,\r\n    type: undefined,\r\n  });\r\n\r\n  defaults.describe('animation', {\r\n    _fallback: false,\r\n    _indexable: false,\r\n    _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\r\n  });\r\n\r\n  defaults.set('animations', {\r\n    colors: {\r\n      type: 'color',\r\n      properties: colors\r\n    },\r\n    numbers: {\r\n      type: 'number',\r\n      properties: numbers\r\n    },\r\n  });\r\n\r\n  defaults.describe('animations', {\r\n    _fallback: 'animation',\r\n  });\r\n\r\n  defaults.set('transitions', {\r\n    active: {\r\n      animation: {\r\n        duration: 400\r\n      }\r\n    },\r\n    resize: {\r\n      animation: {\r\n        duration: 0\r\n      }\r\n    },\r\n    show: {\r\n      animations: {\r\n        colors: {\r\n          from: 'transparent'\r\n        },\r\n        visible: {\r\n          type: 'boolean',\r\n          duration: 0 // show immediately\r\n        },\r\n      }\r\n    },\r\n    hide: {\r\n      animations: {\r\n        colors: {\r\n          to: 'transparent'\r\n        },\r\n        visible: {\r\n          type: 'boolean',\r\n          easing: 'linear',\r\n          fn: v => v | 0 // for keeping the dataset visible all the way through the animation\r\n        },\r\n      }\r\n    }\r\n  });\r\n}\r\n","\r\nconst intlCache = new Map<string, Intl.NumberFormat>();\r\n\r\nfunction getNumberFormat(locale: string, options?: Intl.NumberFormatOptions) {\r\n  options = options || {};\r\n  const cacheKey = locale + JSON.stringify(options);\r\n  let formatter = intlCache.get(cacheKey);\r\n  if (!formatter) {\r\n    formatter = new Intl.NumberFormat(locale, options);\r\n    intlCache.set(cacheKey, formatter);\r\n  }\r\n  return formatter;\r\n}\r\n\r\nexport function formatNumber(num: number, locale: string, options?: Intl.NumberFormatOptions) {\r\n  return getNumberFormat(locale, options).format(num);\r\n}\r\n","import {isArray} from '../helpers/helpers.core.js';\r\nimport {formatNumber} from '../helpers/helpers.intl.js';\r\nimport {log10} from '../helpers/helpers.math.js';\r\n\r\n/**\r\n * Namespace to hold formatters for different types of ticks\r\n * @namespace Chart.Ticks.formatters\r\n */\r\nconst formatters = {\r\n  /**\r\n   * Formatter for value labels\r\n   * @method Chart.Ticks.formatters.values\r\n   * @param value the value to display\r\n   * @return {string|string[]} the label to display\r\n   */\r\n  values(value) {\r\n    return isArray(value) ? /** @type {string[]} */ (value) : '' + value;\r\n  },\r\n\r\n  /**\r\n   * Formatter for numeric ticks\r\n   * @method Chart.Ticks.formatters.numeric\r\n   * @param tickValue {number} the value to be formatted\r\n   * @param index {number} the position of the tickValue parameter in the ticks array\r\n   * @param ticks {object[]} the list of ticks being converted\r\n   * @return {string} string representation of the tickValue parameter\r\n   */\r\n  numeric(tickValue, index, ticks) {\r\n    if (tickValue === 0) {\r\n      return '0'; // never show decimal places for 0\r\n    }\r\n\r\n    const locale = this.chart.options.locale;\r\n    let notation;\r\n    let delta = tickValue; // This is used when there are less than 2 ticks as the tick interval.\r\n\r\n    if (ticks.length > 1) {\r\n      // all ticks are small or there huge numbers; use scientific notation\r\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\r\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\r\n        notation = 'scientific';\r\n      }\r\n\r\n      delta = calculateDelta(tickValue, ticks);\r\n    }\r\n\r\n    const logDelta = log10(Math.abs(delta));\r\n    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0); // toFixed has a max of 20 decimal places\r\n\r\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\r\n    Object.assign(options, this.options.ticks.format);\r\n\r\n    return formatNumber(tickValue, locale, options);\r\n  },\r\n\r\n\r\n  /**\r\n   * Formatter for logarithmic ticks\r\n   * @method Chart.Ticks.formatters.logarithmic\r\n   * @param tickValue {number} the value to be formatted\r\n   * @param index {number} the position of the tickValue parameter in the ticks array\r\n   * @param ticks {object[]} the list of ticks being converted\r\n   * @return {string} string representation of the tickValue parameter\r\n   */\r\n  logarithmic(tickValue, index, ticks) {\r\n    if (tickValue === 0) {\r\n      return '0';\r\n    }\r\n    const remain = ticks[index].significand || (tickValue / (Math.pow(10, Math.floor(log10(tickValue)))));\r\n    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {\r\n      return formatters.numeric.call(this, tickValue, index, ticks);\r\n    }\r\n    return '';\r\n  }\r\n\r\n};\r\n\r\n\r\nfunction calculateDelta(tickValue, ticks) {\r\n  // Figure out how many digits to show\r\n  // The space between the first two ticks might be smaller than normal spacing\r\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\r\n\r\n  // If we have a number like 2.5 as the delta, figure out how many decimal places we need\r\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\r\n    // not an integer\r\n    delta = tickValue - Math.floor(tickValue);\r\n  }\r\n  return delta;\r\n}\r\n\r\n/**\r\n * Namespace to hold static tick generation functions\r\n * @namespace Chart.Ticks\r\n */\r\nexport default {formatters};\r\n","import {getHoverColor} from '../helpers/helpers.color.js';\r\nimport {isObject, merge, valueOrDefault} from '../helpers/helpers.core.js';\r\nimport {applyAnimationsDefaults} from './core.animations.defaults.js';\r\nimport {applyLayoutsDefaults} from './core.layouts.defaults.js';\r\nimport {applyScaleDefaults} from './core.scale.defaults.js';\r\n\r\nexport const overrides = Object.create(null);\r\nexport const descriptors = Object.create(null);\r\n\r\n/**\r\n * @param {object} node\r\n * @param {string} key\r\n * @return {object}\r\n */\r\nfunction getScope(node, key) {\r\n  if (!key) {\r\n    return node;\r\n  }\r\n  const keys = key.split('.');\r\n  for (let i = 0, n = keys.length; i < n; ++i) {\r\n    const k = keys[i];\r\n    node = node[k] || (node[k] = Object.create(null));\r\n  }\r\n  return node;\r\n}\r\n\r\nfunction set(root, scope, values) {\r\n  if (typeof scope === 'string') {\r\n    return merge(getScope(root, scope), values);\r\n  }\r\n  return merge(getScope(root, ''), scope);\r\n}\r\n\r\n/**\r\n * Please use the module's default export which provides a singleton instance\r\n * Note: class is exported for typedoc\r\n */\r\nexport class Defaults {\r\n  constructor(_descriptors, _appliers) {\r\n    this.animation = undefined;\r\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\r\n    this.borderColor = 'rgba(0,0,0,0.1)';\r\n    this.color = '#666';\r\n    this.datasets = {};\r\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\r\n    this.elements = {};\r\n    this.events = [\r\n      'mousemove',\r\n      'mouseout',\r\n      'click',\r\n      'touchstart',\r\n      'touchmove'\r\n    ];\r\n    this.font = {\r\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\r\n      size: 12,\r\n      style: 'normal',\r\n      lineHeight: 1.2,\r\n      weight: null\r\n    };\r\n    this.hover = {};\r\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\r\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\r\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\r\n    this.indexAxis = 'x';\r\n    this.interaction = {\r\n      mode: 'nearest',\r\n      intersect: true,\r\n      includeInvisible: false\r\n    };\r\n    this.maintainAspectRatio = true;\r\n    this.onHover = null;\r\n    this.onClick = null;\r\n    this.parsing = true;\r\n    this.plugins = {};\r\n    this.responsive = true;\r\n    this.scale = undefined;\r\n    this.scales = {};\r\n    this.showLine = true;\r\n    this.drawActiveElementsOnTop = true;\r\n\r\n    this.describe(_descriptors);\r\n    this.apply(_appliers);\r\n  }\r\n\r\n  /**\r\n\t * @param {string|object} scope\r\n\t * @param {object} [values]\r\n\t */\r\n  set(scope, values) {\r\n    return set(this, scope, values);\r\n  }\r\n\r\n  /**\r\n\t * @param {string} scope\r\n\t */\r\n  get(scope) {\r\n    return getScope(this, scope);\r\n  }\r\n\r\n  /**\r\n\t * @param {string|object} scope\r\n\t * @param {object} [values]\r\n\t */\r\n  describe(scope, values) {\r\n    return set(descriptors, scope, values);\r\n  }\r\n\r\n  override(scope, values) {\r\n    return set(overrides, scope, values);\r\n  }\r\n\r\n  /**\r\n\t * Routes the named defaults to fallback to another scope/name.\r\n\t * This routing is useful when those target values, like defaults.color, are changed runtime.\r\n\t * If the values would be copied, the runtime change would not take effect. By routing, the\r\n\t * fallback is evaluated at each access, so its always up to date.\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t * \tdefaults.route('elements.arc', 'backgroundColor', '', 'color')\r\n\t *   - reads the backgroundColor from defaults.color when undefined locally\r\n\t *\r\n\t * @param {string} scope Scope this route applies to.\r\n\t * @param {string} name Property name that should be routed to different namespace when not defined here.\r\n\t * @param {string} targetScope The namespace where those properties should be routed to.\r\n\t * Empty string ('') is the root of defaults.\r\n\t * @param {string} targetName The target name in the target scope the property should be routed to.\r\n\t */\r\n  route(scope, name, targetScope, targetName) {\r\n    const scopeObject = getScope(this, scope);\r\n    const targetScopeObject = getScope(this, targetScope);\r\n    const privateName = '_' + name;\r\n\r\n    Object.defineProperties(scopeObject, {\r\n      // A private property is defined to hold the actual value, when this property is set in its scope (set in the setter)\r\n      [privateName]: {\r\n        value: scopeObject[name],\r\n        writable: true\r\n      },\r\n      // The actual property is defined as getter/setter so we can do the routing when value is not locally set.\r\n      [name]: {\r\n        enumerable: true,\r\n        get() {\r\n          const local = this[privateName];\r\n          const target = targetScopeObject[targetName];\r\n          if (isObject(local)) {\r\n            return Object.assign({}, target, local);\r\n          }\r\n          return valueOrDefault(local, target);\r\n        },\r\n        set(value) {\r\n          this[privateName] = value;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  apply(appliers) {\r\n    appliers.forEach((apply) => apply(this));\r\n  }\r\n}\r\n\r\n// singleton instance\r\nexport default /* #__PURE__ */ new Defaults({\r\n  _scriptable: (name) => !name.startsWith('on'),\r\n  _indexable: (name) => name !== 'events',\r\n  hover: {\r\n    _fallback: 'interaction'\r\n  },\r\n  interaction: {\r\n    _scriptable: false,\r\n    _indexable: false,\r\n  }\r\n}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);\r\n","export function applyLayoutsDefaults(defaults) {\r\n  defaults.set('layout', {\r\n    autoPadding: true,\r\n    padding: {\r\n      top: 0,\r\n      right: 0,\r\n      bottom: 0,\r\n      left: 0\r\n    }\r\n  });\r\n}\r\n","import Ticks from './core.ticks.js';\r\n\r\nexport function applyScaleDefaults(defaults) {\r\n  defaults.set('scale', {\r\n    display: true,\r\n    offset: false,\r\n    reverse: false,\r\n    beginAtZero: false,\r\n\r\n    /**\r\n     * Scale boundary strategy (bypassed by min/max time options)\r\n     * - `data`: make sure data are fully visible, ticks outside are removed\r\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\r\n     * @see https://github.com/chartjs/Chart.js/pull/4556\r\n     * @since 3.0.0\r\n     */\r\n    bounds: 'ticks',\r\n\r\n    /**\r\n     * Addition grace added to max and reduced from min data value.\r\n     * @since 3.0.0\r\n     */\r\n    grace: 0,\r\n\r\n    // grid line settings\r\n    grid: {\r\n      display: true,\r\n      lineWidth: 1,\r\n      drawOnChartArea: true,\r\n      drawTicks: true,\r\n      tickLength: 8,\r\n      tickWidth: (_ctx, options) => options.lineWidth,\r\n      tickColor: (_ctx, options) => options.color,\r\n      offset: false,\r\n    },\r\n\r\n    border: {\r\n      display: true,\r\n      dash: [],\r\n      dashOffset: 0.0,\r\n      width: 1\r\n    },\r\n\r\n    // scale title\r\n    title: {\r\n      // display property\r\n      display: false,\r\n\r\n      // actual label\r\n      text: '',\r\n\r\n      // top/bottom padding\r\n      padding: {\r\n        top: 4,\r\n        bottom: 4\r\n      }\r\n    },\r\n\r\n    // label settings\r\n    ticks: {\r\n      minRotation: 0,\r\n      maxRotation: 50,\r\n      mirror: false,\r\n      textStrokeWidth: 0,\r\n      textStrokeColor: '',\r\n      padding: 3,\r\n      display: true,\r\n      autoSkip: true,\r\n      autoSkipPadding: 3,\r\n      labelOffset: 0,\r\n      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\r\n      callback: Ticks.formatters.values,\r\n      minor: {},\r\n      major: {},\r\n      align: 'center',\r\n      crossAlign: 'near',\r\n\r\n      showLabelBackdrop: false,\r\n      backdropColor: 'rgba(255, 255, 255, 0.75)',\r\n      backdropPadding: 2,\r\n    }\r\n  });\r\n\r\n  defaults.route('scale.ticks', 'color', '', 'color');\r\n  defaults.route('scale.grid', 'color', '', 'borderColor');\r\n  defaults.route('scale.border', 'color', '', 'borderColor');\r\n  defaults.route('scale.title', 'color', '', 'color');\r\n\r\n  defaults.describe('scale', {\r\n    _fallback: false,\r\n    _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\r\n    _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash',\r\n  });\r\n\r\n  defaults.describe('scales', {\r\n    _fallback: 'scale',\r\n  });\r\n\r\n  defaults.describe('scale.ticks', {\r\n    _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\r\n    _indexable: (name) => name !== 'backdropPadding',\r\n  });\r\n}\r\n","import type {ChartArea, Scale} from '../types/index.js';\r\nimport type Chart from '../core/core.controller.js';\r\nimport type {ChartEvent} from '../types.js';\r\nimport {INFINITY} from './helpers.math.js';\r\n\r\n/**\r\n * Note: typedefs are auto-exported, so use a made-up `dom` namespace where\r\n * necessary to avoid duplicates with `export * from './helpers`; see\r\n * https://github.com/microsoft/TypeScript/issues/46011\r\n * @typedef { import('../core/core.controller.js').default } dom.Chart\r\n * @typedef { import('../../types').ChartEvent } ChartEvent\r\n */\r\n\r\n/**\r\n * @private\r\n */\r\nexport function _isDomSupported(): boolean {\r\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function _getParentNode(domNode: HTMLCanvasElement): HTMLCanvasElement {\r\n  let parent = domNode.parentNode;\r\n  if (parent && parent.toString() === '[object ShadowRoot]') {\r\n    parent = (parent as ShadowRoot).host;\r\n  }\r\n  return parent as HTMLCanvasElement;\r\n}\r\n\r\n/**\r\n * convert max-width/max-height values that may be percentages into a number\r\n * @private\r\n */\r\n\r\nfunction parseMaxStyle(styleValue: string | number, node: HTMLElement, parentProperty: string) {\r\n  let valueInPixels: number;\r\n  if (typeof styleValue === 'string') {\r\n    valueInPixels = parseInt(styleValue, 10);\r\n\r\n    if (styleValue.indexOf('%') !== -1) {\r\n      // percentage * size in dimension\r\n      valueInPixels = (valueInPixels / 100) * node.parentNode[parentProperty];\r\n    }\r\n  } else {\r\n    valueInPixels = styleValue;\r\n  }\r\n\r\n  return valueInPixels;\r\n}\r\n\r\nconst getComputedStyle = (element: HTMLElement): CSSStyleDeclaration =>\r\n  element.ownerDocument.defaultView.getComputedStyle(element, null);\r\n\r\nexport function getStyle(el: HTMLElement, property: string): string {\r\n  return getComputedStyle(el).getPropertyValue(property);\r\n}\r\n\r\nconst positions = ['top', 'right', 'bottom', 'left'];\r\nfunction getPositionedStyle(styles: CSSStyleDeclaration, style: string, suffix?: string): ChartArea {\r\n  const result = {} as ChartArea;\r\n  suffix = suffix ? '-' + suffix : '';\r\n  for (let i = 0; i < 4; i++) {\r\n    const pos = positions[i];\r\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\r\n  }\r\n  result.width = result.left + result.right;\r\n  result.height = result.top + result.bottom;\r\n  return result;\r\n}\r\n\r\nconst useOffsetPos = (x: number, y: number, target: HTMLElement | EventTarget) =>\r\n  (x > 0 || y > 0) && (!target || !(target as HTMLElement).shadowRoot);\r\n\r\n/**\r\n * @param e\r\n * @param canvas\r\n * @returns Canvas position\r\n */\r\nfunction getCanvasPosition(\r\n  e: Event | TouchEvent | MouseEvent,\r\n  canvas: HTMLCanvasElement\r\n): {\r\n    x: number;\r\n    y: number;\r\n    box: boolean;\r\n  } {\r\n  const touches = (e as TouchEvent).touches;\r\n  const source = (touches && touches.length ? touches[0] : e) as MouseEvent;\r\n  const {offsetX, offsetY} = source as MouseEvent;\r\n  let box = false;\r\n  let x, y;\r\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\r\n    x = offsetX;\r\n    y = offsetY;\r\n  } else {\r\n    const rect = canvas.getBoundingClientRect();\r\n    x = source.clientX - rect.left;\r\n    y = source.clientY - rect.top;\r\n    box = true;\r\n  }\r\n  return {x, y, box};\r\n}\r\n\r\n/**\r\n * Gets an event's x, y coordinates, relative to the chart area\r\n * @param event\r\n * @param chart\r\n * @returns x and y coordinates of the event\r\n */\r\n\r\nexport function getRelativePosition(\r\n  event: Event | ChartEvent | TouchEvent | MouseEvent,\r\n  chart: Chart\r\n): { x: number; y: number } {\r\n  if ('native' in event) {\r\n    return event;\r\n  }\r\n\r\n  const {canvas, currentDevicePixelRatio} = chart;\r\n  const style = getComputedStyle(canvas);\r\n  const borderBox = style.boxSizing === 'border-box';\r\n  const paddings = getPositionedStyle(style, 'padding');\r\n  const borders = getPositionedStyle(style, 'border', 'width');\r\n  const {x, y, box} = getCanvasPosition(event, canvas);\r\n  const xOffset = paddings.left + (box && borders.left);\r\n  const yOffset = paddings.top + (box && borders.top);\r\n\r\n  let {width, height} = chart;\r\n  if (borderBox) {\r\n    width -= paddings.width + borders.width;\r\n    height -= paddings.height + borders.height;\r\n  }\r\n  return {\r\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\r\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\r\n  };\r\n}\r\n\r\nfunction getContainerSize(canvas: HTMLCanvasElement, width: number, height: number): Partial<Scale> {\r\n  let maxWidth: number, maxHeight: number;\r\n\r\n  if (width === undefined || height === undefined) {\r\n    const container = _getParentNode(canvas);\r\n    if (!container) {\r\n      width = canvas.clientWidth;\r\n      height = canvas.clientHeight;\r\n    } else {\r\n      const rect = container.getBoundingClientRect(); // this is the border box of the container\r\n      const containerStyle = getComputedStyle(container);\r\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\r\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\r\n      width = rect.width - containerPadding.width - containerBorder.width;\r\n      height = rect.height - containerPadding.height - containerBorder.height;\r\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\r\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\r\n    }\r\n  }\r\n  return {\r\n    width,\r\n    height,\r\n    maxWidth: maxWidth || INFINITY,\r\n    maxHeight: maxHeight || INFINITY\r\n  };\r\n}\r\n\r\nconst round1 = (v: number) => Math.round(v * 10) / 10;\r\n\r\n// eslint-disable-next-line complexity\r\nexport function getMaximumSize(\r\n  canvas: HTMLCanvasElement,\r\n  bbWidth?: number,\r\n  bbHeight?: number,\r\n  aspectRatio?: number\r\n): { width: number; height: number } {\r\n  const style = getComputedStyle(canvas);\r\n  const margins = getPositionedStyle(style, 'margin');\r\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\r\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\r\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\r\n  let {width, height} = containerSize;\r\n\r\n  if (style.boxSizing === 'content-box') {\r\n    const borders = getPositionedStyle(style, 'border', 'width');\r\n    const paddings = getPositionedStyle(style, 'padding');\r\n    width -= paddings.width + borders.width;\r\n    height -= paddings.height + borders.height;\r\n  }\r\n  width = Math.max(0, width - margins.width);\r\n  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\r\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\r\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\r\n  if (width && !height) {\r\n    // https://github.com/chartjs/Chart.js/issues/4659\r\n    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\r\n    height = round1(width / 2);\r\n  }\r\n\r\n  const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\r\n\r\n  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\r\n    height = containerSize.height;\r\n    width = round1(Math.floor(height * aspectRatio));\r\n  }\r\n\r\n  return {width, height};\r\n}\r\n\r\n/**\r\n * @param chart\r\n * @param forceRatio\r\n * @param forceStyle\r\n * @returns True if the canvas context size or transformation has changed.\r\n */\r\nexport function retinaScale(\r\n  chart: Chart,\r\n  forceRatio: number,\r\n  forceStyle?: boolean\r\n): boolean | void {\r\n  const pixelRatio = forceRatio || 1;\r\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\r\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\r\n\r\n  chart.height = Math.floor(chart.height);\r\n  chart.width = Math.floor(chart.width);\r\n\r\n  const canvas = chart.canvas;\r\n\r\n  // If no style has been set on the canvas, the render size is used as display size,\r\n  // making the chart visually bigger, so let's enforce it to the \"correct\" values.\r\n  // See https://github.com/chartjs/Chart.js/issues/3575\r\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\r\n    canvas.style.height = `${chart.height}px`;\r\n    canvas.style.width = `${chart.width}px`;\r\n  }\r\n\r\n  if (chart.currentDevicePixelRatio !== pixelRatio\r\n      || canvas.height !== deviceHeight\r\n      || canvas.width !== deviceWidth) {\r\n    chart.currentDevicePixelRatio = pixelRatio;\r\n    canvas.height = deviceHeight;\r\n    canvas.width = deviceWidth;\r\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Detects support for options object argument in addEventListener.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\r\n * @private\r\n */\r\nexport const supportsEventListenerOptions = (function() {\r\n  let passiveSupported = false;\r\n  try {\r\n    const options = {\r\n      get passive() { // This function will be called when the browser attempts to access the passive property.\r\n        passiveSupported = true;\r\n        return false;\r\n      }\r\n    } as EventListenerOptions;\r\n\r\n    window.addEventListener('test', null, options);\r\n    window.removeEventListener('test', null, options);\r\n  } catch (e) {\r\n    // continue regardless of error\r\n  }\r\n  return passiveSupported;\r\n}());\r\n\r\n/**\r\n * The \"used\" size is the final value of a dimension property after all calculations have\r\n * been performed. This method uses the computed style of `element` but returns undefined\r\n * if the computed style is not expressed in pixels. That can happen in some cases where\r\n * `element` has a size relative to its parent and this last one is not yet displayed,\r\n * for example because of `display: none` on a parent node.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\r\n * @returns Size in pixels or undefined if unknown.\r\n */\r\n\r\nexport function readUsedSize(\r\n  element: HTMLElement,\r\n  property: 'width' | 'height'\r\n): number | undefined {\r\n  const value = getStyle(element, property);\r\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\r\n  return matches ? +matches[1] : undefined;\r\n}\r\n","import type {\r\n  Chart,\r\n  Point,\r\n  FontSpec,\r\n  CanvasFontSpec,\r\n  PointStyle,\r\n  RenderTextOpts,\r\n  BackdropOptions\r\n} from '../types/index.js';\r\nimport type {\r\n  TRBL,\r\n  SplinePoint,\r\n  RoundedRect,\r\n  TRBLCorners\r\n} from '../types/geometric.js';\r\nimport {isArray, isNullOrUndef} from './helpers.core.js';\r\nimport {PI, TAU, HALF_PI, QUARTER_PI, TWO_THIRDS_PI, RAD_PER_DEG} from './helpers.math.js';\r\n\r\n/**\r\n * Converts the given font object into a CSS font string.\r\n * @param font - A font object.\r\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\r\n * @private\r\n */\r\nexport function toFontString(font: FontSpec) {\r\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\r\n    return null;\r\n  }\r\n\r\n  return (font.style ? font.style + ' ' : '')\r\n\t\t+ (font.weight ? font.weight + ' ' : '')\r\n\t\t+ font.size + 'px '\r\n\t\t+ font.family;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function _measureText(\r\n  ctx: CanvasRenderingContext2D,\r\n  data: Record<string, number>,\r\n  gc: string[],\r\n  longest: number,\r\n  string: string\r\n) {\r\n  let textWidth = data[string];\r\n  if (!textWidth) {\r\n    textWidth = data[string] = ctx.measureText(string).width;\r\n    gc.push(string);\r\n  }\r\n  if (textWidth > longest) {\r\n    longest = textWidth;\r\n  }\r\n  return longest;\r\n}\r\n\r\ntype Thing = string | undefined | null\r\ntype Things = (Thing | Thing[])[]\r\n\r\n/**\r\n * @private\r\n */\r\n// eslint-disable-next-line complexity\r\nexport function _longestText(\r\n  ctx: CanvasRenderingContext2D,\r\n  font: string,\r\n  arrayOfThings: Things,\r\n  cache?: {data?: Record<string, number>, garbageCollect?: string[], font?: string}\r\n) {\r\n  cache = cache || {};\r\n  let data = cache.data = cache.data || {};\r\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\r\n\r\n  if (cache.font !== font) {\r\n    data = cache.data = {};\r\n    gc = cache.garbageCollect = [];\r\n    cache.font = font;\r\n  }\r\n\r\n  ctx.save();\r\n\r\n  ctx.font = font;\r\n  let longest = 0;\r\n  const ilen = arrayOfThings.length;\r\n  let i: number, j: number, jlen: number, thing: Thing | Thing[], nestedThing: Thing | Thing[];\r\n  for (i = 0; i < ilen; i++) {\r\n    thing = arrayOfThings[i];\r\n\r\n    // Undefined strings and arrays should not be measured\r\n    if (thing !== undefined && thing !== null && !isArray(thing)) {\r\n      longest = _measureText(ctx, data, gc, longest, thing);\r\n    } else if (isArray(thing)) {\r\n      // if it is an array lets measure each element\r\n      // to do maybe simplify this function a bit so we can do this more recursively?\r\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\r\n        nestedThing = thing[j];\r\n        // Undefined strings and arrays should not be measured\r\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\r\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  ctx.restore();\r\n\r\n  const gcLen = gc.length / 2;\r\n  if (gcLen > arrayOfThings.length) {\r\n    for (i = 0; i < gcLen; i++) {\r\n      delete data[gc[i]];\r\n    }\r\n    gc.splice(0, gcLen);\r\n  }\r\n  return longest;\r\n}\r\n\r\n/**\r\n * Returns the aligned pixel value to avoid anti-aliasing blur\r\n * @param chart - The chart instance.\r\n * @param pixel - A pixel value.\r\n * @param width - The width of the element.\r\n * @returns The aligned pixel value.\r\n * @private\r\n */\r\nexport function _alignPixel(chart: Chart, pixel: number, width: number) {\r\n  const devicePixelRatio = chart.currentDevicePixelRatio;\r\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\r\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\r\n}\r\n\r\n/**\r\n * Clears the entire canvas.\r\n */\r\nexport function clearCanvas(canvas: HTMLCanvasElement, ctx?: CanvasRenderingContext2D) {\r\n  ctx = ctx || canvas.getContext('2d');\r\n\r\n  ctx.save();\r\n  // canvas.width and canvas.height do not consider the canvas transform,\r\n  // while clearRect does\r\n  ctx.resetTransform();\r\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n  ctx.restore();\r\n}\r\n\r\nexport interface DrawPointOptions {\r\n  pointStyle: PointStyle;\r\n  rotation?: number;\r\n  radius: number;\r\n  borderWidth: number;\r\n}\r\n\r\nexport function drawPoint(\r\n  ctx: CanvasRenderingContext2D,\r\n  options: DrawPointOptions,\r\n  x: number,\r\n  y: number\r\n) {\r\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n  drawPointLegend(ctx, options, x, y, null);\r\n}\r\n\r\n// eslint-disable-next-line complexity\r\nexport function drawPointLegend(\r\n  ctx: CanvasRenderingContext2D,\r\n  options: DrawPointOptions,\r\n  x: number,\r\n  y: number,\r\n  w: number\r\n) {\r\n  let type: string, xOffset: number, yOffset: number, size: number, cornerRadius: number, width: number, xOffsetW: number, yOffsetW: number;\r\n  const style = options.pointStyle;\r\n  const rotation = options.rotation;\r\n  const radius = options.radius;\r\n  let rad = (rotation || 0) * RAD_PER_DEG;\r\n\r\n  if (style && typeof style === 'object') {\r\n    type = style.toString();\r\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\r\n      ctx.save();\r\n      ctx.translate(x, y);\r\n      ctx.rotate(rad);\r\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\r\n      ctx.restore();\r\n      return;\r\n    }\r\n  }\r\n\r\n  if (isNaN(radius) || radius <= 0) {\r\n    return;\r\n  }\r\n\r\n  ctx.beginPath();\r\n\r\n  switch (style) {\r\n  // Default includes circle\r\n    default:\r\n      if (w) {\r\n        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\r\n      } else {\r\n        ctx.arc(x, y, radius, 0, TAU);\r\n      }\r\n      ctx.closePath();\r\n      break;\r\n    case 'triangle':\r\n      width = w ? w / 2 : radius;\r\n      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\r\n      rad += TWO_THIRDS_PI;\r\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\r\n      rad += TWO_THIRDS_PI;\r\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\r\n      ctx.closePath();\r\n      break;\r\n    case 'rectRounded':\r\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\r\n    // `quadraticCurveTo` since it generates better results when rect is\r\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\r\n    // closer proportion to the previous impl and it is inscribed in the\r\n    // circle with `radius`. For more details, see the following PRs:\r\n    // https://github.com/chartjs/Chart.js/issues/5597\r\n    // https://github.com/chartjs/Chart.js/issues/5858\r\n      cornerRadius = radius * 0.516;\r\n      size = radius - cornerRadius;\r\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\r\n      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\r\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\r\n      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\r\n      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\r\n      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\r\n      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\r\n      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\r\n      ctx.closePath();\r\n      break;\r\n    case 'rect':\r\n      if (!rotation) {\r\n        size = Math.SQRT1_2 * radius;\r\n        width = w ? w / 2 : size;\r\n        ctx.rect(x - width, y - size, 2 * width, 2 * size);\r\n        break;\r\n      }\r\n      rad += QUARTER_PI;\r\n    /* falls through */\r\n    case 'rectRot':\r\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\r\n      xOffset = Math.cos(rad) * radius;\r\n      yOffset = Math.sin(rad) * radius;\r\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\r\n      ctx.moveTo(x - xOffsetW, y - yOffset);\r\n      ctx.lineTo(x + yOffsetW, y - xOffset);\r\n      ctx.lineTo(x + xOffsetW, y + yOffset);\r\n      ctx.lineTo(x - yOffsetW, y + xOffset);\r\n      ctx.closePath();\r\n      break;\r\n    case 'crossRot':\r\n      rad += QUARTER_PI;\r\n    /* falls through */\r\n    case 'cross':\r\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\r\n      xOffset = Math.cos(rad) * radius;\r\n      yOffset = Math.sin(rad) * radius;\r\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\r\n      ctx.moveTo(x - xOffsetW, y - yOffset);\r\n      ctx.lineTo(x + xOffsetW, y + yOffset);\r\n      ctx.moveTo(x + yOffsetW, y - xOffset);\r\n      ctx.lineTo(x - yOffsetW, y + xOffset);\r\n      break;\r\n    case 'star':\r\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\r\n      xOffset = Math.cos(rad) * radius;\r\n      yOffset = Math.sin(rad) * radius;\r\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\r\n      ctx.moveTo(x - xOffsetW, y - yOffset);\r\n      ctx.lineTo(x + xOffsetW, y + yOffset);\r\n      ctx.moveTo(x + yOffsetW, y - xOffset);\r\n      ctx.lineTo(x - yOffsetW, y + xOffset);\r\n      rad += QUARTER_PI;\r\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\r\n      xOffset = Math.cos(rad) * radius;\r\n      yOffset = Math.sin(rad) * radius;\r\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\r\n      ctx.moveTo(x - xOffsetW, y - yOffset);\r\n      ctx.lineTo(x + xOffsetW, y + yOffset);\r\n      ctx.moveTo(x + yOffsetW, y - xOffset);\r\n      ctx.lineTo(x - yOffsetW, y + xOffset);\r\n      break;\r\n    case 'line':\r\n      xOffset = w ? w / 2 : Math.cos(rad) * radius;\r\n      yOffset = Math.sin(rad) * radius;\r\n      ctx.moveTo(x - xOffset, y - yOffset);\r\n      ctx.lineTo(x + xOffset, y + yOffset);\r\n      break;\r\n    case 'dash':\r\n      ctx.moveTo(x, y);\r\n      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\r\n      break;\r\n    case false:\r\n      ctx.closePath();\r\n      break;\r\n  }\r\n\r\n  ctx.fill();\r\n  if (options.borderWidth > 0) {\r\n    ctx.stroke();\r\n  }\r\n}\r\n\r\n/**\r\n * Returns true if the point is inside the rectangle\r\n * @param point - The point to test\r\n * @param area - The rectangle\r\n * @param margin - allowed margin\r\n * @private\r\n */\r\nexport function _isPointInArea(\r\n  point: Point,\r\n  area: TRBL,\r\n  margin?: number\r\n) {\r\n  margin = margin || 0.5; // margin - default is to match rounded decimals\r\n\r\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\r\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\r\n}\r\n\r\nexport function clipArea(ctx: CanvasRenderingContext2D, area: TRBL) {\r\n  ctx.save();\r\n  ctx.beginPath();\r\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\r\n  ctx.clip();\r\n}\r\n\r\nexport function unclipArea(ctx: CanvasRenderingContext2D) {\r\n  ctx.restore();\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function _steppedLineTo(\r\n  ctx: CanvasRenderingContext2D,\r\n  previous: Point,\r\n  target: Point,\r\n  flip?: boolean,\r\n  mode?: string\r\n) {\r\n  if (!previous) {\r\n    return ctx.lineTo(target.x, target.y);\r\n  }\r\n  if (mode === 'middle') {\r\n    const midpoint = (previous.x + target.x) / 2.0;\r\n    ctx.lineTo(midpoint, previous.y);\r\n    ctx.lineTo(midpoint, target.y);\r\n  } else if (mode === 'after' !== !!flip) {\r\n    ctx.lineTo(previous.x, target.y);\r\n  } else {\r\n    ctx.lineTo(target.x, previous.y);\r\n  }\r\n  ctx.lineTo(target.x, target.y);\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function _bezierCurveTo(\r\n  ctx: CanvasRenderingContext2D,\r\n  previous: SplinePoint,\r\n  target: SplinePoint,\r\n  flip?: boolean\r\n) {\r\n  if (!previous) {\r\n    return ctx.lineTo(target.x, target.y);\r\n  }\r\n  ctx.bezierCurveTo(\r\n    flip ? previous.cp1x : previous.cp2x,\r\n    flip ? previous.cp1y : previous.cp2y,\r\n    flip ? target.cp2x : target.cp1x,\r\n    flip ? target.cp2y : target.cp1y,\r\n    target.x,\r\n    target.y);\r\n}\r\n\r\nfunction setRenderOpts(ctx: CanvasRenderingContext2D, opts: RenderTextOpts) {\r\n  if (opts.translation) {\r\n    ctx.translate(opts.translation[0], opts.translation[1]);\r\n  }\r\n\r\n  if (!isNullOrUndef(opts.rotation)) {\r\n    ctx.rotate(opts.rotation);\r\n  }\r\n\r\n  if (opts.color) {\r\n    ctx.fillStyle = opts.color;\r\n  }\r\n\r\n  if (opts.textAlign) {\r\n    ctx.textAlign = opts.textAlign;\r\n  }\r\n\r\n  if (opts.textBaseline) {\r\n    ctx.textBaseline = opts.textBaseline;\r\n  }\r\n}\r\n\r\nfunction decorateText(\r\n  ctx: CanvasRenderingContext2D,\r\n  x: number,\r\n  y: number,\r\n  line: string,\r\n  opts: RenderTextOpts\r\n) {\r\n  if (opts.strikethrough || opts.underline) {\r\n    /**\r\n     * Now that IE11 support has been dropped, we can use more\r\n     * of the TextMetrics object. The actual bounding boxes\r\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\r\n     * can be safely used.\r\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\r\n     */\r\n    const metrics = ctx.measureText(line);\r\n    const left = x - metrics.actualBoundingBoxLeft;\r\n    const right = x + metrics.actualBoundingBoxRight;\r\n    const top = y - metrics.actualBoundingBoxAscent;\r\n    const bottom = y + metrics.actualBoundingBoxDescent;\r\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\r\n\r\n    ctx.strokeStyle = ctx.fillStyle;\r\n    ctx.beginPath();\r\n    ctx.lineWidth = opts.decorationWidth || 2;\r\n    ctx.moveTo(left, yDecoration);\r\n    ctx.lineTo(right, yDecoration);\r\n    ctx.stroke();\r\n  }\r\n}\r\n\r\nfunction drawBackdrop(ctx: CanvasRenderingContext2D, opts: BackdropOptions) {\r\n  const oldColor = ctx.fillStyle;\r\n\r\n  ctx.fillStyle = opts.color as string;\r\n  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\r\n  ctx.fillStyle = oldColor;\r\n}\r\n\r\n/**\r\n * Render text onto the canvas\r\n */\r\nexport function renderText(\r\n  ctx: CanvasRenderingContext2D,\r\n  text: string | string[],\r\n  x: number,\r\n  y: number,\r\n  font: CanvasFontSpec,\r\n  opts: RenderTextOpts = {}\r\n) {\r\n  const lines = isArray(text) ? text : [text];\r\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\r\n  let i: number, line: string;\r\n\r\n  ctx.save();\r\n  ctx.font = font.string;\r\n  setRenderOpts(ctx, opts);\r\n\r\n  for (i = 0; i < lines.length; ++i) {\r\n    line = lines[i];\r\n\r\n    if (opts.backdrop) {\r\n      drawBackdrop(ctx, opts.backdrop);\r\n    }\r\n\r\n    if (stroke) {\r\n      if (opts.strokeColor) {\r\n        ctx.strokeStyle = opts.strokeColor;\r\n      }\r\n\r\n      if (!isNullOrUndef(opts.strokeWidth)) {\r\n        ctx.lineWidth = opts.strokeWidth;\r\n      }\r\n\r\n      ctx.strokeText(line, x, y, opts.maxWidth);\r\n    }\r\n\r\n    ctx.fillText(line, x, y, opts.maxWidth);\r\n    decorateText(ctx, x, y, line, opts);\r\n\r\n    y += Number(font.lineHeight);\r\n  }\r\n\r\n  ctx.restore();\r\n}\r\n\r\n/**\r\n * Add a path of a rectangle with rounded corners to the current sub-path\r\n * @param ctx - Context\r\n * @param rect - Bounding rect\r\n */\r\nexport function addRoundedRectPath(\r\n  ctx: CanvasRenderingContext2D,\r\n  rect: RoundedRect & { radius: TRBLCorners }\r\n) {\r\n  const {x, y, w, h, radius} = rect;\r\n\r\n  // top left arc\r\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\r\n\r\n  // line from top left to bottom left\r\n  ctx.lineTo(x, y + h - radius.bottomLeft);\r\n\r\n  // bottom left arc\r\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\r\n\r\n  // line from bottom left to bottom right\r\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\r\n\r\n  // bottom right arc\r\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\r\n\r\n  // line from bottom right to top right\r\n  ctx.lineTo(x + w, y + radius.topRight);\r\n\r\n  // top right arc\r\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\r\n\r\n  // line from top right to top left\r\n  ctx.lineTo(x + radius.topLeft, y);\r\n}\r\n","import {defined, isArray, isFunction, isObject, resolveObjectKey, _capitalize} from './helpers.core.js';\r\n\r\n/**\r\n * Creates a Proxy for resolving raw values for options.\r\n * @param {object[]} scopes - The option scopes to look for values, in resolution order\r\n * @param {string[]} [prefixes] - The prefixes for values, in resolution order.\r\n * @param {object[]} [rootScopes] - The root option scopes\r\n * @param {string|boolean} [fallback] - Parent scopes fallback\r\n * @param {function} [getTarget] - callback for getting the target for changed values\r\n * @returns Proxy\r\n * @private\r\n */\r\nexport function _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {\r\n  if (!defined(fallback)) {\r\n    fallback = _resolve('_fallback', scopes);\r\n  }\r\n  const cache = {\r\n    [Symbol.toStringTag]: 'Object',\r\n    _cacheable: true,\r\n    _scopes: scopes,\r\n    _rootScopes: rootScopes,\r\n    _fallback: fallback,\r\n    _getTarget: getTarget,\r\n    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),\r\n  };\r\n  return new Proxy(cache, {\r\n    /**\r\n     * A trap for the delete operator.\r\n     */\r\n    deleteProperty(target, prop) {\r\n      delete target[prop]; // remove from cache\r\n      delete target._keys; // remove cached keys\r\n      delete scopes[0][prop]; // remove from top level scope\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * A trap for getting property values.\r\n     */\r\n    get(target, prop) {\r\n      return _cached(target, prop,\r\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\r\n    },\r\n\r\n    /**\r\n     * A trap for Object.getOwnPropertyDescriptor.\r\n     * Also used by Object.hasOwnProperty.\r\n     */\r\n    getOwnPropertyDescriptor(target, prop) {\r\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\r\n    },\r\n\r\n    /**\r\n     * A trap for Object.getPrototypeOf.\r\n     */\r\n    getPrototypeOf() {\r\n      return Reflect.getPrototypeOf(scopes[0]);\r\n    },\r\n\r\n    /**\r\n     * A trap for the in operator.\r\n     */\r\n    has(target, prop) {\r\n      return getKeysFromAllScopes(target).includes(prop);\r\n    },\r\n\r\n    /**\r\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\r\n     */\r\n    ownKeys(target) {\r\n      return getKeysFromAllScopes(target);\r\n    },\r\n\r\n    /**\r\n     * A trap for setting property values.\r\n     */\r\n    set(target, prop, value) {\r\n      const storage = target._storage || (target._storage = getTarget());\r\n      target[prop] = storage[prop] = value; // set to top level scope + cache\r\n      delete target._keys; // remove cached keys\r\n      return true;\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Returns an Proxy for resolving option values with context.\r\n * @param {object} proxy - The Proxy returned by `_createResolver`\r\n * @param {object} context - Context object for scriptable/indexable options\r\n * @param {object} [subProxy] - The proxy provided for scriptable options\r\n * @param {{scriptable: boolean, indexable: boolean, allKeys?: boolean}} [descriptorDefaults] - Defaults for descriptors\r\n * @private\r\n */\r\nexport function _attachContext(proxy, context, subProxy, descriptorDefaults) {\r\n  const cache = {\r\n    _cacheable: false,\r\n    _proxy: proxy,\r\n    _context: context,\r\n    _subProxy: subProxy,\r\n    _stack: new Set(),\r\n    _descriptors: _descriptors(proxy, descriptorDefaults),\r\n    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\r\n    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\r\n  };\r\n  return new Proxy(cache, {\r\n    /**\r\n     * A trap for the delete operator.\r\n     */\r\n    deleteProperty(target, prop) {\r\n      delete target[prop]; // remove from cache\r\n      delete proxy[prop]; // remove from proxy\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * A trap for getting property values.\r\n     */\r\n    get(target, prop, receiver) {\r\n      return _cached(target, prop,\r\n        () => _resolveWithContext(target, prop, receiver));\r\n    },\r\n\r\n    /**\r\n     * A trap for Object.getOwnPropertyDescriptor.\r\n     * Also used by Object.hasOwnProperty.\r\n     */\r\n    getOwnPropertyDescriptor(target, prop) {\r\n      return target._descriptors.allKeys\r\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\r\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\r\n    },\r\n\r\n    /**\r\n     * A trap for Object.getPrototypeOf.\r\n     */\r\n    getPrototypeOf() {\r\n      return Reflect.getPrototypeOf(proxy);\r\n    },\r\n\r\n    /**\r\n     * A trap for the in operator.\r\n     */\r\n    has(target, prop) {\r\n      return Reflect.has(proxy, prop);\r\n    },\r\n\r\n    /**\r\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\r\n     */\r\n    ownKeys() {\r\n      return Reflect.ownKeys(proxy);\r\n    },\r\n\r\n    /**\r\n     * A trap for setting property values.\r\n     */\r\n    set(target, prop, value) {\r\n      proxy[prop] = value; // set to proxy\r\n      delete target[prop]; // remove from cache\r\n      return true;\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {\r\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\r\n  return {\r\n    allKeys: _allKeys,\r\n    scriptable: _scriptable,\r\n    indexable: _indexable,\r\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\r\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\r\n  };\r\n}\r\n\r\nconst readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\r\nconst needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' &&\r\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\r\n\r\nfunction _cached(target, prop, resolve) {\r\n  if (Object.prototype.hasOwnProperty.call(target, prop)) {\r\n    return target[prop];\r\n  }\r\n\r\n  const value = resolve();\r\n  // cache the resolved value\r\n  target[prop] = value;\r\n  return value;\r\n}\r\n\r\nfunction _resolveWithContext(target, prop, receiver) {\r\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\r\n  let value = _proxy[prop]; // resolve from proxy\r\n\r\n  // resolve with context\r\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\r\n    value = _resolveScriptable(prop, value, target, receiver);\r\n  }\r\n  if (isArray(value) && value.length) {\r\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\r\n  }\r\n  if (needsSubResolver(prop, value)) {\r\n    // if the resolved value is an object, create a sub resolver for it\r\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction _resolveScriptable(prop, value, target, receiver) {\r\n  const {_proxy, _context, _subProxy, _stack} = target;\r\n  if (_stack.has(prop)) {\r\n    // @ts-ignore\r\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\r\n  }\r\n  _stack.add(prop);\r\n  value = value(_context, _subProxy || receiver);\r\n  _stack.delete(prop);\r\n  if (needsSubResolver(prop, value)) {\r\n    // When scriptable option returns an object, create a resolver on that.\r\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction _resolveArray(prop, value, target, isIndexable) {\r\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\r\n\r\n  if (defined(_context.index) && isIndexable(prop)) {\r\n    value = value[_context.index % value.length];\r\n  } else if (isObject(value[0])) {\r\n    // Array of objects, return array or resolvers\r\n    const arr = value;\r\n    const scopes = _proxy._scopes.filter(s => s !== arr);\r\n    value = [];\r\n    for (const item of arr) {\r\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\r\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\r\n    }\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction resolveFallback(fallback, prop, value) {\r\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\r\n}\r\n\r\nconst getScope = (key, parent) => key === true ? parent\r\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\r\n\r\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\r\n  for (const parent of parentScopes) {\r\n    const scope = getScope(key, parent);\r\n    if (scope) {\r\n      set.add(scope);\r\n      const fallback = resolveFallback(scope._fallback, key, value);\r\n      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\r\n        // When we reach the descriptor that defines a new _fallback, return that.\r\n        // The fallback will resume to that new scope.\r\n        return fallback;\r\n      }\r\n    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\r\n      // Fallback to `false` results to `false`, when falling back to different key.\r\n      // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\r\n      return null;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction createSubResolver(parentScopes, resolver, prop, value) {\r\n  const rootScopes = resolver._rootScopes;\r\n  const fallback = resolveFallback(resolver._fallback, prop, value);\r\n  const allScopes = [...parentScopes, ...rootScopes];\r\n  const set = new Set();\r\n  set.add(value);\r\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\r\n  if (key === null) {\r\n    return false;\r\n  }\r\n  if (defined(fallback) && fallback !== prop) {\r\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\r\n    if (key === null) {\r\n      return false;\r\n    }\r\n  }\r\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\r\n    () => subGetTarget(resolver, prop, value));\r\n}\r\n\r\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\r\n  while (key) {\r\n    key = addScopes(set, allScopes, key, fallback, item);\r\n  }\r\n  return key;\r\n}\r\n\r\nfunction subGetTarget(resolver, prop, value) {\r\n  const parent = resolver._getTarget();\r\n  if (!(prop in parent)) {\r\n    parent[prop] = {};\r\n  }\r\n  const target = parent[prop];\r\n  if (isArray(target) && isObject(value)) {\r\n    // For array of objects, the object is used to store updated values\r\n    return value;\r\n  }\r\n  return target || {};\r\n}\r\n\r\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\r\n  let value;\r\n  for (const prefix of prefixes) {\r\n    value = _resolve(readKey(prefix, prop), scopes);\r\n    if (defined(value)) {\r\n      return needsSubResolver(prop, value)\r\n        ? createSubResolver(scopes, proxy, prop, value)\r\n        : value;\r\n    }\r\n  }\r\n}\r\n\r\nfunction _resolve(key, scopes) {\r\n  for (const scope of scopes) {\r\n    if (!scope) {\r\n      continue;\r\n    }\r\n    const value = scope[key];\r\n    if (defined(value)) {\r\n      return value;\r\n    }\r\n  }\r\n}\r\n\r\nfunction getKeysFromAllScopes(target) {\r\n  let keys = target._keys;\r\n  if (!keys) {\r\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\r\n  }\r\n  return keys;\r\n}\r\n\r\nfunction resolveKeysFromAllScopes(scopes) {\r\n  const set = new Set();\r\n  for (const scope of scopes) {\r\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\r\n      set.add(key);\r\n    }\r\n  }\r\n  return Array.from(set);\r\n}\r\n\r\nexport function _parseObjectDataRadialScale(meta, data, start, count) {\r\n  const {iScale} = meta;\r\n  const {key = 'r'} = this._parsing;\r\n  const parsed = new Array(count);\r\n  let i, ilen, index, item;\r\n\r\n  for (i = 0, ilen = count; i < ilen; ++i) {\r\n    index = i + start;\r\n    item = data[index];\r\n    parsed[i] = {\r\n      r: iScale.parse(resolveObjectKey(item, key), index)\r\n    };\r\n  }\r\n  return parsed;\r\n}\r\n","import {almostEquals, distanceBetweenPoints, sign} from './helpers.math.js';\r\nimport {_isPointInArea} from './helpers.canvas.js';\r\nimport type {ChartArea} from '../types/index.js';\r\nimport type {SplinePoint} from '../types/geometric.js';\r\n\r\nconst EPSILON = Number.EPSILON || 1e-14;\r\n\r\ntype OptionalSplinePoint = SplinePoint | false\r\nconst getPoint = (points: SplinePoint[], i: number): OptionalSplinePoint => i < points.length && !points[i].skip && points[i];\r\nconst getValueAxis = (indexAxis: 'x' | 'y') => indexAxis === 'x' ? 'y' : 'x';\r\n\r\nexport function splineCurve(\r\n  firstPoint: SplinePoint,\r\n  middlePoint: SplinePoint,\r\n  afterPoint: SplinePoint,\r\n  t: number\r\n): {\r\n    previous: SplinePoint\r\n    next: SplinePoint\r\n  } {\r\n  // Props to Rob Spencer at scaled innovation for his post on splining between points\r\n  // http://scaledinnovation.com/analytics/splines/aboutSplines.html\r\n\r\n  // This function must also respect \"skipped\" points\r\n\r\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\r\n  const current = middlePoint;\r\n  const next = afterPoint.skip ? middlePoint : afterPoint;\r\n  const d01 = distanceBetweenPoints(current, previous);\r\n  const d12 = distanceBetweenPoints(next, current);\r\n\r\n  let s01 = d01 / (d01 + d12);\r\n  let s12 = d12 / (d01 + d12);\r\n\r\n  // If all points are the same, s01 & s02 will be inf\r\n  s01 = isNaN(s01) ? 0 : s01;\r\n  s12 = isNaN(s12) ? 0 : s12;\r\n\r\n  const fa = t * s01; // scaling factor for triangle Ta\r\n  const fb = t * s12;\r\n\r\n  return {\r\n    previous: {\r\n      x: current.x - fa * (next.x - previous.x),\r\n      y: current.y - fa * (next.y - previous.y)\r\n    },\r\n    next: {\r\n      x: current.x + fb * (next.x - previous.x),\r\n      y: current.y + fb * (next.y - previous.y)\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Adjust tangents to ensure monotonic properties\r\n */\r\nfunction monotoneAdjust(points: SplinePoint[], deltaK: number[], mK: number[]) {\r\n  const pointsLen = points.length;\r\n\r\n  let alphaK: number, betaK: number, tauK: number, squaredMagnitude: number, pointCurrent: OptionalSplinePoint;\r\n  let pointAfter = getPoint(points, 0);\r\n  for (let i = 0; i < pointsLen - 1; ++i) {\r\n    pointCurrent = pointAfter;\r\n    pointAfter = getPoint(points, i + 1);\r\n    if (!pointCurrent || !pointAfter) {\r\n      continue;\r\n    }\r\n\r\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\r\n      mK[i] = mK[i + 1] = 0;\r\n      continue;\r\n    }\r\n\r\n    alphaK = mK[i] / deltaK[i];\r\n    betaK = mK[i + 1] / deltaK[i];\r\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\r\n    if (squaredMagnitude <= 9) {\r\n      continue;\r\n    }\r\n\r\n    tauK = 3 / Math.sqrt(squaredMagnitude);\r\n    mK[i] = alphaK * tauK * deltaK[i];\r\n    mK[i + 1] = betaK * tauK * deltaK[i];\r\n  }\r\n}\r\n\r\nfunction monotoneCompute(points: SplinePoint[], mK: number[], indexAxis: 'x' | 'y' = 'x') {\r\n  const valueAxis = getValueAxis(indexAxis);\r\n  const pointsLen = points.length;\r\n  let delta: number, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\r\n  let pointAfter = getPoint(points, 0);\r\n\r\n  for (let i = 0; i < pointsLen; ++i) {\r\n    pointBefore = pointCurrent;\r\n    pointCurrent = pointAfter;\r\n    pointAfter = getPoint(points, i + 1);\r\n    if (!pointCurrent) {\r\n      continue;\r\n    }\r\n\r\n    const iPixel = pointCurrent[indexAxis];\r\n    const vPixel = pointCurrent[valueAxis];\r\n    if (pointBefore) {\r\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\r\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\r\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\r\n    }\r\n    if (pointAfter) {\r\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\r\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\r\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This function calculates Bzier control points in a similar way than |splineCurve|,\r\n * but preserves monotonicity of the provided data and ensures no local extremums are added\r\n * between the dataset discrete points due to the interpolation.\r\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\r\n */\r\nexport function splineCurveMonotone(points: SplinePoint[], indexAxis: 'x' | 'y' = 'x') {\r\n  const valueAxis = getValueAxis(indexAxis);\r\n  const pointsLen = points.length;\r\n  const deltaK: number[] = Array(pointsLen).fill(0);\r\n  const mK: number[] = Array(pointsLen);\r\n\r\n  // Calculate slopes (deltaK) and initialize tangents (mK)\r\n  let i, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\r\n  let pointAfter = getPoint(points, 0);\r\n\r\n  for (i = 0; i < pointsLen; ++i) {\r\n    pointBefore = pointCurrent;\r\n    pointCurrent = pointAfter;\r\n    pointAfter = getPoint(points, i + 1);\r\n    if (!pointCurrent) {\r\n      continue;\r\n    }\r\n\r\n    if (pointAfter) {\r\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\r\n\r\n      // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\r\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\r\n    }\r\n    mK[i] = !pointBefore ? deltaK[i]\r\n      : !pointAfter ? deltaK[i - 1]\r\n        : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\r\n          : (deltaK[i - 1] + deltaK[i]) / 2;\r\n  }\r\n\r\n  monotoneAdjust(points, deltaK, mK);\r\n\r\n  monotoneCompute(points, mK, indexAxis);\r\n}\r\n\r\nfunction capControlPoint(pt: number, min: number, max: number) {\r\n  return Math.max(Math.min(pt, max), min);\r\n}\r\n\r\nfunction capBezierPoints(points: SplinePoint[], area: ChartArea) {\r\n  let i, ilen, point, inArea, inAreaPrev;\r\n  let inAreaNext = _isPointInArea(points[0], area);\r\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\r\n    inAreaPrev = inArea;\r\n    inArea = inAreaNext;\r\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\r\n    if (!inArea) {\r\n      continue;\r\n    }\r\n    point = points[i];\r\n    if (inAreaPrev) {\r\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\r\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\r\n    }\r\n    if (inAreaNext) {\r\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\r\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function _updateBezierControlPoints(\r\n  points: SplinePoint[],\r\n  options,\r\n  area: ChartArea,\r\n  loop: boolean,\r\n  indexAxis: 'x' | 'y'\r\n) {\r\n  let i: number, ilen: number, point: SplinePoint, controlPoints: ReturnType<typeof splineCurve>;\r\n\r\n  // Only consider points that are drawn in case the spanGaps option is used\r\n  if (options.spanGaps) {\r\n    points = points.filter((pt) => !pt.skip);\r\n  }\r\n\r\n  if (options.cubicInterpolationMode === 'monotone') {\r\n    splineCurveMonotone(points, indexAxis);\r\n  } else {\r\n    let prev = loop ? points[points.length - 1] : points[0];\r\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\r\n      point = points[i];\r\n      controlPoints = splineCurve(\r\n        prev,\r\n        point,\r\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\r\n        options.tension\r\n      );\r\n      point.cp1x = controlPoints.previous.x;\r\n      point.cp1y = controlPoints.previous.y;\r\n      point.cp2x = controlPoints.next.x;\r\n      point.cp2y = controlPoints.next.y;\r\n      prev = point;\r\n    }\r\n  }\r\n\r\n  if (options.capBezierPoints) {\r\n    capBezierPoints(points, area);\r\n  }\r\n}\r\n","import {PI, TAU, HALF_PI} from './helpers.math.js';\r\n\r\nconst atEdge = (t: number) => t === 0 || t === 1;\r\nconst elasticIn = (t: number, s: number, p: number) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\r\nconst elasticOut = (t: number, s: number, p: number) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\r\n\r\n/**\r\n * Easing functions adapted from Robert Penner's easing equations.\r\n * @namespace Chart.helpers.easing.effects\r\n * @see http://www.robertpenner.com/easing/\r\n */\r\nconst effects = {\r\n  linear: (t: number) => t,\r\n\r\n  easeInQuad: (t: number) => t * t,\r\n\r\n  easeOutQuad: (t: number) => -t * (t - 2),\r\n\r\n  easeInOutQuad: (t: number) => ((t /= 0.5) < 1)\r\n    ? 0.5 * t * t\r\n    : -0.5 * ((--t) * (t - 2) - 1),\r\n\r\n  easeInCubic: (t: number) => t * t * t,\r\n\r\n  easeOutCubic: (t: number) => (t -= 1) * t * t + 1,\r\n\r\n  easeInOutCubic: (t: number) => ((t /= 0.5) < 1)\r\n    ? 0.5 * t * t * t\r\n    : 0.5 * ((t -= 2) * t * t + 2),\r\n\r\n  easeInQuart: (t: number) => t * t * t * t,\r\n\r\n  easeOutQuart: (t: number) => -((t -= 1) * t * t * t - 1),\r\n\r\n  easeInOutQuart: (t: number) => ((t /= 0.5) < 1)\r\n    ? 0.5 * t * t * t * t\r\n    : -0.5 * ((t -= 2) * t * t * t - 2),\r\n\r\n  easeInQuint: (t: number) => t * t * t * t * t,\r\n\r\n  easeOutQuint: (t: number) => (t -= 1) * t * t * t * t + 1,\r\n\r\n  easeInOutQuint: (t: number) => ((t /= 0.5) < 1)\r\n    ? 0.5 * t * t * t * t * t\r\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\r\n\r\n  easeInSine: (t: number) => -Math.cos(t * HALF_PI) + 1,\r\n\r\n  easeOutSine: (t: number) => Math.sin(t * HALF_PI),\r\n\r\n  easeInOutSine: (t: number) => -0.5 * (Math.cos(PI * t) - 1),\r\n\r\n  easeInExpo: (t: number) => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\r\n\r\n  easeOutExpo: (t: number) => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\r\n\r\n  easeInOutExpo: (t: number) => atEdge(t) ? t : t < 0.5\r\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\r\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\r\n\r\n  easeInCirc: (t: number) => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\r\n\r\n  easeOutCirc: (t: number) => Math.sqrt(1 - (t -= 1) * t),\r\n\r\n  easeInOutCirc: (t: number) => ((t /= 0.5) < 1)\r\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\r\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\r\n\r\n  easeInElastic: (t: number) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\r\n\r\n  easeOutElastic: (t: number) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\r\n\r\n  easeInOutElastic(t: number) {\r\n    const s = 0.1125;\r\n    const p = 0.45;\r\n    return atEdge(t) ? t :\r\n      t < 0.5\r\n        ? 0.5 * elasticIn(t * 2, s, p)\r\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\r\n  },\r\n\r\n  easeInBack(t: number) {\r\n    const s = 1.70158;\r\n    return t * t * ((s + 1) * t - s);\r\n  },\r\n\r\n  easeOutBack(t: number) {\r\n    const s = 1.70158;\r\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\r\n  },\r\n\r\n  easeInOutBack(t: number) {\r\n    let s = 1.70158;\r\n    if ((t /= 0.5) < 1) {\r\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\r\n    }\r\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\r\n  },\r\n\r\n  easeInBounce: (t: number) => 1 - effects.easeOutBounce(1 - t),\r\n\r\n  easeOutBounce(t: number) {\r\n    const m = 7.5625;\r\n    const d = 2.75;\r\n    if (t < (1 / d)) {\r\n      return m * t * t;\r\n    }\r\n    if (t < (2 / d)) {\r\n      return m * (t -= (1.5 / d)) * t + 0.75;\r\n    }\r\n    if (t < (2.5 / d)) {\r\n      return m * (t -= (2.25 / d)) * t + 0.9375;\r\n    }\r\n    return m * (t -= (2.625 / d)) * t + 0.984375;\r\n  },\r\n\r\n  easeInOutBounce: (t: number) => (t < 0.5)\r\n    ? effects.easeInBounce(t * 2) * 0.5\r\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\r\n} as const;\r\n\r\nexport type EasingFunction = keyof typeof effects\r\n\r\nexport default effects;\r\n","import type {Point, SplinePoint} from '../types/geometric.js';\r\n\r\n/**\r\n * @private\r\n */\r\nexport function _pointInLine(p1: Point, p2: Point, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\r\n  return {\r\n    x: p1.x + t * (p2.x - p1.x),\r\n    y: p1.y + t * (p2.y - p1.y)\r\n  };\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function _steppedInterpolation(\r\n  p1: Point,\r\n  p2: Point,\r\n  t: number, mode: 'middle' | 'after' | unknown\r\n) {\r\n  return {\r\n    x: p1.x + t * (p2.x - p1.x),\r\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\r\n      : mode === 'after' ? t < 1 ? p1.y : p2.y\r\n        : t > 0 ? p2.y : p1.y\r\n  };\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function _bezierInterpolation(p1: SplinePoint, p2: SplinePoint, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\r\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\r\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\r\n  const a = _pointInLine(p1, cp1, t);\r\n  const b = _pointInLine(cp1, cp2, t);\r\n  const c = _pointInLine(cp2, p2, t);\r\n  const d = _pointInLine(a, b, t);\r\n  const e = _pointInLine(b, c, t);\r\n  return _pointInLine(d, e, t);\r\n}\r\n","import defaults from '../core/core.defaults.js';\r\nimport {isArray, isObject, toDimension, valueOrDefault} from './helpers.core.js';\r\nimport {toFontString} from './helpers.canvas.js';\r\nimport type {ChartArea, FontSpec, Point} from '../types/index.js';\r\nimport type {TRBL, TRBLCorners} from '../types/geometric.js';\r\n\r\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\r\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\r\n\r\n/**\r\n * @alias Chart.helpers.options\r\n * @namespace\r\n */\r\n/**\r\n * Converts the given line height `value` in pixels for a specific font `size`.\r\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\r\n * @param size - The font size (in pixels) used to resolve relative `value`.\r\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\r\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\r\n * @since 2.7.0\r\n */\r\nexport function toLineHeight(value: number | string, size: number): number {\r\n  const matches = ('' + value).match(LINE_HEIGHT);\r\n  if (!matches || matches[1] === 'normal') {\r\n    return size * 1.2;\r\n  }\r\n\r\n  value = +matches[2];\r\n\r\n  switch (matches[3]) {\r\n    case 'px':\r\n      return value;\r\n    case '%':\r\n      value /= 100;\r\n      break;\r\n    default:\r\n      break;\r\n  }\r\n\r\n  return size * value;\r\n}\r\n\r\nconst numberOrZero = (v: unknown) => +v || 0;\r\n\r\n/**\r\n * @param value\r\n * @param props\r\n */\r\nexport function _readValueToProps<K extends string>(value: number | Record<K, number>, props: K[]): Record<K, number>;\r\nexport function _readValueToProps<K extends string, T extends string>(value: number | Record<K & T, number>, props: Record<T, K>): Record<T, number>;\r\nexport function _readValueToProps(value: number | Record<string, number>, props: string[] | Record<string, string>) {\r\n  const ret = {};\r\n  const objProps = isObject(props);\r\n  const keys = objProps ? Object.keys(props) : props;\r\n  const read = isObject(value)\r\n    ? objProps\r\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\r\n      : prop => value[prop]\r\n    : () => value;\r\n\r\n  for (const prop of keys) {\r\n    ret[prop] = numberOrZero(read(prop));\r\n  }\r\n  return ret;\r\n}\r\n\r\n/**\r\n * Converts the given value into a TRBL object.\r\n * @param value - If a number, set the value to all TRBL component,\r\n *  else, if an object, use defined properties and sets undefined ones to 0.\r\n *  x / y are shorthands for same value for left/right and top/bottom.\r\n * @returns The padding values (top, right, bottom, left)\r\n * @since 3.0.0\r\n */\r\nexport function toTRBL(value: number | TRBL | Point) {\r\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\r\n}\r\n\r\n/**\r\n * Converts the given value into a TRBL corners object (similar with css border-radius).\r\n * @param value - If a number, set the value to all TRBL corner components,\r\n *  else, if an object, use defined properties and sets undefined ones to 0.\r\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\r\n * @since 3.0.0\r\n */\r\nexport function toTRBLCorners(value: number | TRBLCorners) {\r\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\r\n}\r\n\r\n/**\r\n * Converts the given value into a padding object with pre-computed width/height.\r\n * @param value - If a number, set the value to all TRBL component,\r\n *  else, if an object, use defined properties and sets undefined ones to 0.\r\n *  x / y are shorthands for same value for left/right and top/bottom.\r\n * @returns The padding values (top, right, bottom, left, width, height)\r\n * @since 2.7.0\r\n */\r\nexport function toPadding(value?: number | TRBL): ChartArea {\r\n  const obj = toTRBL(value) as ChartArea;\r\n\r\n  obj.width = obj.left + obj.right;\r\n  obj.height = obj.top + obj.bottom;\r\n\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Parses font options and returns the font object.\r\n * @param options - A object that contains font options to be parsed.\r\n * @param fallback - A object that contains fallback font options.\r\n * @return The font object.\r\n * @private\r\n */\r\n\r\nexport function toFont(options: Partial<FontSpec>, fallback?: Partial<FontSpec>) {\r\n  options = options || {};\r\n  fallback = fallback || defaults.font as FontSpec;\r\n\r\n  let size = valueOrDefault(options.size, fallback.size);\r\n\r\n  if (typeof size === 'string') {\r\n    size = parseInt(size, 10);\r\n  }\r\n  let style = valueOrDefault(options.style, fallback.style);\r\n  if (style && !('' + style).match(FONT_STYLE)) {\r\n    console.warn('Invalid font style specified: \"' + style + '\"');\r\n    style = undefined;\r\n  }\r\n\r\n  const font = {\r\n    family: valueOrDefault(options.family, fallback.family),\r\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\r\n    size,\r\n    style,\r\n    weight: valueOrDefault(options.weight, fallback.weight),\r\n    string: ''\r\n  };\r\n\r\n  font.string = toFontString(font);\r\n  return font;\r\n}\r\n\r\n/**\r\n * Evaluates the given `inputs` sequentially and returns the first defined value.\r\n * @param inputs - An array of values, falling back to the last value.\r\n * @param context - If defined and the current value is a function, the value\r\n * is called with `context` as first argument and the result becomes the new input.\r\n * @param index - If defined and the current value is an array, the value\r\n * at `index` become the new input.\r\n * @param info - object to return information about resolution in\r\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\r\n * @since 2.7.0\r\n */\r\nexport function resolve(inputs: Array<unknown>, context?: object, index?: number, info?: { cacheable: boolean }) {\r\n  let cacheable = true;\r\n  let i: number, ilen: number, value: unknown;\r\n\r\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\r\n    value = inputs[i];\r\n    if (value === undefined) {\r\n      continue;\r\n    }\r\n    if (context !== undefined && typeof value === 'function') {\r\n      value = value(context);\r\n      cacheable = false;\r\n    }\r\n    if (index !== undefined && isArray(value)) {\r\n      value = value[index % value.length];\r\n      cacheable = false;\r\n    }\r\n    if (value !== undefined) {\r\n      if (info && !cacheable) {\r\n        info.cacheable = false;\r\n      }\r\n      return value;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param minmax\r\n * @param grace\r\n * @param beginAtZero\r\n * @private\r\n */\r\nexport function _addGrace(minmax: { min: number; max: number; }, grace: number | string, beginAtZero: boolean) {\r\n  const {min, max} = minmax;\r\n  const change = toDimension(grace, (max - min) / 2);\r\n  const keepZero = (value: number, add: number) => beginAtZero && value === 0 ? 0 : value + add;\r\n  return {\r\n    min: keepZero(min, -Math.abs(change)),\r\n    max: keepZero(max, change)\r\n  };\r\n}\r\n\r\n/**\r\n * Create a context inheriting parentContext\r\n * @param parentContext\r\n * @param context\r\n * @returns\r\n */\r\nexport function createContext<T extends object>(parentContext: null, context: T): T;\r\nexport function createContext<T extends object, P extends T>(parentContext: P, context: T): P & T;\r\nexport function createContext(parentContext: object, context: object) {\r\n  return Object.assign(Object.create(parentContext), context);\r\n}\r\n","export interface RTLAdapter {\r\n  x(x: number): number;\r\n  setWidth(w: number): void;\r\n  textAlign(align: 'center' | 'left' | 'right'): 'center' | 'left' | 'right';\r\n  xPlus(x: number, value: number): number;\r\n  leftForLtr(x: number, itemWidth: number): number;\r\n}\r\n\r\nconst getRightToLeftAdapter = function(rectX: number, width: number): RTLAdapter {\r\n  return {\r\n    x(x) {\r\n      return rectX + rectX + width - x;\r\n    },\r\n    setWidth(w) {\r\n      width = w;\r\n    },\r\n    textAlign(align) {\r\n      if (align === 'center') {\r\n        return align;\r\n      }\r\n      return align === 'right' ? 'left' : 'right';\r\n    },\r\n    xPlus(x, value) {\r\n      return x - value;\r\n    },\r\n    leftForLtr(x, itemWidth) {\r\n      return x - itemWidth;\r\n    },\r\n  };\r\n};\r\n\r\nconst getLeftToRightAdapter = function(): RTLAdapter {\r\n  return {\r\n    x(x) {\r\n      return x;\r\n    },\r\n    setWidth(w) { // eslint-disable-line no-unused-vars\r\n    },\r\n    textAlign(align) {\r\n      return align;\r\n    },\r\n    xPlus(x, value) {\r\n      return x + value;\r\n    },\r\n    leftForLtr(x, _itemWidth) { // eslint-disable-line @typescript-eslint/no-unused-vars\r\n      return x;\r\n    },\r\n  };\r\n};\r\n\r\nexport function getRtlAdapter(rtl: boolean, rectX: number, width: number) {\r\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\r\n}\r\n\r\nexport function overrideTextDirection(ctx: CanvasRenderingContext2D, direction: 'ltr' | 'rtl') {\r\n  let style: CSSStyleDeclaration, original: [string, string];\r\n  if (direction === 'ltr' || direction === 'rtl') {\r\n    style = ctx.canvas.style;\r\n    original = [\r\n      style.getPropertyValue('direction'),\r\n      style.getPropertyPriority('direction'),\r\n    ];\r\n\r\n    style.setProperty('direction', direction, 'important');\r\n    (ctx as { prevTextDirection?: [string, string] }).prevTextDirection = original;\r\n  }\r\n}\r\n\r\nexport function restoreTextDirection(ctx: CanvasRenderingContext2D, original?: [string, string]) {\r\n  if (original !== undefined) {\r\n    delete (ctx as { prevTextDirection?: [string, string] }).prevTextDirection;\r\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\r\n  }\r\n}\r\n","import {_angleBetween, _angleDiff, _isBetween, _normalizeAngle} from './helpers.math.js';\r\nimport {createContext} from './helpers.options.js';\r\n\r\n/**\r\n * @typedef { import('../elements/element.line.js').default } LineElement\r\n * @typedef { import('../elements/element.point.js').default } PointElement\r\n * @typedef {{start: number, end: number, loop: boolean, style?: any}} Segment\r\n */\r\n\r\nfunction propertyFn(property) {\r\n  if (property === 'angle') {\r\n    return {\r\n      between: _angleBetween,\r\n      compare: _angleDiff,\r\n      normalize: _normalizeAngle,\r\n    };\r\n  }\r\n  return {\r\n    between: _isBetween,\r\n    compare: (a, b) => a - b,\r\n    normalize: x => x\r\n  };\r\n}\r\n\r\nfunction normalizeSegment({start, end, count, loop, style}) {\r\n  return {\r\n    start: start % count,\r\n    end: end % count,\r\n    loop: loop && (end - start + 1) % count === 0,\r\n    style\r\n  };\r\n}\r\n\r\nfunction getSegment(segment, points, bounds) {\r\n  const {property, start: startBound, end: endBound} = bounds;\r\n  const {between, normalize} = propertyFn(property);\r\n  const count = points.length;\r\n  // eslint-disable-next-line prefer-const\r\n  let {start, end, loop} = segment;\r\n  let i, ilen;\r\n\r\n  if (loop) {\r\n    start += count;\r\n    end += count;\r\n    for (i = 0, ilen = count; i < ilen; ++i) {\r\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\r\n        break;\r\n      }\r\n      start--;\r\n      end--;\r\n    }\r\n    start %= count;\r\n    end %= count;\r\n  }\r\n\r\n  if (end < start) {\r\n    end += count;\r\n  }\r\n  return {start, end, loop, style: segment.style};\r\n}\r\n\r\n/**\r\n * Returns the sub-segment(s) of a line segment that fall in the given bounds\r\n * @param {object} segment\r\n * @param {number} segment.start - start index of the segment, referring the points array\r\n * @param {number} segment.end - end index of the segment, referring the points array\r\n * @param {boolean} segment.loop - indicates that the segment is a loop\r\n * @param {object} [segment.style] - segment style\r\n * @param {PointElement[]} points - the points that this segment refers to\r\n * @param {object} [bounds]\r\n * @param {string} bounds.property - the property of a `PointElement` we are bounding. `x`, `y` or `angle`.\r\n * @param {number} bounds.start - start value of the property\r\n * @param {number} bounds.end - end value of the property\r\n * @private\r\n **/\r\nexport function _boundSegment(segment, points, bounds) {\r\n  if (!bounds) {\r\n    return [segment];\r\n  }\r\n\r\n  const {property, start: startBound, end: endBound} = bounds;\r\n  const count = points.length;\r\n  const {compare, between, normalize} = propertyFn(property);\r\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\r\n\r\n  const result = [];\r\n  let inside = false;\r\n  let subStart = null;\r\n  let value, point, prevValue;\r\n\r\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\r\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\r\n  const shouldStart = () => inside || startIsBefore();\r\n  const shouldStop = () => !inside || endIsBefore();\r\n\r\n  for (let i = start, prev = start; i <= end; ++i) {\r\n    point = points[i % count];\r\n\r\n    if (point.skip) {\r\n      continue;\r\n    }\r\n\r\n    value = normalize(point[property]);\r\n\r\n    if (value === prevValue) {\r\n      continue;\r\n    }\r\n\r\n    inside = between(value, startBound, endBound);\r\n\r\n    if (subStart === null && shouldStart()) {\r\n      subStart = compare(value, startBound) === 0 ? i : prev;\r\n    }\r\n\r\n    if (subStart !== null && shouldStop()) {\r\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\r\n      subStart = null;\r\n    }\r\n    prev = i;\r\n    prevValue = value;\r\n  }\r\n\r\n  if (subStart !== null) {\r\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n\r\n/**\r\n * Returns the segments of the line that are inside given bounds\r\n * @param {LineElement} line\r\n * @param {object} [bounds]\r\n * @param {string} bounds.property - the property we are bounding with. `x`, `y` or `angle`.\r\n * @param {number} bounds.start - start value of the `property`\r\n * @param {number} bounds.end - end value of the `property`\r\n * @private\r\n */\r\nexport function _boundSegments(line, bounds) {\r\n  const result = [];\r\n  const segments = line.segments;\r\n\r\n  for (let i = 0; i < segments.length; i++) {\r\n    const sub = _boundSegment(segments[i], line.points, bounds);\r\n    if (sub.length) {\r\n      result.push(...sub);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Find start and end index of a line.\r\n */\r\nfunction findStartAndEnd(points, count, loop, spanGaps) {\r\n  let start = 0;\r\n  let end = count - 1;\r\n\r\n  if (loop && !spanGaps) {\r\n    // loop and not spanning gaps, first find a gap to start from\r\n    while (start < count && !points[start].skip) {\r\n      start++;\r\n    }\r\n  }\r\n\r\n  // find first non skipped point (after the first gap possibly)\r\n  while (start < count && points[start].skip) {\r\n    start++;\r\n  }\r\n\r\n  // if we looped to count, start needs to be 0\r\n  start %= count;\r\n\r\n  if (loop) {\r\n    // loop will go past count, if start > 0\r\n    end += start;\r\n  }\r\n\r\n  while (end > start && points[end % count].skip) {\r\n    end--;\r\n  }\r\n\r\n  // end could be more than count, normalize\r\n  end %= count;\r\n\r\n  return {start, end};\r\n}\r\n\r\n/**\r\n * Compute solid segments from Points, when spanGaps === false\r\n * @param {PointElement[]} points - the points\r\n * @param {number} start - start index\r\n * @param {number} max - max index (can go past count on a loop)\r\n * @param {boolean} loop - boolean indicating that this would be a loop if no gaps are found\r\n */\r\nfunction solidSegments(points, start, max, loop) {\r\n  const count = points.length;\r\n  const result = [];\r\n  let last = start;\r\n  let prev = points[start];\r\n  let end;\r\n\r\n  for (end = start + 1; end <= max; ++end) {\r\n    const cur = points[end % count];\r\n    if (cur.skip || cur.stop) {\r\n      if (!prev.skip) {\r\n        loop = false;\r\n        result.push({start: start % count, end: (end - 1) % count, loop});\r\n        // @ts-ignore\r\n        start = last = cur.stop ? end : null;\r\n      }\r\n    } else {\r\n      last = end;\r\n      if (prev.skip) {\r\n        start = end;\r\n      }\r\n    }\r\n    prev = cur;\r\n  }\r\n\r\n  if (last !== null) {\r\n    result.push({start: start % count, end: last % count, loop});\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Compute the continuous segments that define the whole line\r\n * There can be skipped points within a segment, if spanGaps is true.\r\n * @param {LineElement} line\r\n * @param {object} [segmentOptions]\r\n * @return {Segment[]}\r\n * @private\r\n */\r\nexport function _computeSegments(line, segmentOptions) {\r\n  const points = line.points;\r\n  const spanGaps = line.options.spanGaps;\r\n  const count = points.length;\r\n\r\n  if (!count) {\r\n    return [];\r\n  }\r\n\r\n  const loop = !!line._loop;\r\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\r\n\r\n  if (spanGaps === true) {\r\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\r\n  }\r\n\r\n  const max = end < start ? end + count : end;\r\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\r\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\r\n}\r\n\r\n/**\r\n * @param {Segment[]} segments\r\n * @param {PointElement[]} points\r\n * @param {object} [segmentOptions]\r\n * @return {Segment[]}\r\n */\r\nfunction splitByStyles(line, segments, points, segmentOptions) {\r\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\r\n    return segments;\r\n  }\r\n  return doSplitByStyles(line, segments, points, segmentOptions);\r\n}\r\n\r\n/**\r\n * @param {LineElement} line\r\n * @param {Segment[]} segments\r\n * @param {PointElement[]} points\r\n * @param {object} [segmentOptions]\r\n * @return {Segment[]}\r\n */\r\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\r\n  const chartContext = line._chart.getContext();\r\n  const baseStyle = readStyle(line.options);\r\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\r\n  const count = points.length;\r\n  const result = [];\r\n  let prevStyle = baseStyle;\r\n  let start = segments[0].start;\r\n  let i = start;\r\n\r\n  function addStyle(s, e, l, st) {\r\n    const dir = spanGaps ? -1 : 1;\r\n    if (s === e) {\r\n      return;\r\n    }\r\n    // Style can not start/end on a skipped point, adjust indices accordingly\r\n    s += count;\r\n    while (points[s % count].skip) {\r\n      s -= dir;\r\n    }\r\n    while (points[e % count].skip) {\r\n      e += dir;\r\n    }\r\n    if (s % count !== e % count) {\r\n      result.push({start: s % count, end: e % count, loop: l, style: st});\r\n      prevStyle = st;\r\n      start = e % count;\r\n    }\r\n  }\r\n\r\n  for (const segment of segments) {\r\n    start = spanGaps ? start : segment.start;\r\n    let prev = points[start % count];\r\n    let style;\r\n    for (i = start + 1; i <= segment.end; i++) {\r\n      const pt = points[i % count];\r\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\r\n        type: 'segment',\r\n        p0: prev,\r\n        p1: pt,\r\n        p0DataIndex: (i - 1) % count,\r\n        p1DataIndex: i % count,\r\n        datasetIndex\r\n      })));\r\n      if (styleChanged(style, prevStyle)) {\r\n        addStyle(start, i - 1, segment.loop, prevStyle);\r\n      }\r\n      prev = pt;\r\n      prevStyle = style;\r\n    }\r\n    if (start < i - 1) {\r\n      addStyle(start, i - 1, segment.loop, prevStyle);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction readStyle(options) {\r\n  return {\r\n    backgroundColor: options.backgroundColor,\r\n    borderCapStyle: options.borderCapStyle,\r\n    borderDash: options.borderDash,\r\n    borderDashOffset: options.borderDashOffset,\r\n    borderJoinStyle: options.borderJoinStyle,\r\n    borderWidth: options.borderWidth,\r\n    borderColor: options.borderColor\r\n  };\r\n}\r\n\r\nfunction styleChanged(style, prevStyle) {\r\n  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\r\n}\r\n","import {_lookupByKey, _rlookupByKey} from '../helpers/helpers.collection.js';\r\nimport {getRelativePosition} from '../helpers/helpers.dom.js';\r\nimport {_angleBetween, getAngleFromPoint} from '../helpers/helpers.math.js';\r\nimport {_isPointInArea} from '../helpers/index.js';\r\n\r\n/**\r\n * @typedef { import('./core.controller.js').default } Chart\r\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\r\n * @typedef {{axis?: string, intersect?: boolean, includeInvisible?: boolean}} InteractionOptions\r\n * @typedef {{datasetIndex: number, index: number, element: import('./core.element.js').default}} InteractionItem\r\n * @typedef { import('../types/index.js').Point } Point\r\n */\r\n\r\n/**\r\n * Helper function to do binary search when possible\r\n * @param {object} metaset - the dataset meta\r\n * @param {string} axis - the axis mode. x|y|xy|r\r\n * @param {number} value - the value to find\r\n * @param {boolean} [intersect] - should the element intersect\r\n * @returns {{lo:number, hi:number}} indices to search data array between\r\n */\r\nfunction binarySearch(metaset, axis, value, intersect) {\r\n  const {controller, data, _sorted} = metaset;\r\n  const iScale = controller._cachedMeta.iScale;\r\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\r\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\r\n    if (!intersect) {\r\n      return lookupMethod(data, axis, value);\r\n    } else if (controller._sharedOptions) {\r\n      // _sharedOptions indicates that each element has equal options -> equal proportions\r\n      // So we can do a ranged binary search based on the range of first element and\r\n      // be confident to get the full range of indices that can intersect with the value.\r\n      const el = data[0];\r\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\r\n      if (range) {\r\n        const start = lookupMethod(data, axis, value - range);\r\n        const end = lookupMethod(data, axis, value + range);\r\n        return {lo: start.lo, hi: end.hi};\r\n      }\r\n    }\r\n  }\r\n  // Default to all elements, when binary search can not be used.\r\n  return {lo: 0, hi: data.length - 1};\r\n}\r\n\r\n/**\r\n * Helper function to select candidate elements for interaction\r\n * @param {Chart} chart - the chart\r\n * @param {string} axis - the axis mode. x|y|xy|r\r\n * @param {Point} position - the point to be nearest to, in relative coordinates\r\n * @param {function} handler - the callback to execute for each visible item\r\n * @param {boolean} [intersect] - consider intersecting items\r\n */\r\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\r\n  const metasets = chart.getSortedVisibleDatasetMetas();\r\n  const value = position[axis];\r\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n    const {index, data} = metasets[i];\r\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\r\n    for (let j = lo; j <= hi; ++j) {\r\n      const element = data[j];\r\n      if (!element.skip) {\r\n        handler(element, index, j);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get a distance metric function for two points based on the\r\n * axis mode setting\r\n * @param {string} axis - the axis mode. x|y|xy|r\r\n */\r\nfunction getDistanceMetricForAxis(axis) {\r\n  const useX = axis.indexOf('x') !== -1;\r\n  const useY = axis.indexOf('y') !== -1;\r\n\r\n  return function(pt1, pt2) {\r\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\r\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\r\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\r\n  };\r\n}\r\n\r\n/**\r\n * Helper function to get the items that intersect the event position\r\n * @param {Chart} chart - the chart\r\n * @param {Point} position - the point to be nearest to, in relative coordinates\r\n * @param {string} axis - the axis mode. x|y|xy|r\r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\r\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\r\n * @return {InteractionItem[]} the nearest items\r\n */\r\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\r\n  const items = [];\r\n\r\n  if (!includeInvisible && !chart.isPointInArea(position)) {\r\n    return items;\r\n  }\r\n\r\n  const evaluationFunc = function(element, datasetIndex, index) {\r\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\r\n      return;\r\n    }\r\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\r\n      items.push({element, datasetIndex, index});\r\n    }\r\n  };\r\n\r\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\r\n  return items;\r\n}\r\n\r\n/**\r\n * Helper function to get the items nearest to the event position for a radial chart\r\n * @param {Chart} chart - the chart to look at elements from\r\n * @param {Point} position - the point to be nearest to, in relative coordinates\r\n * @param {string} axis - the axes along which to measure distance\r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\r\n * @return {InteractionItem[]} the nearest items\r\n */\r\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\r\n  let items = [];\r\n\r\n  function evaluationFunc(element, datasetIndex, index) {\r\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\r\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\r\n\r\n    if (_angleBetween(angle, startAngle, endAngle)) {\r\n      items.push({element, datasetIndex, index});\r\n    }\r\n  }\r\n\r\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\r\n  return items;\r\n}\r\n\r\n/**\r\n * Helper function to get the items nearest to the event position for a cartesian chart\r\n * @param {Chart} chart - the chart to look at elements from\r\n * @param {Point} position - the point to be nearest to, in relative coordinates\r\n * @param {string} axis - the axes along which to measure distance\r\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\r\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\r\n * @return {InteractionItem[]} the nearest items\r\n */\r\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\r\n  let items = [];\r\n  const distanceMetric = getDistanceMetricForAxis(axis);\r\n  let minDistance = Number.POSITIVE_INFINITY;\r\n\r\n  function evaluationFunc(element, datasetIndex, index) {\r\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\r\n    if (intersect && !inRange) {\r\n      return;\r\n    }\r\n\r\n    const center = element.getCenterPoint(useFinalPosition);\r\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\r\n    if (!pointInArea && !inRange) {\r\n      return;\r\n    }\r\n\r\n    const distance = distanceMetric(position, center);\r\n    if (distance < minDistance) {\r\n      items = [{element, datasetIndex, index}];\r\n      minDistance = distance;\r\n    } else if (distance === minDistance) {\r\n      // Can have multiple items at the same distance in which case we sort by size\r\n      items.push({element, datasetIndex, index});\r\n    }\r\n  }\r\n\r\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\r\n  return items;\r\n}\r\n\r\n/**\r\n * Helper function to get the items nearest to the event position considering all visible items in the chart\r\n * @param {Chart} chart - the chart to look at elements from\r\n * @param {Point} position - the point to be nearest to, in relative coordinates\r\n * @param {string} axis - the axes along which to measure distance\r\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\r\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\r\n * @return {InteractionItem[]} the nearest items\r\n */\r\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\r\n  if (!includeInvisible && !chart.isPointInArea(position)) {\r\n    return [];\r\n  }\r\n\r\n  return axis === 'r' && !intersect\r\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\r\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\r\n}\r\n\r\n/**\r\n * Helper function to get the items matching along the given X or Y axis\r\n * @param {Chart} chart - the chart to look at elements from\r\n * @param {Point} position - the point to be nearest to, in relative coordinates\r\n * @param {string} axis - the axis to match\r\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\r\n * @return {InteractionItem[]} the nearest items\r\n */\r\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\r\n  const items = [];\r\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\r\n  let intersectsItem = false;\r\n\r\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\r\n    if (element[rangeMethod](position[axis], useFinalPosition)) {\r\n      items.push({element, datasetIndex, index});\r\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\r\n    }\r\n  });\r\n\r\n  // If we want to trigger on an intersect and we don't have any items\r\n  // that intersect the position, return nothing\r\n  if (intersect && !intersectsItem) {\r\n    return [];\r\n  }\r\n  return items;\r\n}\r\n\r\n/**\r\n * Contains interaction related functions\r\n * @namespace Chart.Interaction\r\n */\r\nexport default {\r\n  // Part of the public API to facilitate developers creating their own modes\r\n  evaluateInteractionItems,\r\n\r\n  // Helper function for different modes\r\n  modes: {\r\n    /**\r\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\r\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\r\n\t\t * @function Chart.Interaction.modes.index\r\n\t\t * @since v2.4.0\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {InteractionOptions} options - options to use\r\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\r\n\t\t * @return {InteractionItem[]} - items that are found\r\n\t\t */\r\n    index(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      // Default axis for index mode is 'x' to match old behaviour\r\n      const axis = options.axis || 'x';\r\n      const includeInvisible = options.includeInvisible || false;\r\n      const items = options.intersect\r\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\r\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\r\n      const elements = [];\r\n\r\n      if (!items.length) {\r\n        return [];\r\n      }\r\n\r\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\r\n        const index = items[0].index;\r\n        const element = meta.data[index];\r\n\r\n        // don't count items that are skipped (null data)\r\n        if (element && !element.skip) {\r\n          elements.push({element, datasetIndex: meta.index, index});\r\n        }\r\n      });\r\n\r\n      return elements;\r\n    },\r\n\r\n    /**\r\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\r\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\r\n\t\t * @function Chart.Interaction.modes.dataset\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {InteractionOptions} options - options to use\r\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\r\n\t\t * @return {InteractionItem[]} - items that are found\r\n\t\t */\r\n    dataset(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      const axis = options.axis || 'xy';\r\n      const includeInvisible = options.includeInvisible || false;\r\n      let items = options.intersect\r\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\r\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\r\n\r\n      if (items.length > 0) {\r\n        const datasetIndex = items[0].datasetIndex;\r\n        const data = chart.getDatasetMeta(datasetIndex).data;\r\n        items = [];\r\n        for (let i = 0; i < data.length; ++i) {\r\n          items.push({element: data[i], datasetIndex, index: i});\r\n        }\r\n      }\r\n\r\n      return items;\r\n    },\r\n\r\n    /**\r\n\t\t * Point mode returns all elements that hit test based on the event position\r\n\t\t * of the event\r\n\t\t * @function Chart.Interaction.modes.intersect\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {InteractionOptions} options - options to use\r\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\r\n\t\t * @return {InteractionItem[]} - items that are found\r\n\t\t */\r\n    point(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      const axis = options.axis || 'xy';\r\n      const includeInvisible = options.includeInvisible || false;\r\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\r\n    },\r\n\r\n    /**\r\n\t\t * nearest mode returns the element closest to the point\r\n\t\t * @function Chart.Interaction.modes.intersect\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {InteractionOptions} options - options to use\r\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\r\n\t\t * @return {InteractionItem[]} - items that are found\r\n\t\t */\r\n    nearest(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      const axis = options.axis || 'xy';\r\n      const includeInvisible = options.includeInvisible || false;\r\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\r\n    },\r\n\r\n    /**\r\n\t\t * x mode returns the elements that hit-test at the current x coordinate\r\n\t\t * @function Chart.Interaction.modes.x\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {InteractionOptions} options - options to use\r\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\r\n\t\t * @return {InteractionItem[]} - items that are found\r\n\t\t */\r\n    x(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\r\n    },\r\n\r\n    /**\r\n\t\t * y mode returns the elements that hit-test at the current y coordinate\r\n\t\t * @function Chart.Interaction.modes.y\r\n\t\t * @param {Chart} chart - the chart we are returning items from\r\n\t\t * @param {Event} e - the event we are find things at\r\n\t\t * @param {InteractionOptions} options - options to use\r\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\r\n\t\t * @return {InteractionItem[]} - items that are found\r\n\t\t */\r\n    y(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\r\n    }\r\n  }\r\n};\r\n","import {defined, each, isObject} from '../helpers/helpers.core.js';\r\nimport {toPadding} from '../helpers/helpers.options.js';\r\n\r\n/**\r\n * @typedef { import('./core.controller.js').default } Chart\r\n */\r\n\r\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\r\n\r\nfunction filterByPosition(array, position) {\r\n  return array.filter(v => v.pos === position);\r\n}\r\n\r\nfunction filterDynamicPositionByAxis(array, axis) {\r\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\r\n}\r\n\r\nfunction sortByWeight(array, reverse) {\r\n  return array.sort((a, b) => {\r\n    const v0 = reverse ? b : a;\r\n    const v1 = reverse ? a : b;\r\n    return v0.weight === v1.weight ?\r\n      v0.index - v1.index :\r\n      v0.weight - v1.weight;\r\n  });\r\n}\r\n\r\nfunction wrapBoxes(boxes) {\r\n  const layoutBoxes = [];\r\n  let i, ilen, box, pos, stack, stackWeight;\r\n\r\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\r\n    box = boxes[i];\r\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\r\n    layoutBoxes.push({\r\n      index: i,\r\n      box,\r\n      pos,\r\n      horizontal: box.isHorizontal(),\r\n      weight: box.weight,\r\n      stack: stack && (pos + stack),\r\n      stackWeight\r\n    });\r\n  }\r\n  return layoutBoxes;\r\n}\r\n\r\nfunction buildStacks(layouts) {\r\n  const stacks = {};\r\n  for (const wrap of layouts) {\r\n    const {stack, pos, stackWeight} = wrap;\r\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\r\n      continue;\r\n    }\r\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\r\n    _stack.count++;\r\n    _stack.weight += stackWeight;\r\n  }\r\n  return stacks;\r\n}\r\n\r\n/**\r\n * store dimensions used instead of available chartArea in fitBoxes\r\n **/\r\nfunction setLayoutDims(layouts, params) {\r\n  const stacks = buildStacks(layouts);\r\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\r\n  let i, ilen, layout;\r\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\r\n    layout = layouts[i];\r\n    const {fullSize} = layout.box;\r\n    const stack = stacks[layout.stack];\r\n    const factor = stack && layout.stackWeight / stack.weight;\r\n    if (layout.horizontal) {\r\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\r\n      layout.height = hBoxMaxHeight;\r\n    } else {\r\n      layout.width = vBoxMaxWidth;\r\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\r\n    }\r\n  }\r\n  return stacks;\r\n}\r\n\r\nfunction buildLayoutBoxes(boxes) {\r\n  const layoutBoxes = wrapBoxes(boxes);\r\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\r\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\r\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\r\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\r\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\r\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\r\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\r\n\r\n  return {\r\n    fullSize,\r\n    leftAndTop: left.concat(top),\r\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\r\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\r\n    vertical: left.concat(right).concat(centerVertical),\r\n    horizontal: top.concat(bottom).concat(centerHorizontal)\r\n  };\r\n}\r\n\r\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\r\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\r\n}\r\n\r\nfunction updateMaxPadding(maxPadding, boxPadding) {\r\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\r\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\r\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\r\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\r\n}\r\n\r\nfunction updateDims(chartArea, params, layout, stacks) {\r\n  const {pos, box} = layout;\r\n  const maxPadding = chartArea.maxPadding;\r\n\r\n  // dynamically placed boxes size is not considered\r\n  if (!isObject(pos)) {\r\n    if (layout.size) {\r\n      // this layout was already counted for, lets first reduce old size\r\n      chartArea[pos] -= layout.size;\r\n    }\r\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\r\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\r\n    layout.size = stack.size / stack.count;\r\n    chartArea[pos] += layout.size;\r\n  }\r\n\r\n  if (box.getPadding) {\r\n    updateMaxPadding(maxPadding, box.getPadding());\r\n  }\r\n\r\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\r\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\r\n  const widthChanged = newWidth !== chartArea.w;\r\n  const heightChanged = newHeight !== chartArea.h;\r\n  chartArea.w = newWidth;\r\n  chartArea.h = newHeight;\r\n\r\n  // return booleans on the changes per direction\r\n  return layout.horizontal\r\n    ? {same: widthChanged, other: heightChanged}\r\n    : {same: heightChanged, other: widthChanged};\r\n}\r\n\r\nfunction handleMaxPadding(chartArea) {\r\n  const maxPadding = chartArea.maxPadding;\r\n\r\n  function updatePos(pos) {\r\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\r\n    chartArea[pos] += change;\r\n    return change;\r\n  }\r\n  chartArea.y += updatePos('top');\r\n  chartArea.x += updatePos('left');\r\n  updatePos('right');\r\n  updatePos('bottom');\r\n}\r\n\r\nfunction getMargins(horizontal, chartArea) {\r\n  const maxPadding = chartArea.maxPadding;\r\n\r\n  function marginForPositions(positions) {\r\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\r\n    positions.forEach((pos) => {\r\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\r\n    });\r\n    return margin;\r\n  }\r\n\r\n  return horizontal\r\n    ? marginForPositions(['left', 'right'])\r\n    : marginForPositions(['top', 'bottom']);\r\n}\r\n\r\nfunction fitBoxes(boxes, chartArea, params, stacks) {\r\n  const refitBoxes = [];\r\n  let i, ilen, layout, box, refit, changed;\r\n\r\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\r\n    layout = boxes[i];\r\n    box = layout.box;\r\n\r\n    box.update(\r\n      layout.width || chartArea.w,\r\n      layout.height || chartArea.h,\r\n      getMargins(layout.horizontal, chartArea)\r\n    );\r\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\r\n\r\n    // Dimensions changed and there were non full width boxes before this\r\n    // -> we have to refit those\r\n    refit |= same && refitBoxes.length;\r\n\r\n    // Chart area changed in the opposite direction\r\n    changed = changed || other;\r\n\r\n    if (!box.fullSize) { // fullSize boxes don't need to be re-fitted in any case\r\n      refitBoxes.push(layout);\r\n    }\r\n  }\r\n\r\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\r\n}\r\n\r\nfunction setBoxDims(box, left, top, width, height) {\r\n  box.top = top;\r\n  box.left = left;\r\n  box.right = left + width;\r\n  box.bottom = top + height;\r\n  box.width = width;\r\n  box.height = height;\r\n}\r\n\r\nfunction placeBoxes(boxes, chartArea, params, stacks) {\r\n  const userPadding = params.padding;\r\n  let {x, y} = chartArea;\r\n\r\n  for (const layout of boxes) {\r\n    const box = layout.box;\r\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\r\n    const weight = (layout.stackWeight / stack.weight) || 1;\r\n    if (layout.horizontal) {\r\n      const width = chartArea.w * weight;\r\n      const height = stack.size || box.height;\r\n      if (defined(stack.start)) {\r\n        y = stack.start;\r\n      }\r\n      if (box.fullSize) {\r\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\r\n      } else {\r\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\r\n      }\r\n      stack.start = y;\r\n      stack.placed += width;\r\n      y = box.bottom;\r\n    } else {\r\n      const height = chartArea.h * weight;\r\n      const width = stack.size || box.width;\r\n      if (defined(stack.start)) {\r\n        x = stack.start;\r\n      }\r\n      if (box.fullSize) {\r\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\r\n      } else {\r\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\r\n      }\r\n      stack.start = x;\r\n      stack.placed += height;\r\n      x = box.right;\r\n    }\r\n  }\r\n\r\n  chartArea.x = x;\r\n  chartArea.y = y;\r\n}\r\n\r\n/**\r\n * @interface LayoutItem\r\n * @typedef {object} LayoutItem\r\n * @prop {string} position - The position of the item in the chart layout. Possible values are\r\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\r\n * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\r\n * @prop {boolean} fullSize - if true, and the item is horizontal, then push vertical boxes down\r\n * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\r\n * @prop {function} update - Takes two parameters: width and height. Returns size of item\r\n * @prop {function} draw - Draws the element\r\n * @prop {function} [getPadding] -  Returns an object with padding on the edges\r\n * @prop {number} width - Width of item. Must be valid after update()\r\n * @prop {number} height - Height of item. Must be valid after update()\r\n * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\r\n * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\r\n * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\r\n * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\r\n */\r\n\r\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\r\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\r\n// It is this service's responsibility of carrying out that layout.\r\nexport default {\r\n\r\n  /**\r\n\t * Register a box to a chart.\r\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\r\n\t * @param {Chart} chart - the chart to use\r\n\t * @param {LayoutItem} item - the item to add to be laid out\r\n\t */\r\n  addBox(chart, item) {\r\n    if (!chart.boxes) {\r\n      chart.boxes = [];\r\n    }\r\n\r\n    // initialize item with default values\r\n    item.fullSize = item.fullSize || false;\r\n    item.position = item.position || 'top';\r\n    item.weight = item.weight || 0;\r\n    // @ts-ignore\r\n    item._layers = item._layers || function() {\r\n      return [{\r\n        z: 0,\r\n        draw(chartArea) {\r\n          item.draw(chartArea);\r\n        }\r\n      }];\r\n    };\r\n\r\n    chart.boxes.push(item);\r\n  },\r\n\r\n  /**\r\n\t * Remove a layoutItem from a chart\r\n\t * @param {Chart} chart - the chart to remove the box from\r\n\t * @param {LayoutItem} layoutItem - the item to remove from the layout\r\n\t */\r\n  removeBox(chart, layoutItem) {\r\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\r\n    if (index !== -1) {\r\n      chart.boxes.splice(index, 1);\r\n    }\r\n  },\r\n\r\n  /**\r\n\t * Sets (or updates) options on the given `item`.\r\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\r\n\t * @param {LayoutItem} item - the item to configure with the given options\r\n\t * @param {object} options - the new item options.\r\n\t */\r\n  configure(chart, item, options) {\r\n    item.fullSize = options.fullSize;\r\n    item.position = options.position;\r\n    item.weight = options.weight;\r\n  },\r\n\r\n  /**\r\n\t * Fits boxes of the given chart into the given size by having each box measure itself\r\n\t * then running a fitting algorithm\r\n\t * @param {Chart} chart - the chart\r\n\t * @param {number} width - the width to fit into\r\n\t * @param {number} height - the height to fit into\r\n   * @param {number} minPadding - minimum padding required for each side of chart area\r\n\t */\r\n  update(chart, width, height, minPadding) {\r\n    if (!chart) {\r\n      return;\r\n    }\r\n\r\n    const padding = toPadding(chart.options.layout.padding);\r\n    const availableWidth = Math.max(width - padding.width, 0);\r\n    const availableHeight = Math.max(height - padding.height, 0);\r\n    const boxes = buildLayoutBoxes(chart.boxes);\r\n    const verticalBoxes = boxes.vertical;\r\n    const horizontalBoxes = boxes.horizontal;\r\n\r\n    // Before any changes are made, notify boxes that an update is about to being\r\n    // This is used to clear any cached data (e.g. scale limits)\r\n    each(chart.boxes, box => {\r\n      if (typeof box.beforeLayout === 'function') {\r\n        box.beforeLayout();\r\n      }\r\n    });\r\n\r\n    // Essentially we now have any number of boxes on each of the 4 sides.\r\n    // Our canvas looks like the following.\r\n    // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\r\n    // B1 is the bottom axis\r\n    // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\r\n    // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\r\n    // an error will be thrown.\r\n    //\r\n    // |----------------------------------------------------|\r\n    // |                  T1 (Full Width)                   |\r\n    // |----------------------------------------------------|\r\n    // |    |    |                 T2                  |    |\r\n    // |    |----|-------------------------------------|----|\r\n    // |    |    | C1 |                           | C2 |    |\r\n    // |    |    |----|                           |----|    |\r\n    // |    |    |                                     |    |\r\n    // | L1 | L2 |           ChartArea (C0)            | R1 |\r\n    // |    |    |                                     |    |\r\n    // |    |    |----|                           |----|    |\r\n    // |    |    | C3 |                           | C4 |    |\r\n    // |    |----|-------------------------------------|----|\r\n    // |    |    |                 B1                  |    |\r\n    // |----------------------------------------------------|\r\n    // |                  B2 (Full Width)                   |\r\n    // |----------------------------------------------------|\r\n    //\r\n\r\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\r\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\r\n\r\n    const params = Object.freeze({\r\n      outerWidth: width,\r\n      outerHeight: height,\r\n      padding,\r\n      availableWidth,\r\n      availableHeight,\r\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\r\n      hBoxMaxHeight: availableHeight / 2\r\n    });\r\n    const maxPadding = Object.assign({}, padding);\r\n    updateMaxPadding(maxPadding, toPadding(minPadding));\r\n    const chartArea = Object.assign({\r\n      maxPadding,\r\n      w: availableWidth,\r\n      h: availableHeight,\r\n      x: padding.left,\r\n      y: padding.top\r\n    }, padding);\r\n\r\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\r\n\r\n    // First fit the fullSize boxes, to reduce probability of re-fitting.\r\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\r\n\r\n    // Then fit vertical boxes\r\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\r\n\r\n    // Then fit horizontal boxes\r\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\r\n      // if the area changed, re-fit vertical boxes\r\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\r\n    }\r\n\r\n    handleMaxPadding(chartArea);\r\n\r\n    // Finally place the boxes to correct coordinates\r\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\r\n\r\n    // Move to opposite side of chart\r\n    chartArea.x += chartArea.w;\r\n    chartArea.y += chartArea.h;\r\n\r\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\r\n\r\n    chart.chartArea = {\r\n      left: chartArea.left,\r\n      top: chartArea.top,\r\n      right: chartArea.left + chartArea.w,\r\n      bottom: chartArea.top + chartArea.h,\r\n      height: chartArea.h,\r\n      width: chartArea.w,\r\n    };\r\n\r\n    // Finally update boxes in chartArea (radial scale for example)\r\n    each(boxes.chartArea, (layout) => {\r\n      const box = layout.box;\r\n      Object.assign(box, chart.chartArea);\r\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\r\n    });\r\n  }\r\n};\r\n","\r\n/**\r\n * @typedef { import('../core/core.controller.js').default } Chart\r\n */\r\n\r\n/**\r\n * Abstract class that allows abstracting platform dependencies away from the chart.\r\n */\r\nexport default class BasePlatform {\r\n  /**\r\n\t * Called at chart construction time, returns a context2d instance implementing\r\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\r\n\t * @param {HTMLCanvasElement} canvas - The canvas from which to acquire context (platform specific)\r\n\t * @param {number} [aspectRatio] - The chart options\r\n\t */\r\n  acquireContext(canvas, aspectRatio) {} // eslint-disable-line no-unused-vars\r\n\r\n  /**\r\n\t * Called at chart destruction time, releases any resources associated to the context\r\n\t * previously returned by the acquireContext() method.\r\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\r\n\t * @returns {boolean} true if the method succeeded, else false\r\n\t */\r\n  releaseContext(context) { // eslint-disable-line no-unused-vars\r\n    return false;\r\n  }\r\n\r\n  /**\r\n\t * Registers the specified listener on the given chart.\r\n\t * @param {Chart} chart - Chart from which to listen for event\r\n\t * @param {string} type - The ({@link ChartEvent}) type to listen for\r\n\t * @param {function} listener - Receives a notification (an object that implements\r\n\t * the {@link ChartEvent} interface) when an event of the specified type occurs.\r\n\t */\r\n  addEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\r\n\r\n  /**\r\n\t * Removes the specified listener previously registered with addEventListener.\r\n\t * @param {Chart} chart - Chart from which to remove the listener\r\n\t * @param {string} type - The ({@link ChartEvent}) type to remove\r\n\t * @param {function} listener - The listener function to remove from the event target.\r\n\t */\r\n  removeEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\r\n\r\n  /**\r\n\t * @returns {number} the current devicePixelRatio of the device this platform is connected to.\r\n\t */\r\n  getDevicePixelRatio() {\r\n    return 1;\r\n  }\r\n\r\n  /**\r\n\t * Returns the maximum size in pixels of given canvas element.\r\n\t * @param {HTMLCanvasElement} element\r\n\t * @param {number} [width] - content width of parent element\r\n\t * @param {number} [height] - content height of parent element\r\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\r\n\t */\r\n  getMaximumSize(element, width, height, aspectRatio) {\r\n    width = Math.max(0, width || element.width);\r\n    height = height || element.height;\r\n    return {\r\n      width,\r\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * @param {HTMLCanvasElement} canvas\r\n\t * @returns {boolean} true if the canvas is attached to the platform, false if not.\r\n\t */\r\n  isAttached(canvas) { // eslint-disable-line no-unused-vars\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Updates config with platform specific requirements\r\n   * @param {import('../core/core.config.js').default} config\r\n   */\r\n  updateConfig(config) { // eslint-disable-line no-unused-vars\r\n    // no-op\r\n  }\r\n}\r\n","/**\r\n * Platform fallback implementation (minimal).\r\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\r\n */\r\n\r\nimport BasePlatform from './platform.base.js';\r\n\r\n/**\r\n * Platform class for charts without access to the DOM or to many element properties\r\n * This platform is used by default for any chart passed an OffscreenCanvas.\r\n * @extends BasePlatform\r\n */\r\nexport default class BasicPlatform extends BasePlatform {\r\n  acquireContext(item) {\r\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\r\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\r\n    // https://github.com/chartjs/Chart.js/issues/2807\r\n    return item && item.getContext && item.getContext('2d') || null;\r\n  }\r\n  updateConfig(config) {\r\n    config.options.animation = false;\r\n  }\r\n}\r\n","/**\r\n * Chart.Platform implementation for targeting a web browser\r\n */\r\n\r\nimport BasePlatform from './platform.base.js';\r\nimport {_getParentNode, getRelativePosition, supportsEventListenerOptions, readUsedSize, getMaximumSize} from '../helpers/helpers.dom.js';\r\nimport {throttled} from '../helpers/helpers.extras.js';\r\nimport {isNullOrUndef} from '../helpers/helpers.core.js';\r\n\r\n/**\r\n * @typedef { import('../core/core.controller.js').default } Chart\r\n */\r\n\r\nconst EXPANDO_KEY = '$chartjs';\r\n\r\n/**\r\n * DOM event types -> Chart.js event types.\r\n * Note: only events with different types are mapped.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\r\n */\r\nconst EVENT_TYPES = {\r\n  touchstart: 'mousedown',\r\n  touchmove: 'mousemove',\r\n  touchend: 'mouseup',\r\n  pointerenter: 'mouseenter',\r\n  pointerdown: 'mousedown',\r\n  pointermove: 'mousemove',\r\n  pointerup: 'mouseup',\r\n  pointerleave: 'mouseout',\r\n  pointerout: 'mouseout'\r\n};\r\n\r\nconst isNullOrEmpty = value => value === null || value === '';\r\n/**\r\n * Initializes the canvas style and render size without modifying the canvas display size,\r\n * since responsiveness is handled by the controller.resize() method. The config is used\r\n * to determine the aspect ratio to apply in case no explicit height has been specified.\r\n * @param {HTMLCanvasElement} canvas\r\n * @param {number} [aspectRatio]\r\n */\r\nfunction initCanvas(canvas, aspectRatio) {\r\n  const style = canvas.style;\r\n\r\n  // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\r\n  // returns null or '' if no explicit value has been set to the canvas attribute.\r\n  const renderHeight = canvas.getAttribute('height');\r\n  const renderWidth = canvas.getAttribute('width');\r\n\r\n  // Chart.js modifies some canvas values that we want to restore on destroy\r\n  canvas[EXPANDO_KEY] = {\r\n    initial: {\r\n      height: renderHeight,\r\n      width: renderWidth,\r\n      style: {\r\n        display: style.display,\r\n        height: style.height,\r\n        width: style.width\r\n      }\r\n    }\r\n  };\r\n\r\n  // Force canvas to display as block to avoid extra space caused by inline\r\n  // elements, which would interfere with the responsive resize process.\r\n  // https://github.com/chartjs/Chart.js/issues/2538\r\n  style.display = style.display || 'block';\r\n  // Include possible borders in the size\r\n  style.boxSizing = style.boxSizing || 'border-box';\r\n\r\n  if (isNullOrEmpty(renderWidth)) {\r\n    const displayWidth = readUsedSize(canvas, 'width');\r\n    if (displayWidth !== undefined) {\r\n      canvas.width = displayWidth;\r\n    }\r\n  }\r\n\r\n  if (isNullOrEmpty(renderHeight)) {\r\n    if (canvas.style.height === '') {\r\n      // If no explicit render height and style height, let's apply the aspect ratio,\r\n      // which one can be specified by the user but also by charts as default option\r\n      // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\r\n      canvas.height = canvas.width / (aspectRatio || 2);\r\n    } else {\r\n      const displayHeight = readUsedSize(canvas, 'height');\r\n      if (displayHeight !== undefined) {\r\n        canvas.height = displayHeight;\r\n      }\r\n    }\r\n  }\r\n\r\n  return canvas;\r\n}\r\n\r\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\r\n// https://github.com/chartjs/Chart.js/issues/4287\r\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\r\n\r\nfunction addListener(node, type, listener) {\r\n  node.addEventListener(type, listener, eventListenerOptions);\r\n}\r\n\r\nfunction removeListener(chart, type, listener) {\r\n  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\r\n}\r\n\r\nfunction fromNativeEvent(event, chart) {\r\n  const type = EVENT_TYPES[event.type] || event.type;\r\n  const {x, y} = getRelativePosition(event, chart);\r\n  return {\r\n    type,\r\n    chart,\r\n    native: event,\r\n    x: x !== undefined ? x : null,\r\n    y: y !== undefined ? y : null,\r\n  };\r\n}\r\n\r\nfunction nodeListContains(nodeList, canvas) {\r\n  for (const node of nodeList) {\r\n    if (node === canvas || node.contains(canvas)) {\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction createAttachObserver(chart, type, listener) {\r\n  const canvas = chart.canvas;\r\n  const observer = new MutationObserver(entries => {\r\n    let trigger = false;\r\n    for (const entry of entries) {\r\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\r\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\r\n    }\r\n    if (trigger) {\r\n      listener();\r\n    }\r\n  });\r\n  observer.observe(document, {childList: true, subtree: true});\r\n  return observer;\r\n}\r\n\r\nfunction createDetachObserver(chart, type, listener) {\r\n  const canvas = chart.canvas;\r\n  const observer = new MutationObserver(entries => {\r\n    let trigger = false;\r\n    for (const entry of entries) {\r\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\r\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\r\n    }\r\n    if (trigger) {\r\n      listener();\r\n    }\r\n  });\r\n  observer.observe(document, {childList: true, subtree: true});\r\n  return observer;\r\n}\r\n\r\nconst drpListeningCharts = new Map();\r\nlet oldDevicePixelRatio = 0;\r\n\r\nfunction onWindowResize() {\r\n  const dpr = window.devicePixelRatio;\r\n  if (dpr === oldDevicePixelRatio) {\r\n    return;\r\n  }\r\n  oldDevicePixelRatio = dpr;\r\n  drpListeningCharts.forEach((resize, chart) => {\r\n    if (chart.currentDevicePixelRatio !== dpr) {\r\n      resize();\r\n    }\r\n  });\r\n}\r\n\r\nfunction listenDevicePixelRatioChanges(chart, resize) {\r\n  if (!drpListeningCharts.size) {\r\n    window.addEventListener('resize', onWindowResize);\r\n  }\r\n  drpListeningCharts.set(chart, resize);\r\n}\r\n\r\nfunction unlistenDevicePixelRatioChanges(chart) {\r\n  drpListeningCharts.delete(chart);\r\n  if (!drpListeningCharts.size) {\r\n    window.removeEventListener('resize', onWindowResize);\r\n  }\r\n}\r\n\r\nfunction createResizeObserver(chart, type, listener) {\r\n  const canvas = chart.canvas;\r\n  const container = canvas && _getParentNode(canvas);\r\n  if (!container) {\r\n    return;\r\n  }\r\n  const resize = throttled((width, height) => {\r\n    const w = container.clientWidth;\r\n    listener(width, height);\r\n    if (w < container.clientWidth) {\r\n      // If the container size shrank during chart resize, let's assume\r\n      // scrollbar appeared. So we resize again with the scrollbar visible -\r\n      // effectively making chart smaller and the scrollbar hidden again.\r\n      // Because we are inside `throttled`, and currently `ticking`, scroll\r\n      // events are ignored during this whole 2 resize process.\r\n      // If we assumed wrong and something else happened, we are resizing\r\n      // twice in a frame (potential performance issue)\r\n      listener();\r\n    }\r\n  }, window);\r\n\r\n  // @ts-ignore until https://github.com/microsoft/TypeScript/issues/37861 implemented\r\n  const observer = new ResizeObserver(entries => {\r\n    const entry = entries[0];\r\n    const width = entry.contentRect.width;\r\n    const height = entry.contentRect.height;\r\n    // When its container's display is set to 'none' the callback will be called with a\r\n    // size of (0, 0), which will cause the chart to lose its original height, so skip\r\n    // resizing in such case.\r\n    if (width === 0 && height === 0) {\r\n      return;\r\n    }\r\n    resize(width, height);\r\n  });\r\n  observer.observe(container);\r\n  listenDevicePixelRatioChanges(chart, resize);\r\n\r\n  return observer;\r\n}\r\n\r\nfunction releaseObserver(chart, type, observer) {\r\n  if (observer) {\r\n    observer.disconnect();\r\n  }\r\n  if (type === 'resize') {\r\n    unlistenDevicePixelRatioChanges(chart);\r\n  }\r\n}\r\n\r\nfunction createProxyAndListen(chart, type, listener) {\r\n  const canvas = chart.canvas;\r\n  const proxy = throttled((event) => {\r\n    // This case can occur if the chart is destroyed while waiting\r\n    // for the throttled function to occur. We prevent crashes by checking\r\n    // for a destroyed chart\r\n    if (chart.ctx !== null) {\r\n      listener(fromNativeEvent(event, chart));\r\n    }\r\n  }, chart);\r\n\r\n  addListener(canvas, type, proxy);\r\n\r\n  return proxy;\r\n}\r\n\r\n/**\r\n * Platform class for charts that can access the DOM and global window/document properties\r\n * @extends BasePlatform\r\n */\r\nexport default class DomPlatform extends BasePlatform {\r\n\r\n  /**\r\n\t * @param {HTMLCanvasElement} canvas\r\n\t * @param {number} [aspectRatio]\r\n\t * @return {CanvasRenderingContext2D|null}\r\n\t */\r\n  acquireContext(canvas, aspectRatio) {\r\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\r\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\r\n    // https://github.com/chartjs/Chart.js/issues/2807\r\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\r\n\r\n    // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the canvas is\r\n    // inside an iframe or when running in a protected environment. We could guess the\r\n    // types from their toString() value but let's keep things flexible and assume it's\r\n    // a sufficient condition if the canvas has a context2D which has canvas as `canvas`.\r\n    // https://github.com/chartjs/Chart.js/issues/3887\r\n    // https://github.com/chartjs/Chart.js/issues/4102\r\n    // https://github.com/chartjs/Chart.js/issues/4152\r\n    if (context && context.canvas === canvas) {\r\n      // Load platform resources on first chart creation, to make it possible to\r\n      // import the library before setting platform options.\r\n      initCanvas(canvas, aspectRatio);\r\n      return context;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n\t * @param {CanvasRenderingContext2D} context\r\n\t */\r\n  releaseContext(context) {\r\n    const canvas = context.canvas;\r\n    if (!canvas[EXPANDO_KEY]) {\r\n      return false;\r\n    }\r\n\r\n    const initial = canvas[EXPANDO_KEY].initial;\r\n    ['height', 'width'].forEach((prop) => {\r\n      const value = initial[prop];\r\n      if (isNullOrUndef(value)) {\r\n        canvas.removeAttribute(prop);\r\n      } else {\r\n        canvas.setAttribute(prop, value);\r\n      }\r\n    });\r\n\r\n    const style = initial.style || {};\r\n    Object.keys(style).forEach((key) => {\r\n      canvas.style[key] = style[key];\r\n    });\r\n\r\n    // The canvas render size might have been changed (and thus the state stack discarded),\r\n    // we can't use save() and restore() to restore the initial state. So make sure that at\r\n    // least the canvas context is reset to the default state by setting the canvas width.\r\n    // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\r\n    // eslint-disable-next-line no-self-assign\r\n    canvas.width = canvas.width;\r\n\r\n    delete canvas[EXPANDO_KEY];\r\n    return true;\r\n  }\r\n\r\n  /**\r\n\t *\r\n\t * @param {Chart} chart\r\n\t * @param {string} type\r\n\t * @param {function} listener\r\n\t */\r\n  addEventListener(chart, type, listener) {\r\n    // Can have only one listener per type, so make sure previous is removed\r\n    this.removeEventListener(chart, type);\r\n\r\n    const proxies = chart.$proxies || (chart.$proxies = {});\r\n    const handlers = {\r\n      attach: createAttachObserver,\r\n      detach: createDetachObserver,\r\n      resize: createResizeObserver\r\n    };\r\n    const handler = handlers[type] || createProxyAndListen;\r\n    proxies[type] = handler(chart, type, listener);\r\n  }\r\n\r\n\r\n  /**\r\n\t * @param {Chart} chart\r\n\t * @param {string} type\r\n\t */\r\n  removeEventListener(chart, type) {\r\n    const proxies = chart.$proxies || (chart.$proxies = {});\r\n    const proxy = proxies[type];\r\n\r\n    if (!proxy) {\r\n      return;\r\n    }\r\n\r\n    const handlers = {\r\n      attach: releaseObserver,\r\n      detach: releaseObserver,\r\n      resize: releaseObserver\r\n    };\r\n    const handler = handlers[type] || removeListener;\r\n    handler(chart, type, proxy);\r\n    proxies[type] = undefined;\r\n  }\r\n\r\n  getDevicePixelRatio() {\r\n    return window.devicePixelRatio;\r\n  }\r\n\r\n  /**\r\n\t * @param {HTMLCanvasElement} canvas\r\n\t * @param {number} [width] - content width of parent element\r\n\t * @param {number} [height] - content height of parent element\r\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\r\n\t */\r\n  getMaximumSize(canvas, width, height, aspectRatio) {\r\n    return getMaximumSize(canvas, width, height, aspectRatio);\r\n  }\r\n\r\n  /**\r\n\t * @param {HTMLCanvasElement} canvas\r\n\t */\r\n  isAttached(canvas) {\r\n    const container = _getParentNode(canvas);\r\n    return !!(container && container.isConnected);\r\n  }\r\n}\r\n","import {_isDomSupported} from '../helpers/index.js';\r\nimport BasePlatform from './platform.base.js';\r\nimport BasicPlatform from './platform.basic.js';\r\nimport DomPlatform from './platform.dom.js';\r\n\r\nexport function _detectPlatform(canvas) {\r\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\r\n    return BasicPlatform;\r\n  }\r\n  return DomPlatform;\r\n}\r\n\r\nexport {BasePlatform, BasicPlatform, DomPlatform};\r\n","import effects from '../helpers/helpers.easing.js';\r\nimport {resolve} from '../helpers/helpers.options.js';\r\nimport {color as helpersColor} from '../helpers/helpers.color.js';\r\n\r\nconst transparent = 'transparent';\r\nconst interpolators = {\r\n  boolean(from, to, factor) {\r\n    return factor > 0.5 ? to : from;\r\n  },\r\n  /**\r\n   * @param {string} from\r\n   * @param {string} to\r\n   * @param {number} factor\r\n   */\r\n  color(from, to, factor) {\r\n    const c0 = helpersColor(from || transparent);\r\n    const c1 = c0.valid && helpersColor(to || transparent);\r\n    return c1 && c1.valid\r\n      ? c1.mix(c0, factor).hexString()\r\n      : to;\r\n  },\r\n  number(from, to, factor) {\r\n    return from + (to - from) * factor;\r\n  }\r\n};\r\n\r\nexport default class Animation {\r\n  constructor(cfg, target, prop, to) {\r\n    const currentValue = target[prop];\r\n\r\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\r\n    const from = resolve([cfg.from, currentValue, to]);\r\n\r\n    this._active = true;\r\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\r\n    this._easing = effects[cfg.easing] || effects.linear;\r\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\r\n    this._duration = this._total = Math.floor(cfg.duration);\r\n    this._loop = !!cfg.loop;\r\n    this._target = target;\r\n    this._prop = prop;\r\n    this._from = from;\r\n    this._to = to;\r\n    this._promises = undefined;\r\n  }\r\n\r\n  active() {\r\n    return this._active;\r\n  }\r\n\r\n  update(cfg, to, date) {\r\n    if (this._active) {\r\n      this._notify(false);\r\n\r\n      const currentValue = this._target[this._prop];\r\n      const elapsed = date - this._start;\r\n      const remain = this._duration - elapsed;\r\n      this._start = date;\r\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\r\n      this._total += elapsed;\r\n      this._loop = !!cfg.loop;\r\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\r\n      this._from = resolve([cfg.from, currentValue, to]);\r\n    }\r\n  }\r\n\r\n  cancel() {\r\n    if (this._active) {\r\n      // update current evaluated value, for smoother animations\r\n      this.tick(Date.now());\r\n      this._active = false;\r\n      this._notify(false);\r\n    }\r\n  }\r\n\r\n  tick(date) {\r\n    const elapsed = date - this._start;\r\n    const duration = this._duration;\r\n    const prop = this._prop;\r\n    const from = this._from;\r\n    const loop = this._loop;\r\n    const to = this._to;\r\n    let factor;\r\n\r\n    this._active = from !== to && (loop || (elapsed < duration));\r\n\r\n    if (!this._active) {\r\n      this._target[prop] = to;\r\n      this._notify(true);\r\n      return;\r\n    }\r\n\r\n    if (elapsed < 0) {\r\n      this._target[prop] = from;\r\n      return;\r\n    }\r\n\r\n    factor = (elapsed / duration) % 2;\r\n    factor = loop && factor > 1 ? 2 - factor : factor;\r\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\r\n\r\n    this._target[prop] = this._fn(from, to, factor);\r\n  }\r\n\r\n  wait() {\r\n    const promises = this._promises || (this._promises = []);\r\n    return new Promise((res, rej) => {\r\n      promises.push({res, rej});\r\n    });\r\n  }\r\n\r\n  _notify(resolved) {\r\n    const method = resolved ? 'res' : 'rej';\r\n    const promises = this._promises || [];\r\n    for (let i = 0; i < promises.length; i++) {\r\n      promises[i][method]();\r\n    }\r\n  }\r\n}\r\n","import animator from './core.animator.js';\r\nimport Animation from './core.animation.js';\r\nimport defaults from './core.defaults.js';\r\nimport {isArray, isObject} from '../helpers/helpers.core.js';\r\n\r\nexport default class Animations {\r\n  constructor(chart, config) {\r\n    this._chart = chart;\r\n    this._properties = new Map();\r\n    this.configure(config);\r\n  }\r\n\r\n  configure(config) {\r\n    if (!isObject(config)) {\r\n      return;\r\n    }\r\n\r\n    const animationOptions = Object.keys(defaults.animation);\r\n    const animatedProps = this._properties;\r\n\r\n    Object.getOwnPropertyNames(config).forEach(key => {\r\n      const cfg = config[key];\r\n      if (!isObject(cfg)) {\r\n        return;\r\n      }\r\n      const resolved = {};\r\n      for (const option of animationOptions) {\r\n        resolved[option] = cfg[option];\r\n      }\r\n\r\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\r\n        if (prop === key || !animatedProps.has(prop)) {\r\n          animatedProps.set(prop, resolved);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n\t * Utility to handle animation of `options`.\r\n\t * @private\r\n\t */\r\n  _animateOptions(target, values) {\r\n    const newOptions = values.options;\r\n    const options = resolveTargetOptions(target, newOptions);\r\n    if (!options) {\r\n      return [];\r\n    }\r\n\r\n    const animations = this._createAnimations(options, newOptions);\r\n    if (newOptions.$shared) {\r\n      // Going to shared options:\r\n      // After all animations are done, assign the shared options object to the element\r\n      // So any new updates to the shared options are observed\r\n      awaitAll(target.options.$animations, newOptions).then(() => {\r\n        target.options = newOptions;\r\n      }, () => {\r\n        // rejected, noop\r\n      });\r\n    }\r\n\r\n    return animations;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _createAnimations(target, values) {\r\n    const animatedProps = this._properties;\r\n    const animations = [];\r\n    const running = target.$animations || (target.$animations = {});\r\n    const props = Object.keys(values);\r\n    const date = Date.now();\r\n    let i;\r\n\r\n    for (i = props.length - 1; i >= 0; --i) {\r\n      const prop = props[i];\r\n      if (prop.charAt(0) === '$') {\r\n        continue;\r\n      }\r\n\r\n      if (prop === 'options') {\r\n        animations.push(...this._animateOptions(target, values));\r\n        continue;\r\n      }\r\n      const value = values[prop];\r\n      let animation = running[prop];\r\n      const cfg = animatedProps.get(prop);\r\n\r\n      if (animation) {\r\n        if (cfg && animation.active()) {\r\n          // There is an existing active animation, let's update that\r\n          animation.update(cfg, value, date);\r\n          continue;\r\n        } else {\r\n          animation.cancel();\r\n        }\r\n      }\r\n      if (!cfg || !cfg.duration) {\r\n        // not animated, set directly to new value\r\n        target[prop] = value;\r\n        continue;\r\n      }\r\n\r\n      running[prop] = animation = new Animation(cfg, target, prop, value);\r\n      animations.push(animation);\r\n    }\r\n    return animations;\r\n  }\r\n\r\n\r\n  /**\r\n\t * Update `target` properties to new values, using configured animations\r\n\t * @param {object} target - object to update\r\n\t * @param {object} values - new target properties\r\n\t * @returns {boolean|undefined} - `true` if animations were started\r\n\t **/\r\n  update(target, values) {\r\n    if (this._properties.size === 0) {\r\n      // Nothing is animated, just apply the new values.\r\n      Object.assign(target, values);\r\n      return;\r\n    }\r\n\r\n    const animations = this._createAnimations(target, values);\r\n\r\n    if (animations.length) {\r\n      animator.add(this._chart, animations);\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction awaitAll(animations, properties) {\r\n  const running = [];\r\n  const keys = Object.keys(properties);\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const anim = animations[keys[i]];\r\n    if (anim && anim.active()) {\r\n      running.push(anim.wait());\r\n    }\r\n  }\r\n  // @ts-ignore\r\n  return Promise.all(running);\r\n}\r\n\r\nfunction resolveTargetOptions(target, newOptions) {\r\n  if (!newOptions) {\r\n    return;\r\n  }\r\n  let options = target.options;\r\n  if (!options) {\r\n    target.options = newOptions;\r\n    return;\r\n  }\r\n  if (options.$shared) {\r\n    // Going from shared options to distinct one:\r\n    // Create new options object containing the old shared values and start updating that.\r\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\r\n  }\r\n  return options;\r\n}\r\n","import Animations from './core.animations.js';\r\nimport defaults from './core.defaults.js';\r\nimport {isArray, isFinite, isObject, valueOrDefault, resolveObjectKey, defined} from '../helpers/helpers.core.js';\r\nimport {listenArrayEvents, unlistenArrayEvents} from '../helpers/helpers.collection.js';\r\nimport {createContext, sign} from '../helpers/index.js';\r\n\r\n/**\r\n * @typedef { import('./core.controller.js').default } Chart\r\n * @typedef { import('./core.scale.js').default } Scale\r\n */\r\n\r\nfunction scaleClip(scale, allowedOverflow) {\r\n  const opts = scale && scale.options || {};\r\n  const reverse = opts.reverse;\r\n  const min = opts.min === undefined ? allowedOverflow : 0;\r\n  const max = opts.max === undefined ? allowedOverflow : 0;\r\n  return {\r\n    start: reverse ? max : min,\r\n    end: reverse ? min : max\r\n  };\r\n}\r\n\r\nfunction defaultClip(xScale, yScale, allowedOverflow) {\r\n  if (allowedOverflow === false) {\r\n    return false;\r\n  }\r\n  const x = scaleClip(xScale, allowedOverflow);\r\n  const y = scaleClip(yScale, allowedOverflow);\r\n\r\n  return {\r\n    top: y.end,\r\n    right: x.end,\r\n    bottom: y.start,\r\n    left: x.start\r\n  };\r\n}\r\n\r\nfunction toClip(value) {\r\n  let t, r, b, l;\r\n\r\n  if (isObject(value)) {\r\n    t = value.top;\r\n    r = value.right;\r\n    b = value.bottom;\r\n    l = value.left;\r\n  } else {\r\n    t = r = b = l = value;\r\n  }\r\n\r\n  return {\r\n    top: t,\r\n    right: r,\r\n    bottom: b,\r\n    left: l,\r\n    disabled: value === false\r\n  };\r\n}\r\n\r\nfunction getSortedDatasetIndices(chart, filterVisible) {\r\n  const keys = [];\r\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\r\n  let i, ilen;\r\n\r\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n    keys.push(metasets[i].index);\r\n  }\r\n  return keys;\r\n}\r\n\r\nfunction applyStack(stack, value, dsIndex, options = {}) {\r\n  const keys = stack.keys;\r\n  const singleMode = options.mode === 'single';\r\n  let i, ilen, datasetIndex, otherValue;\r\n\r\n  if (value === null) {\r\n    return;\r\n  }\r\n\r\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\r\n    datasetIndex = +keys[i];\r\n    if (datasetIndex === dsIndex) {\r\n      if (options.all) {\r\n        continue;\r\n      }\r\n      break;\r\n    }\r\n    otherValue = stack.values[datasetIndex];\r\n    if (isFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\r\n      value += otherValue;\r\n    }\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction convertObjectDataToArray(data) {\r\n  const keys = Object.keys(data);\r\n  const adata = new Array(keys.length);\r\n  let i, ilen, key;\r\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\r\n    key = keys[i];\r\n    adata[i] = {\r\n      x: key,\r\n      y: data[key]\r\n    };\r\n  }\r\n  return adata;\r\n}\r\n\r\nfunction isStacked(scale, meta) {\r\n  const stacked = scale && scale.options.stacked;\r\n  return stacked || (stacked === undefined && meta.stack !== undefined);\r\n}\r\n\r\nfunction getStackKey(indexScale, valueScale, meta) {\r\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\r\n}\r\n\r\nfunction getUserBounds(scale) {\r\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\r\n  return {\r\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\r\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\r\n  };\r\n}\r\n\r\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\r\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\r\n  return subStack[indexValue] || (subStack[indexValue] = {});\r\n}\r\n\r\nfunction getLastIndexInStack(stack, vScale, positive, type) {\r\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\r\n    const value = stack[meta.index];\r\n    if ((positive && value > 0) || (!positive && value < 0)) {\r\n      return meta.index;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction updateStacks(controller, parsed) {\r\n  const {chart, _cachedMeta: meta} = controller;\r\n  const stacks = chart._stacks || (chart._stacks = {}); // map structure is {stackKey: {datasetIndex: value}}\r\n  const {iScale, vScale, index: datasetIndex} = meta;\r\n  const iAxis = iScale.axis;\r\n  const vAxis = vScale.axis;\r\n  const key = getStackKey(iScale, vScale, meta);\r\n  const ilen = parsed.length;\r\n  let stack;\r\n\r\n  for (let i = 0; i < ilen; ++i) {\r\n    const item = parsed[i];\r\n    const {[iAxis]: index, [vAxis]: value} = item;\r\n    const itemStacks = item._stacks || (item._stacks = {});\r\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\r\n    stack[datasetIndex] = value;\r\n\r\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\r\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\r\n\r\n    const visualValues = stack._visualValues || (stack._visualValues = {});\r\n    visualValues[datasetIndex] = value;\r\n  }\r\n}\r\n\r\nfunction getFirstScaleId(chart, axis) {\r\n  const scales = chart.scales;\r\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\r\n}\r\n\r\nfunction createDatasetContext(parent, index) {\r\n  return createContext(parent,\r\n    {\r\n      active: false,\r\n      dataset: undefined,\r\n      datasetIndex: index,\r\n      index,\r\n      mode: 'default',\r\n      type: 'dataset'\r\n    }\r\n  );\r\n}\r\n\r\nfunction createDataContext(parent, index, element) {\r\n  return createContext(parent, {\r\n    active: false,\r\n    dataIndex: index,\r\n    parsed: undefined,\r\n    raw: undefined,\r\n    element,\r\n    index,\r\n    mode: 'default',\r\n    type: 'data'\r\n  });\r\n}\r\n\r\nfunction clearStacks(meta, items) {\r\n  // Not using meta.index here, because it might be already updated if the dataset changed location\r\n  const datasetIndex = meta.controller.index;\r\n  const axis = meta.vScale && meta.vScale.axis;\r\n  if (!axis) {\r\n    return;\r\n  }\r\n\r\n  items = items || meta._parsed;\r\n  for (const parsed of items) {\r\n    const stacks = parsed._stacks;\r\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\r\n      return;\r\n    }\r\n    delete stacks[axis][datasetIndex];\r\n    if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\r\n      delete stacks[axis]._visualValues[datasetIndex];\r\n    }\r\n  }\r\n}\r\n\r\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\r\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\r\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\r\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\r\n\r\nexport default class DatasetController {\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {};\r\n\r\n  /**\r\n   * Element type used to generate a meta dataset (e.g. Chart.element.LineElement).\r\n   */\r\n  static datasetElementType = null;\r\n\r\n  /**\r\n   * Element type used to generate a meta data (e.g. Chart.element.PointElement).\r\n   */\r\n  static dataElementType = null;\r\n\r\n  /**\r\n\t * @param {Chart} chart\r\n\t * @param {number} datasetIndex\r\n\t */\r\n  constructor(chart, datasetIndex) {\r\n    this.chart = chart;\r\n    this._ctx = chart.ctx;\r\n    this.index = datasetIndex;\r\n    this._cachedDataOpts = {};\r\n    this._cachedMeta = this.getMeta();\r\n    this._type = this._cachedMeta.type;\r\n    this.options = undefined;\r\n    /** @type {boolean | object} */\r\n    this._parsing = false;\r\n    this._data = undefined;\r\n    this._objectData = undefined;\r\n    this._sharedOptions = undefined;\r\n    this._drawStart = undefined;\r\n    this._drawCount = undefined;\r\n    this.enableOptionSharing = false;\r\n    this.supportsDecimation = false;\r\n    this.$context = undefined;\r\n    this._syncList = [];\r\n    this.datasetElementType = new.target.datasetElementType;\r\n    this.dataElementType = new.target.dataElementType;\r\n\r\n    this.initialize();\r\n  }\r\n\r\n  initialize() {\r\n    const meta = this._cachedMeta;\r\n    this.configure();\r\n    this.linkScales();\r\n    meta._stacked = isStacked(meta.vScale, meta);\r\n    this.addElements();\r\n\r\n    if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\r\n      console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\r\n    }\r\n  }\r\n\r\n  updateIndex(datasetIndex) {\r\n    if (this.index !== datasetIndex) {\r\n      clearStacks(this._cachedMeta);\r\n    }\r\n    this.index = datasetIndex;\r\n  }\r\n\r\n  linkScales() {\r\n    const chart = this.chart;\r\n    const meta = this._cachedMeta;\r\n    const dataset = this.getDataset();\r\n\r\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\r\n\r\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\r\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\r\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\r\n    const indexAxis = meta.indexAxis;\r\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\r\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\r\n    meta.xScale = this.getScaleForId(xid);\r\n    meta.yScale = this.getScaleForId(yid);\r\n    meta.rScale = this.getScaleForId(rid);\r\n    meta.iScale = this.getScaleForId(iid);\r\n    meta.vScale = this.getScaleForId(vid);\r\n  }\r\n\r\n  getDataset() {\r\n    return this.chart.data.datasets[this.index];\r\n  }\r\n\r\n  getMeta() {\r\n    return this.chart.getDatasetMeta(this.index);\r\n  }\r\n\r\n  /**\r\n\t * @param {string} scaleID\r\n\t * @return {Scale}\r\n\t */\r\n  getScaleForId(scaleID) {\r\n    return this.chart.scales[scaleID];\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getOtherScale(scale) {\r\n    const meta = this._cachedMeta;\r\n    return scale === meta.iScale\r\n      ? meta.vScale\r\n      : meta.iScale;\r\n  }\r\n\r\n  reset() {\r\n    this._update('reset');\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _destroy() {\r\n    const meta = this._cachedMeta;\r\n    if (this._data) {\r\n      unlistenArrayEvents(this._data, this);\r\n    }\r\n    if (meta._stacked) {\r\n      clearStacks(meta);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _dataCheck() {\r\n    const dataset = this.getDataset();\r\n    const data = dataset.data || (dataset.data = []);\r\n    const _data = this._data;\r\n\r\n    // In order to correctly handle data addition/deletion animation (an thus simulate\r\n    // real-time charts), we need to monitor these data modifications and synchronize\r\n    // the internal meta data accordingly.\r\n\r\n    if (isObject(data)) {\r\n      this._data = convertObjectDataToArray(data);\r\n    } else if (_data !== data) {\r\n      if (_data) {\r\n        // This case happens when the user replaced the data array instance.\r\n        unlistenArrayEvents(_data, this);\r\n        // Discard old parsed data and stacks\r\n        const meta = this._cachedMeta;\r\n        clearStacks(meta);\r\n        meta._parsed = [];\r\n      }\r\n      if (data && Object.isExtensible(data)) {\r\n        listenArrayEvents(data, this);\r\n      }\r\n      this._syncList = [];\r\n      this._data = data;\r\n    }\r\n  }\r\n\r\n  addElements() {\r\n    const meta = this._cachedMeta;\r\n\r\n    this._dataCheck();\r\n\r\n    if (this.datasetElementType) {\r\n      meta.dataset = new this.datasetElementType();\r\n    }\r\n  }\r\n\r\n  buildOrUpdateElements(resetNewElements) {\r\n    const meta = this._cachedMeta;\r\n    const dataset = this.getDataset();\r\n    let stackChanged = false;\r\n\r\n    this._dataCheck();\r\n\r\n    // make sure cached _stacked status is current\r\n    const oldStacked = meta._stacked;\r\n    meta._stacked = isStacked(meta.vScale, meta);\r\n\r\n    // detect change in stack option\r\n    if (meta.stack !== dataset.stack) {\r\n      stackChanged = true;\r\n      // remove values from old stack\r\n      clearStacks(meta);\r\n      meta.stack = dataset.stack;\r\n    }\r\n\r\n    // Re-sync meta data in case the user replaced the data array or if we missed\r\n    // any updates and so make sure that we handle number of datapoints changing.\r\n    this._resyncElements(resetNewElements);\r\n\r\n    // if stack changed, update stack values for the whole dataset\r\n    if (stackChanged || oldStacked !== meta._stacked) {\r\n      updateStacks(this, meta._parsed);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Merges user-supplied and default dataset-level options\r\n\t * @private\r\n\t */\r\n  configure() {\r\n    const config = this.chart.config;\r\n    const scopeKeys = config.datasetScopeKeys(this._type);\r\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\r\n    this.options = config.createResolver(scopes, this.getContext());\r\n    this._parsing = this.options.parsing;\r\n    this._cachedDataOpts = {};\r\n  }\r\n\r\n  /**\r\n\t * @param {number} start\r\n\t * @param {number} count\r\n\t */\r\n  parse(start, count) {\r\n    const {_cachedMeta: meta, _data: data} = this;\r\n    const {iScale, _stacked} = meta;\r\n    const iAxis = iScale.axis;\r\n\r\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\r\n    let prev = start > 0 && meta._parsed[start - 1];\r\n    let i, cur, parsed;\r\n\r\n    if (this._parsing === false) {\r\n      meta._parsed = data;\r\n      meta._sorted = true;\r\n      parsed = data;\r\n    } else {\r\n      if (isArray(data[start])) {\r\n        parsed = this.parseArrayData(meta, data, start, count);\r\n      } else if (isObject(data[start])) {\r\n        parsed = this.parseObjectData(meta, data, start, count);\r\n      } else {\r\n        parsed = this.parsePrimitiveData(meta, data, start, count);\r\n      }\r\n\r\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\r\n      for (i = 0; i < count; ++i) {\r\n        meta._parsed[i + start] = cur = parsed[i];\r\n        if (sorted) {\r\n          if (isNotInOrderComparedToPrev()) {\r\n            sorted = false;\r\n          }\r\n          prev = cur;\r\n        }\r\n      }\r\n      meta._sorted = sorted;\r\n    }\r\n\r\n    if (_stacked) {\r\n      updateStacks(this, parsed);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Parse array of primitive values\r\n\t * @param {object} meta - dataset meta\r\n\t * @param {array} data - data array. Example [1,3,4]\r\n\t * @param {number} start - start index\r\n\t * @param {number} count - number of items to parse\r\n\t * @returns {object} parsed item - item containing index and a parsed value\r\n\t * for each scale id.\r\n\t * Example: {xScale0: 0, yScale0: 1}\r\n\t * @protected\r\n\t */\r\n  parsePrimitiveData(meta, data, start, count) {\r\n    const {iScale, vScale} = meta;\r\n    const iAxis = iScale.axis;\r\n    const vAxis = vScale.axis;\r\n    const labels = iScale.getLabels();\r\n    const singleScale = iScale === vScale;\r\n    const parsed = new Array(count);\r\n    let i, ilen, index;\r\n\r\n    for (i = 0, ilen = count; i < ilen; ++i) {\r\n      index = i + start;\r\n      parsed[i] = {\r\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\r\n        [vAxis]: vScale.parse(data[index], index)\r\n      };\r\n    }\r\n    return parsed;\r\n  }\r\n\r\n  /**\r\n\t * Parse array of arrays\r\n\t * @param {object} meta - dataset meta\r\n\t * @param {array} data - data array. Example [[1,2],[3,4]]\r\n\t * @param {number} start - start index\r\n\t * @param {number} count - number of items to parse\r\n\t * @returns {object} parsed item - item containing index and a parsed value\r\n\t * for each scale id.\r\n\t * Example: {x: 0, y: 1}\r\n\t * @protected\r\n\t */\r\n  parseArrayData(meta, data, start, count) {\r\n    const {xScale, yScale} = meta;\r\n    const parsed = new Array(count);\r\n    let i, ilen, index, item;\r\n\r\n    for (i = 0, ilen = count; i < ilen; ++i) {\r\n      index = i + start;\r\n      item = data[index];\r\n      parsed[i] = {\r\n        x: xScale.parse(item[0], index),\r\n        y: yScale.parse(item[1], index)\r\n      };\r\n    }\r\n    return parsed;\r\n  }\r\n\r\n  /**\r\n\t * Parse array of objects\r\n\t * @param {object} meta - dataset meta\r\n\t * @param {array} data - data array. Example [{x:1, y:5}, {x:2, y:10}]\r\n\t * @param {number} start - start index\r\n\t * @param {number} count - number of items to parse\r\n\t * @returns {object} parsed item - item containing index and a parsed value\r\n\t * for each scale id. _custom is optional\r\n\t * Example: {xScale0: 0, yScale0: 1, _custom: {r: 10, foo: 'bar'}}\r\n\t * @protected\r\n\t */\r\n  parseObjectData(meta, data, start, count) {\r\n    const {xScale, yScale} = meta;\r\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\r\n    const parsed = new Array(count);\r\n    let i, ilen, index, item;\r\n\r\n    for (i = 0, ilen = count; i < ilen; ++i) {\r\n      index = i + start;\r\n      item = data[index];\r\n      parsed[i] = {\r\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\r\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\r\n      };\r\n    }\r\n    return parsed;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getParsed(index) {\r\n    return this._cachedMeta._parsed[index];\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getDataElement(index) {\r\n    return this._cachedMeta.data[index];\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  applyStack(scale, parsed, mode) {\r\n    const chart = this.chart;\r\n    const meta = this._cachedMeta;\r\n    const value = parsed[scale.axis];\r\n    const stack = {\r\n      keys: getSortedDatasetIndices(chart, true),\r\n      values: parsed._stacks[scale.axis]._visualValues\r\n    };\r\n    return applyStack(stack, value, meta.index, {mode});\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  updateRangeFromParsed(range, scale, parsed, stack) {\r\n    const parsedValue = parsed[scale.axis];\r\n    let value = parsedValue === null ? NaN : parsedValue;\r\n    const values = stack && parsed._stacks[scale.axis];\r\n    if (stack && values) {\r\n      stack.values = values;\r\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\r\n    }\r\n    range.min = Math.min(range.min, value);\r\n    range.max = Math.max(range.max, value);\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getMinMax(scale, canStack) {\r\n    const meta = this._cachedMeta;\r\n    const _parsed = meta._parsed;\r\n    const sorted = meta._sorted && scale === meta.iScale;\r\n    const ilen = _parsed.length;\r\n    const otherScale = this._getOtherScale(scale);\r\n    const stack = createStack(canStack, meta, this.chart);\r\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\r\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\r\n    let i, parsed;\r\n\r\n    function _skip() {\r\n      parsed = _parsed[i];\r\n      const otherValue = parsed[otherScale.axis];\r\n      return !isFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\r\n    }\r\n\r\n    for (i = 0; i < ilen; ++i) {\r\n      if (_skip()) {\r\n        continue;\r\n      }\r\n      this.updateRangeFromParsed(range, scale, parsed, stack);\r\n      if (sorted) {\r\n        // if the data is sorted, we don't need to check further from this end of array\r\n        break;\r\n      }\r\n    }\r\n    if (sorted) {\r\n      // in the sorted case, find first non-skipped value from other end of array\r\n      for (i = ilen - 1; i >= 0; --i) {\r\n        if (_skip()) {\r\n          continue;\r\n        }\r\n        this.updateRangeFromParsed(range, scale, parsed, stack);\r\n        break;\r\n      }\r\n    }\r\n    return range;\r\n  }\r\n\r\n  getAllParsedValues(scale) {\r\n    const parsed = this._cachedMeta._parsed;\r\n    const values = [];\r\n    let i, ilen, value;\r\n\r\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\r\n      value = parsed[i][scale.axis];\r\n      if (isFinite(value)) {\r\n        values.push(value);\r\n      }\r\n    }\r\n    return values;\r\n  }\r\n\r\n  /**\r\n\t * @return {number|boolean}\r\n\t * @protected\r\n\t */\r\n  getMaxOverflow() {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const iScale = meta.iScale;\r\n    const vScale = meta.vScale;\r\n    const parsed = this.getParsed(index);\r\n    return {\r\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\r\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _update(mode) {\r\n    const meta = this._cachedMeta;\r\n    this.update(mode || 'default');\r\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\r\n  }\r\n\r\n  /**\r\n\t * @param {string} mode\r\n\t */\r\n  update(mode) {} // eslint-disable-line no-unused-vars\r\n\r\n  draw() {\r\n    const ctx = this._ctx;\r\n    const chart = this.chart;\r\n    const meta = this._cachedMeta;\r\n    const elements = meta.data || [];\r\n    const area = chart.chartArea;\r\n    const active = [];\r\n    const start = this._drawStart || 0;\r\n    const count = this._drawCount || (elements.length - start);\r\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\r\n    let i;\r\n\r\n    if (meta.dataset) {\r\n      meta.dataset.draw(ctx, area, start, count);\r\n    }\r\n\r\n    for (i = start; i < start + count; ++i) {\r\n      const element = elements[i];\r\n      if (element.hidden) {\r\n        continue;\r\n      }\r\n      if (element.active && drawActiveElementsOnTop) {\r\n        active.push(element);\r\n      } else {\r\n        element.draw(ctx, area);\r\n      }\r\n    }\r\n\r\n    for (i = 0; i < active.length; ++i) {\r\n      active[i].draw(ctx, area);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Returns a set of predefined style properties that should be used to represent the dataset\r\n\t * or the data if the index is specified\r\n\t * @param {number} index - data index\r\n\t * @param {boolean} [active] - true if hover\r\n\t * @return {object} style object\r\n\t */\r\n  getStyle(index, active) {\r\n    const mode = active ? 'active' : 'default';\r\n    return index === undefined && this._cachedMeta.dataset\r\n      ? this.resolveDatasetElementOptions(mode)\r\n      : this.resolveDataElementOptions(index || 0, mode);\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getContext(index, active, mode) {\r\n    const dataset = this.getDataset();\r\n    let context;\r\n    if (index >= 0 && index < this._cachedMeta.data.length) {\r\n      const element = this._cachedMeta.data[index];\r\n      context = element.$context ||\r\n        (element.$context = createDataContext(this.getContext(), index, element));\r\n      context.parsed = this.getParsed(index);\r\n      context.raw = dataset.data[index];\r\n      context.index = context.dataIndex = index;\r\n    } else {\r\n      context = this.$context ||\r\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\r\n      context.dataset = dataset;\r\n      context.index = context.datasetIndex = this.index;\r\n    }\r\n\r\n    context.active = !!active;\r\n    context.mode = mode;\r\n    return context;\r\n  }\r\n\r\n  /**\r\n\t * @param {string} [mode]\r\n\t * @protected\r\n\t */\r\n  resolveDatasetElementOptions(mode) {\r\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\r\n  }\r\n\r\n  /**\r\n\t * @param {number} index\r\n\t * @param {string} [mode]\r\n\t * @protected\r\n\t */\r\n  resolveDataElementOptions(index, mode) {\r\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _resolveElementOptions(elementType, mode = 'default', index) {\r\n    const active = mode === 'active';\r\n    const cache = this._cachedDataOpts;\r\n    const cacheKey = elementType + '-' + mode;\r\n    const cached = cache[cacheKey];\r\n    const sharing = this.enableOptionSharing && defined(index);\r\n    if (cached) {\r\n      return cloneIfNotShared(cached, sharing);\r\n    }\r\n    const config = this.chart.config;\r\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\r\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\r\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\r\n    const names = Object.keys(defaults.elements[elementType]);\r\n    // context is provided as a function, and is called only if needed,\r\n    // so we don't create a context for each element if not needed.\r\n    const context = () => this.getContext(index, active, mode);\r\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\r\n\r\n    if (values.$shared) {\r\n      // `$shared` indicates this set of options can be shared between multiple elements.\r\n      // Sharing is used to reduce number of properties to change during animation.\r\n      values.$shared = sharing;\r\n\r\n      // We cache options by `mode`, which can be 'active' for example. This enables us\r\n      // to have the 'active' element options and 'default' options to switch between\r\n      // when interacting.\r\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\r\n    }\r\n\r\n    return values;\r\n  }\r\n\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _resolveAnimations(index, transition, active) {\r\n    const chart = this.chart;\r\n    const cache = this._cachedDataOpts;\r\n    const cacheKey = `animation-${transition}`;\r\n    const cached = cache[cacheKey];\r\n    if (cached) {\r\n      return cached;\r\n    }\r\n    let options;\r\n    if (chart.options.animation !== false) {\r\n      const config = this.chart.config;\r\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\r\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\r\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\r\n    }\r\n    const animations = new Animations(chart, options && options.animations);\r\n    if (options && options._cacheable) {\r\n      cache[cacheKey] = Object.freeze(animations);\r\n    }\r\n    return animations;\r\n  }\r\n\r\n  /**\r\n\t * Utility for getting the options object shared between elements\r\n\t * @protected\r\n\t */\r\n  getSharedOptions(options) {\r\n    if (!options.$shared) {\r\n      return;\r\n    }\r\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\r\n  }\r\n\r\n  /**\r\n\t * Utility for determining if `options` should be included in the updated properties\r\n\t * @protected\r\n\t */\r\n  includeOptions(mode, sharedOptions) {\r\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\r\n  }\r\n\r\n  /**\r\n   * @todo v4, rename to getSharedOptions and remove excess functions\r\n   */\r\n  _getSharedOptions(start, mode) {\r\n    const firstOpts = this.resolveDataElementOptions(start, mode);\r\n    const previouslySharedOptions = this._sharedOptions;\r\n    const sharedOptions = this.getSharedOptions(firstOpts);\r\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\r\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n    return {sharedOptions, includeOptions};\r\n  }\r\n\r\n  /**\r\n\t * Utility for updating an element with new properties, using animations when appropriate.\r\n\t * @protected\r\n\t */\r\n  updateElement(element, index, properties, mode) {\r\n    if (isDirectUpdateMode(mode)) {\r\n      Object.assign(element, properties);\r\n    } else {\r\n      this._resolveAnimations(index, mode).update(element, properties);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Utility to animate the shared options, that are potentially affecting multiple elements.\r\n\t * @protected\r\n\t */\r\n  updateSharedOptions(sharedOptions, mode, newOptions) {\r\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\r\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _setStyle(element, index, mode, active) {\r\n    element.active = active;\r\n    const options = this.getStyle(index, active);\r\n    this._resolveAnimations(index, mode, active).update(element, {\r\n      // When going from active to inactive, we need to update to the shared options.\r\n      // This way the once hovered element will end up with the same original shared options instance, after animation.\r\n      options: (!active && this.getSharedOptions(options)) || options\r\n    });\r\n  }\r\n\r\n  removeHoverStyle(element, datasetIndex, index) {\r\n    this._setStyle(element, index, 'active', false);\r\n  }\r\n\r\n  setHoverStyle(element, datasetIndex, index) {\r\n    this._setStyle(element, index, 'active', true);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _removeDatasetHoverStyle() {\r\n    const element = this._cachedMeta.dataset;\r\n\r\n    if (element) {\r\n      this._setStyle(element, undefined, 'active', false);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _setDatasetHoverStyle() {\r\n    const element = this._cachedMeta.dataset;\r\n\r\n    if (element) {\r\n      this._setStyle(element, undefined, 'active', true);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _resyncElements(resetNewElements) {\r\n    const data = this._data;\r\n    const elements = this._cachedMeta.data;\r\n\r\n    // Apply changes detected through array listeners\r\n    for (const [method, arg1, arg2] of this._syncList) {\r\n      this[method](arg1, arg2);\r\n    }\r\n    this._syncList = [];\r\n\r\n    const numMeta = elements.length;\r\n    const numData = data.length;\r\n    const count = Math.min(numData, numMeta);\r\n\r\n    if (count) {\r\n      // TODO: It is not optimal to always parse the old data\r\n      // This is done because we are not detecting direct assignments:\r\n      // chart.data.datasets[0].data[5] = 10;\r\n      // chart.data.datasets[0].data[5].y = 10;\r\n      this.parse(0, count);\r\n    }\r\n\r\n    if (numData > numMeta) {\r\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\r\n    } else if (numData < numMeta) {\r\n      this._removeElements(numData, numMeta - numData);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _insertElements(start, count, resetNewElements = true) {\r\n    const meta = this._cachedMeta;\r\n    const data = meta.data;\r\n    const end = start + count;\r\n    let i;\r\n\r\n    const move = (arr) => {\r\n      arr.length += count;\r\n      for (i = arr.length - 1; i >= end; i--) {\r\n        arr[i] = arr[i - count];\r\n      }\r\n    };\r\n    move(data);\r\n\r\n    for (i = start; i < end; ++i) {\r\n      data[i] = new this.dataElementType();\r\n    }\r\n\r\n    if (this._parsing) {\r\n      move(meta._parsed);\r\n    }\r\n    this.parse(start, count);\r\n\r\n    if (resetNewElements) {\r\n      this.updateElements(data, start, count, 'reset');\r\n    }\r\n  }\r\n\r\n  updateElements(element, start, count, mode) {} // eslint-disable-line no-unused-vars\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _removeElements(start, count) {\r\n    const meta = this._cachedMeta;\r\n    if (this._parsing) {\r\n      const removed = meta._parsed.splice(start, count);\r\n      if (meta._stacked) {\r\n        clearStacks(meta, removed);\r\n      }\r\n    }\r\n    meta.data.splice(start, count);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n   */\r\n  _sync(args) {\r\n    if (this._parsing) {\r\n      this._syncList.push(args);\r\n    } else {\r\n      const [method, arg1, arg2] = args;\r\n      this[method](arg1, arg2);\r\n    }\r\n    this.chart._dataChanges.push([this.index, ...args]);\r\n  }\r\n\r\n  _onDataPush() {\r\n    const count = arguments.length;\r\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\r\n  }\r\n\r\n  _onDataPop() {\r\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\r\n  }\r\n\r\n  _onDataShift() {\r\n    this._sync(['_removeElements', 0, 1]);\r\n  }\r\n\r\n  _onDataSplice(start, count) {\r\n    if (count) {\r\n      this._sync(['_removeElements', start, count]);\r\n    }\r\n    const newCount = arguments.length - 2;\r\n    if (newCount) {\r\n      this._sync(['_insertElements', start, newCount]);\r\n    }\r\n  }\r\n\r\n  _onDataUnshift() {\r\n    this._sync(['_insertElements', 0, arguments.length]);\r\n  }\r\n}\r\n","import type {AnyObject} from '../types/basic.js';\r\nimport type {Point} from '../types/geometric.js';\r\nimport type {Animation} from '../types/animation.js';\r\nimport {isNumber} from '../helpers/helpers.math.js';\r\n\r\nexport default class Element<T = AnyObject, O = AnyObject> {\r\n\r\n  static defaults = {};\r\n  static defaultRoutes = undefined;\r\n\r\n  x: number;\r\n  y: number;\r\n  active = false;\r\n  options: O;\r\n  $animations: Record<keyof T, Animation>;\r\n\r\n  tooltipPosition(useFinalPosition: boolean): Point {\r\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\r\n    return {x, y} as Point;\r\n  }\r\n\r\n  hasValue() {\r\n    return isNumber(this.x) && isNumber(this.y);\r\n  }\r\n\r\n  /**\r\n   * Gets the current or final value of each prop. Can return extra properties (whole object).\r\n   * @param props - properties to get\r\n   * @param [final] - get the final value (animation target)\r\n   */\r\n  getProps<P extends (keyof T)[]>(props: P, final?: boolean): Pick<T, P[number]>;\r\n  getProps<P extends string>(props: P[], final?: boolean): Partial<Record<P, unknown>>;\r\n  getProps(props: string[], final?: boolean): Partial<Record<string, unknown>> {\r\n    const anims = this.$animations;\r\n    if (!final || !anims) {\r\n      // let's not create an object, if not needed\r\n      return this as Record<string, unknown>;\r\n    }\r\n    const ret: Record<string, unknown> = {};\r\n    props.forEach((prop) => {\r\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop as string];\r\n    });\r\n    return ret;\r\n  }\r\n}\r\n","import {isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\r\nimport {_factorize} from '../helpers/helpers.math.js';\r\n\r\n\r\n/**\r\n * @typedef { import('./core.controller.js').default } Chart\r\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\r\n */\r\n\r\n/**\r\n * Returns a subset of ticks to be plotted to avoid overlapping labels.\r\n * @param {import('./core.scale.js').default} scale\r\n * @param {Tick[]} ticks\r\n * @return {Tick[]}\r\n * @private\r\n */\r\nexport function autoSkip(scale, ticks) {\r\n  const tickOpts = scale.options.ticks;\r\n  const determinedMaxTicks = determineMaxTicks(scale);\r\n  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\r\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\r\n  const numMajorIndices = majorIndices.length;\r\n  const first = majorIndices[0];\r\n  const last = majorIndices[numMajorIndices - 1];\r\n  const newTicks = [];\r\n\r\n  // If there are too many major ticks to display them all\r\n  if (numMajorIndices > ticksLimit) {\r\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\r\n    return newTicks;\r\n  }\r\n\r\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\r\n\r\n  if (numMajorIndices > 0) {\r\n    let i, ilen;\r\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\r\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\r\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\r\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\r\n    }\r\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\r\n    return newTicks;\r\n  }\r\n  skip(ticks, newTicks, spacing);\r\n  return newTicks;\r\n}\r\n\r\nfunction determineMaxTicks(scale) {\r\n  const offset = scale.options.offset;\r\n  const tickLength = scale._tickSize();\r\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\r\n  const maxChart = scale._maxLength / tickLength;\r\n  return Math.floor(Math.min(maxScale, maxChart));\r\n}\r\n\r\n/**\r\n * @param {number[]} majorIndices\r\n * @param {Tick[]} ticks\r\n * @param {number} ticksLimit\r\n */\r\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\r\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\r\n  const spacing = ticks.length / ticksLimit;\r\n\r\n  // If the major ticks are evenly spaced apart, place the minor ticks\r\n  // so that they divide the major ticks into even chunks\r\n  if (!evenMajorSpacing) {\r\n    return Math.max(spacing, 1);\r\n  }\r\n\r\n  const factors = _factorize(evenMajorSpacing);\r\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\r\n    const factor = factors[i];\r\n    if (factor > spacing) {\r\n      return factor;\r\n    }\r\n  }\r\n  return Math.max(spacing, 1);\r\n}\r\n\r\n/**\r\n * @param {Tick[]} ticks\r\n */\r\nfunction getMajorIndices(ticks) {\r\n  const result = [];\r\n  let i, ilen;\r\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n    if (ticks[i].major) {\r\n      result.push(i);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * @param {Tick[]} ticks\r\n * @param {Tick[]} newTicks\r\n * @param {number[]} majorIndices\r\n * @param {number} spacing\r\n */\r\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\r\n  let count = 0;\r\n  let next = majorIndices[0];\r\n  let i;\r\n\r\n  spacing = Math.ceil(spacing);\r\n  for (i = 0; i < ticks.length; i++) {\r\n    if (i === next) {\r\n      newTicks.push(ticks[i]);\r\n      count++;\r\n      next = majorIndices[count * spacing];\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Tick[]} ticks\r\n * @param {Tick[]} newTicks\r\n * @param {number} spacing\r\n * @param {number} [majorStart]\r\n * @param {number} [majorEnd]\r\n */\r\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\r\n  const start = valueOrDefault(majorStart, 0);\r\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\r\n  let count = 0;\r\n  let length, i, next;\r\n\r\n  spacing = Math.ceil(spacing);\r\n  if (majorEnd) {\r\n    length = majorEnd - majorStart;\r\n    spacing = length / Math.floor(length / spacing);\r\n  }\r\n\r\n  next = start;\r\n\r\n  while (next < 0) {\r\n    count++;\r\n    next = Math.round(start + count * spacing);\r\n  }\r\n\r\n  for (i = Math.max(start, 0); i < end; i++) {\r\n    if (i === next) {\r\n      newTicks.push(ticks[i]);\r\n      count++;\r\n      next = Math.round(start + count * spacing);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @param {number[]} arr\r\n */\r\nfunction getEvenSpacing(arr) {\r\n  const len = arr.length;\r\n  let i, diff;\r\n\r\n  if (len < 2) {\r\n    return false;\r\n  }\r\n\r\n  for (diff = arr[0], i = 1; i < len; ++i) {\r\n    if (arr[i] - arr[i - 1] !== diff) {\r\n      return false;\r\n    }\r\n  }\r\n  return diff;\r\n}\r\n","import Element from './core.element.js';\r\nimport {_alignPixel, _measureText, renderText, clipArea, unclipArea} from '../helpers/helpers.canvas.js';\r\nimport {callback as call, each, finiteOrDefault, isArray, isFinite, isNullOrUndef, isObject, valueOrDefault} from '../helpers/helpers.core.js';\r\nimport {toDegrees, toRadians, _int16Range, _limitValue, HALF_PI} from '../helpers/helpers.math.js';\r\nimport {_alignStartEnd, _toLeftRightCenter} from '../helpers/helpers.extras.js';\r\nimport {createContext, toFont, toPadding, _addGrace} from '../helpers/helpers.options.js';\r\nimport {autoSkip} from './core.scale.autoskip.js';\r\n\r\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\r\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\r\nconst getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);\r\n\r\n/**\r\n * @typedef { import('../types/index.js').Chart } Chart\r\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\r\n */\r\n\r\n/**\r\n * Returns a new array containing numItems from arr\r\n * @param {any[]} arr\r\n * @param {number} numItems\r\n */\r\nfunction sample(arr, numItems) {\r\n  const result = [];\r\n  const increment = arr.length / numItems;\r\n  const len = arr.length;\r\n  let i = 0;\r\n\r\n  for (; i < len; i += increment) {\r\n    result.push(arr[Math.floor(i)]);\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * @param {Scale} scale\r\n * @param {number} index\r\n * @param {boolean} offsetGridLines\r\n */\r\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\r\n  const length = scale.ticks.length;\r\n  const validIndex = Math.min(index, length - 1);\r\n  const start = scale._startPixel;\r\n  const end = scale._endPixel;\r\n  const epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\r\n  let lineValue = scale.getPixelForTick(validIndex);\r\n  let offset;\r\n\r\n  if (offsetGridLines) {\r\n    if (length === 1) {\r\n      offset = Math.max(lineValue - start, end - lineValue);\r\n    } else if (index === 0) {\r\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\r\n    } else {\r\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\r\n    }\r\n    lineValue += validIndex < index ? offset : -offset;\r\n\r\n    // Return undefined if the pixel is out of the range\r\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\r\n      return;\r\n    }\r\n  }\r\n  return lineValue;\r\n}\r\n\r\n/**\r\n * @param {object} caches\r\n * @param {number} length\r\n */\r\nfunction garbageCollect(caches, length) {\r\n  each(caches, (cache) => {\r\n    const gc = cache.gc;\r\n    const gcLen = gc.length / 2;\r\n    let i;\r\n    if (gcLen > length) {\r\n      for (i = 0; i < gcLen; ++i) {\r\n        delete cache.data[gc[i]];\r\n      }\r\n      gc.splice(0, gcLen);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * @param {object} options\r\n */\r\nfunction getTickMarkLength(options) {\r\n  return options.drawTicks ? options.tickLength : 0;\r\n}\r\n\r\n/**\r\n * @param {object} options\r\n */\r\nfunction getTitleHeight(options, fallback) {\r\n  if (!options.display) {\r\n    return 0;\r\n  }\r\n\r\n  const font = toFont(options.font, fallback);\r\n  const padding = toPadding(options.padding);\r\n  const lines = isArray(options.text) ? options.text.length : 1;\r\n\r\n  return (lines * font.lineHeight) + padding.height;\r\n}\r\n\r\nfunction createScaleContext(parent, scale) {\r\n  return createContext(parent, {\r\n    scale,\r\n    type: 'scale'\r\n  });\r\n}\r\n\r\nfunction createTickContext(parent, index, tick) {\r\n  return createContext(parent, {\r\n    tick,\r\n    index,\r\n    type: 'tick'\r\n  });\r\n}\r\n\r\nfunction titleAlign(align, position, reverse) {\r\n  /** @type {CanvasTextAlign} */\r\n  let ret = _toLeftRightCenter(align);\r\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\r\n    ret = reverseAlign(ret);\r\n  }\r\n  return ret;\r\n}\r\n\r\nfunction titleArgs(scale, offset, position, align) {\r\n  const {top, left, bottom, right, chart} = scale;\r\n  const {chartArea, scales} = chart;\r\n  let rotation = 0;\r\n  let maxWidth, titleX, titleY;\r\n  const height = bottom - top;\r\n  const width = right - left;\r\n\r\n  if (scale.isHorizontal()) {\r\n    titleX = _alignStartEnd(align, left, right);\r\n\r\n    if (isObject(position)) {\r\n      const positionAxisID = Object.keys(position)[0];\r\n      const value = position[positionAxisID];\r\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\r\n    } else if (position === 'center') {\r\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\r\n    } else {\r\n      titleY = offsetFromEdge(scale, position, offset);\r\n    }\r\n    maxWidth = right - left;\r\n  } else {\r\n    if (isObject(position)) {\r\n      const positionAxisID = Object.keys(position)[0];\r\n      const value = position[positionAxisID];\r\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\r\n    } else if (position === 'center') {\r\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\r\n    } else {\r\n      titleX = offsetFromEdge(scale, position, offset);\r\n    }\r\n    titleY = _alignStartEnd(align, bottom, top);\r\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\r\n  }\r\n  return {titleX, titleY, maxWidth, rotation};\r\n}\r\n\r\nexport default class Scale extends Element {\r\n\r\n  // eslint-disable-next-line max-statements\r\n  constructor(cfg) {\r\n    super();\r\n\r\n    /** @type {string} */\r\n    this.id = cfg.id;\r\n    /** @type {string} */\r\n    this.type = cfg.type;\r\n    /** @type {any} */\r\n    this.options = undefined;\r\n    /** @type {CanvasRenderingContext2D} */\r\n    this.ctx = cfg.ctx;\r\n    /** @type {Chart} */\r\n    this.chart = cfg.chart;\r\n\r\n    // implements box\r\n    /** @type {number} */\r\n    this.top = undefined;\r\n    /** @type {number} */\r\n    this.bottom = undefined;\r\n    /** @type {number} */\r\n    this.left = undefined;\r\n    /** @type {number} */\r\n    this.right = undefined;\r\n    /** @type {number} */\r\n    this.width = undefined;\r\n    /** @type {number} */\r\n    this.height = undefined;\r\n    this._margins = {\r\n      left: 0,\r\n      right: 0,\r\n      top: 0,\r\n      bottom: 0\r\n    };\r\n    /** @type {number} */\r\n    this.maxWidth = undefined;\r\n    /** @type {number} */\r\n    this.maxHeight = undefined;\r\n    /** @type {number} */\r\n    this.paddingTop = undefined;\r\n    /** @type {number} */\r\n    this.paddingBottom = undefined;\r\n    /** @type {number} */\r\n    this.paddingLeft = undefined;\r\n    /** @type {number} */\r\n    this.paddingRight = undefined;\r\n\r\n    // scale-specific properties\r\n    /** @type {string=} */\r\n    this.axis = undefined;\r\n    /** @type {number=} */\r\n    this.labelRotation = undefined;\r\n    this.min = undefined;\r\n    this.max = undefined;\r\n    this._range = undefined;\r\n    /** @type {Tick[]} */\r\n    this.ticks = [];\r\n    /** @type {object[]|null} */\r\n    this._gridLineItems = null;\r\n    /** @type {object[]|null} */\r\n    this._labelItems = null;\r\n    /** @type {object|null} */\r\n    this._labelSizes = null;\r\n    this._length = 0;\r\n    this._maxLength = 0;\r\n    this._longestTextCache = {};\r\n    /** @type {number} */\r\n    this._startPixel = undefined;\r\n    /** @type {number} */\r\n    this._endPixel = undefined;\r\n    this._reversePixels = false;\r\n    this._userMax = undefined;\r\n    this._userMin = undefined;\r\n    this._suggestedMax = undefined;\r\n    this._suggestedMin = undefined;\r\n    this._ticksLength = 0;\r\n    this._borderValue = 0;\r\n    this._cache = {};\r\n    this._dataLimitsCached = false;\r\n    this.$context = undefined;\r\n  }\r\n\r\n  /**\r\n\t * @param {any} options\r\n\t * @since 3.0\r\n\t */\r\n  init(options) {\r\n    this.options = options.setContext(this.getContext());\r\n\r\n    this.axis = options.axis;\r\n\r\n    // parse min/max value, so we can properly determine min/max for other scales\r\n    this._userMin = this.parse(options.min);\r\n    this._userMax = this.parse(options.max);\r\n    this._suggestedMin = this.parse(options.suggestedMin);\r\n    this._suggestedMax = this.parse(options.suggestedMax);\r\n  }\r\n\r\n  /**\r\n\t * Parse a supported input value to internal representation.\r\n\t * @param {*} raw\r\n\t * @param {number} [index]\r\n\t * @since 3.0\r\n\t */\r\n  parse(raw, index) { // eslint-disable-line no-unused-vars\r\n    return raw;\r\n  }\r\n\r\n  /**\r\n\t * @return {{min: number, max: number, minDefined: boolean, maxDefined: boolean}}\r\n\t * @protected\r\n\t * @since 3.0\r\n\t */\r\n  getUserBounds() {\r\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\r\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\r\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\r\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\r\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\r\n    return {\r\n      min: finiteOrDefault(_userMin, _suggestedMin),\r\n      max: finiteOrDefault(_userMax, _suggestedMax),\r\n      minDefined: isFinite(_userMin),\r\n      maxDefined: isFinite(_userMax)\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * @param {boolean} canStack\r\n\t * @return {{min: number, max: number}}\r\n\t * @protected\r\n\t * @since 3.0\r\n\t */\r\n  getMinMax(canStack) {\r\n    // eslint-disable-next-line prefer-const\r\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\r\n    let range;\r\n\r\n    if (minDefined && maxDefined) {\r\n      return {min, max};\r\n    }\r\n\r\n    const metas = this.getMatchingVisibleMetas();\r\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\r\n      range = metas[i].controller.getMinMax(this, canStack);\r\n      if (!minDefined) {\r\n        min = Math.min(min, range.min);\r\n      }\r\n      if (!maxDefined) {\r\n        max = Math.max(max, range.max);\r\n      }\r\n    }\r\n\r\n    // Make sure min <= max when only min or max is defined by user and the data is outside that range\r\n    min = maxDefined && min > max ? max : min;\r\n    max = minDefined && min > max ? min : max;\r\n\r\n    return {\r\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\r\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * Get the padding needed for the scale\r\n\t * @return {{top: number, left: number, bottom: number, right: number}} the necessary padding\r\n\t * @private\r\n\t */\r\n  getPadding() {\r\n    return {\r\n      left: this.paddingLeft || 0,\r\n      top: this.paddingTop || 0,\r\n      right: this.paddingRight || 0,\r\n      bottom: this.paddingBottom || 0\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * Returns the scale tick objects\r\n\t * @return {Tick[]}\r\n\t * @since 2.7\r\n\t */\r\n  getTicks() {\r\n    return this.ticks;\r\n  }\r\n\r\n  /**\r\n\t * @return {string[]}\r\n\t */\r\n  getLabels() {\r\n    const data = this.chart.data;\r\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\r\n  }\r\n\r\n  /**\r\n   * @return {import('../types.js').LabelItem[]}\r\n   */\r\n  getLabelItems(chartArea = this.chart.chartArea) {\r\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\r\n    return items;\r\n  }\r\n\r\n  // When a new layout is created, reset the data limits cache\r\n  beforeLayout() {\r\n    this._cache = {};\r\n    this._dataLimitsCached = false;\r\n  }\r\n\r\n  // These methods are ordered by lifecycle. Utilities then follow.\r\n  // Any function defined here is inherited by all scale types.\r\n  // Any function can be extended by the scale type\r\n\r\n  beforeUpdate() {\r\n    call(this.options.beforeUpdate, [this]);\r\n  }\r\n\r\n  /**\r\n\t * @param {number} maxWidth - the max width in pixels\r\n\t * @param {number} maxHeight - the max height in pixels\r\n\t * @param {{top: number, left: number, bottom: number, right: number}} margins - the space between the edge of the other scales and edge of the chart\r\n\t *   This space comes from two sources:\r\n\t *     - padding - space that's required to show the labels at the edges of the scale\r\n\t *     - thickness of scales or legends in another orientation\r\n\t */\r\n  update(maxWidth, maxHeight, margins) {\r\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\r\n    const sampleSize = tickOpts.sampleSize;\r\n\r\n    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\r\n    this.beforeUpdate();\r\n\r\n    // Absorb the master measurements\r\n    this.maxWidth = maxWidth;\r\n    this.maxHeight = maxHeight;\r\n    this._margins = margins = Object.assign({\r\n      left: 0,\r\n      right: 0,\r\n      top: 0,\r\n      bottom: 0\r\n    }, margins);\r\n\r\n    this.ticks = null;\r\n    this._labelSizes = null;\r\n    this._gridLineItems = null;\r\n    this._labelItems = null;\r\n\r\n    // Dimensions\r\n    this.beforeSetDimensions();\r\n    this.setDimensions();\r\n    this.afterSetDimensions();\r\n\r\n    this._maxLength = this.isHorizontal()\r\n      ? this.width + margins.left + margins.right\r\n      : this.height + margins.top + margins.bottom;\r\n\r\n    // Data min/max\r\n    if (!this._dataLimitsCached) {\r\n      this.beforeDataLimits();\r\n      this.determineDataLimits();\r\n      this.afterDataLimits();\r\n      this._range = _addGrace(this, grace, beginAtZero);\r\n      this._dataLimitsCached = true;\r\n    }\r\n\r\n    this.beforeBuildTicks();\r\n\r\n    this.ticks = this.buildTicks() || [];\r\n\r\n    // Allow modification of ticks in callback.\r\n    this.afterBuildTicks();\r\n\r\n    // Compute tick rotation and fit using a sampled subset of labels\r\n    // We generally don't need to compute the size of every single label for determining scale size\r\n    const samplingEnabled = sampleSize < this.ticks.length;\r\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\r\n\r\n    // configure is called twice, once here, once from core.controller.updateLayout.\r\n    // Here we haven't been positioned yet, but dimensions are correct.\r\n    // Variables set in configure are needed for calculateLabelRotation, and\r\n    // it's ok that coordinates are not correct there, only dimensions matter.\r\n    this.configure();\r\n\r\n    // Tick Rotation\r\n    this.beforeCalculateLabelRotation();\r\n    this.calculateLabelRotation(); // Preconditions: number of ticks and sizes of largest labels must be calculated beforehand\r\n    this.afterCalculateLabelRotation();\r\n\r\n    // Auto-skip\r\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\r\n      this.ticks = autoSkip(this, this.ticks);\r\n      this._labelSizes = null;\r\n      this.afterAutoSkip();\r\n    }\r\n\r\n    if (samplingEnabled) {\r\n      // Generate labels using all non-skipped ticks\r\n      this._convertTicksToLabels(this.ticks);\r\n    }\r\n\r\n    this.beforeFit();\r\n    this.fit(); // Preconditions: label rotation and label sizes must be calculated beforehand\r\n    this.afterFit();\r\n\r\n    // IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!\r\n\r\n    this.afterUpdate();\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  configure() {\r\n    let reversePixels = this.options.reverse;\r\n    let startPixel, endPixel;\r\n\r\n    if (this.isHorizontal()) {\r\n      startPixel = this.left;\r\n      endPixel = this.right;\r\n    } else {\r\n      startPixel = this.top;\r\n      endPixel = this.bottom;\r\n      // by default vertical scales are from bottom to top, so pixels are reversed\r\n      reversePixels = !reversePixels;\r\n    }\r\n    this._startPixel = startPixel;\r\n    this._endPixel = endPixel;\r\n    this._reversePixels = reversePixels;\r\n    this._length = endPixel - startPixel;\r\n    this._alignToPixels = this.options.alignToPixels;\r\n  }\r\n\r\n  afterUpdate() {\r\n    call(this.options.afterUpdate, [this]);\r\n  }\r\n\r\n  //\r\n\r\n  beforeSetDimensions() {\r\n    call(this.options.beforeSetDimensions, [this]);\r\n  }\r\n  setDimensions() {\r\n    // Set the unconstrained dimension before label rotation\r\n    if (this.isHorizontal()) {\r\n      // Reset position before calculating rotation\r\n      this.width = this.maxWidth;\r\n      this.left = 0;\r\n      this.right = this.width;\r\n    } else {\r\n      this.height = this.maxHeight;\r\n\r\n      // Reset position before calculating rotation\r\n      this.top = 0;\r\n      this.bottom = this.height;\r\n    }\r\n\r\n    // Reset padding\r\n    this.paddingLeft = 0;\r\n    this.paddingTop = 0;\r\n    this.paddingRight = 0;\r\n    this.paddingBottom = 0;\r\n  }\r\n  afterSetDimensions() {\r\n    call(this.options.afterSetDimensions, [this]);\r\n  }\r\n\r\n  _callHooks(name) {\r\n    this.chart.notifyPlugins(name, this.getContext());\r\n    call(this.options[name], [this]);\r\n  }\r\n\r\n  // Data limits\r\n  beforeDataLimits() {\r\n    this._callHooks('beforeDataLimits');\r\n  }\r\n  determineDataLimits() {}\r\n  afterDataLimits() {\r\n    this._callHooks('afterDataLimits');\r\n  }\r\n\r\n  //\r\n  beforeBuildTicks() {\r\n    this._callHooks('beforeBuildTicks');\r\n  }\r\n  /**\r\n\t * @return {object[]} the ticks\r\n\t */\r\n  buildTicks() {\r\n    return [];\r\n  }\r\n  afterBuildTicks() {\r\n    this._callHooks('afterBuildTicks');\r\n  }\r\n\r\n  beforeTickToLabelConversion() {\r\n    call(this.options.beforeTickToLabelConversion, [this]);\r\n  }\r\n  /**\r\n\t * Convert ticks to label strings\r\n\t * @param {Tick[]} ticks\r\n\t */\r\n  generateTickLabels(ticks) {\r\n    const tickOpts = this.options.ticks;\r\n    let i, ilen, tick;\r\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n      tick = ticks[i];\r\n      tick.label = call(tickOpts.callback, [tick.value, i, ticks], this);\r\n    }\r\n  }\r\n  afterTickToLabelConversion() {\r\n    call(this.options.afterTickToLabelConversion, [this]);\r\n  }\r\n\r\n  //\r\n\r\n  beforeCalculateLabelRotation() {\r\n    call(this.options.beforeCalculateLabelRotation, [this]);\r\n  }\r\n  calculateLabelRotation() {\r\n    const options = this.options;\r\n    const tickOpts = options.ticks;\r\n    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\r\n    const minRotation = tickOpts.minRotation || 0;\r\n    const maxRotation = tickOpts.maxRotation;\r\n    let labelRotation = minRotation;\r\n    let tickWidth, maxHeight, maxLabelDiagonal;\r\n\r\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\r\n      this.labelRotation = minRotation;\r\n      return;\r\n    }\r\n\r\n    const labelSizes = this._getLabelSizes();\r\n    const maxLabelWidth = labelSizes.widest.width;\r\n    const maxLabelHeight = labelSizes.highest.height;\r\n\r\n    // Estimate the width of each grid based on the canvas width, the maximum\r\n    // label width and the number of tick intervals\r\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\r\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\r\n\r\n    // Allow 3 pixels x2 padding either side for label readability\r\n    if (maxLabelWidth + 6 > tickWidth) {\r\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\r\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\r\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\r\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\r\n      labelRotation = toDegrees(Math.min(\r\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\r\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\r\n      ));\r\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\r\n    }\r\n\r\n    this.labelRotation = labelRotation;\r\n  }\r\n  afterCalculateLabelRotation() {\r\n    call(this.options.afterCalculateLabelRotation, [this]);\r\n  }\r\n  afterAutoSkip() {}\r\n\r\n  //\r\n\r\n  beforeFit() {\r\n    call(this.options.beforeFit, [this]);\r\n  }\r\n  fit() {\r\n    // Reset\r\n    const minSize = {\r\n      width: 0,\r\n      height: 0\r\n    };\r\n\r\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\r\n    const display = this._isVisible();\r\n    const isHorizontal = this.isHorizontal();\r\n\r\n    if (display) {\r\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\r\n      if (isHorizontal) {\r\n        minSize.width = this.maxWidth;\r\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\r\n      } else {\r\n        minSize.height = this.maxHeight; // fill all the height\r\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\r\n      }\r\n\r\n      // Don't bother fitting the ticks if we are not showing the labels\r\n      if (tickOpts.display && this.ticks.length) {\r\n        const {first, last, widest, highest} = this._getLabelSizes();\r\n        const tickPadding = tickOpts.padding * 2;\r\n        const angleRadians = toRadians(this.labelRotation);\r\n        const cos = Math.cos(angleRadians);\r\n        const sin = Math.sin(angleRadians);\r\n\r\n        if (isHorizontal) {\r\n        // A horizontal axis is more constrained by the height.\r\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\r\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\r\n        } else {\r\n        // A vertical axis is more constrained by the width. Labels are the\r\n        // dominant factor here, so get that length first and account for padding\r\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\r\n\r\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\r\n        }\r\n        this._calculatePadding(first, last, sin, cos);\r\n      }\r\n    }\r\n\r\n    this._handleMargins();\r\n\r\n    if (isHorizontal) {\r\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\r\n      this.height = minSize.height;\r\n    } else {\r\n      this.width = minSize.width;\r\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\r\n    }\r\n  }\r\n\r\n  _calculatePadding(first, last, sin, cos) {\r\n    const {ticks: {align, padding}, position} = this.options;\r\n    const isRotated = this.labelRotation !== 0;\r\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\r\n\r\n    if (this.isHorizontal()) {\r\n      const offsetLeft = this.getPixelForTick(0) - this.left;\r\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\r\n      let paddingLeft = 0;\r\n      let paddingRight = 0;\r\n\r\n      // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\r\n      // which means that the right padding is dominated by the font height\r\n      if (isRotated) {\r\n        if (labelsBelowTicks) {\r\n          paddingLeft = cos * first.width;\r\n          paddingRight = sin * last.height;\r\n        } else {\r\n          paddingLeft = sin * first.height;\r\n          paddingRight = cos * last.width;\r\n        }\r\n      } else if (align === 'start') {\r\n        paddingRight = last.width;\r\n      } else if (align === 'end') {\r\n        paddingLeft = first.width;\r\n      } else if (align !== 'inner') {\r\n        paddingLeft = first.width / 2;\r\n        paddingRight = last.width / 2;\r\n      }\r\n\r\n      // Adjust padding taking into account changes in offsets\r\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\r\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\r\n    } else {\r\n      let paddingTop = last.height / 2;\r\n      let paddingBottom = first.height / 2;\r\n\r\n      if (align === 'start') {\r\n        paddingTop = 0;\r\n        paddingBottom = first.height;\r\n      } else if (align === 'end') {\r\n        paddingTop = last.height;\r\n        paddingBottom = 0;\r\n      }\r\n\r\n      this.paddingTop = paddingTop + padding;\r\n      this.paddingBottom = paddingBottom + padding;\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Handle margins and padding interactions\r\n\t * @private\r\n\t */\r\n  _handleMargins() {\r\n    if (this._margins) {\r\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\r\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\r\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\r\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\r\n    }\r\n  }\r\n\r\n  afterFit() {\r\n    call(this.options.afterFit, [this]);\r\n  }\r\n\r\n  // Shared Methods\r\n  /**\r\n\t * @return {boolean}\r\n\t */\r\n  isHorizontal() {\r\n    const {axis, position} = this.options;\r\n    return position === 'top' || position === 'bottom' || axis === 'x';\r\n  }\r\n  /**\r\n\t * @return {boolean}\r\n\t */\r\n  isFullSize() {\r\n    return this.options.fullSize;\r\n  }\r\n\r\n  /**\r\n\t * @param {Tick[]} ticks\r\n\t * @private\r\n\t */\r\n  _convertTicksToLabels(ticks) {\r\n    this.beforeTickToLabelConversion();\r\n\r\n    this.generateTickLabels(ticks);\r\n\r\n    // Ticks should be skipped when callback returns null or undef, so lets remove those.\r\n    let i, ilen;\r\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n      if (isNullOrUndef(ticks[i].label)) {\r\n        ticks.splice(i, 1);\r\n        ilen--;\r\n        i--;\r\n      }\r\n    }\r\n\r\n    this.afterTickToLabelConversion();\r\n  }\r\n\r\n  /**\r\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\r\n\t * @private\r\n\t */\r\n  _getLabelSizes() {\r\n    let labelSizes = this._labelSizes;\r\n\r\n    if (!labelSizes) {\r\n      const sampleSize = this.options.ticks.sampleSize;\r\n      let ticks = this.ticks;\r\n      if (sampleSize < ticks.length) {\r\n        ticks = sample(ticks, sampleSize);\r\n      }\r\n\r\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\r\n    }\r\n\r\n    return labelSizes;\r\n  }\r\n\r\n  /**\r\n\t * Returns {width, height, offset} objects for the first, last, widest, highest tick\r\n\t * labels where offset indicates the anchor point offset from the top in pixels.\r\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\r\n\t * @private\r\n\t */\r\n  _computeLabelSizes(ticks, length, maxTicksLimit) {\r\n    const {ctx, _longestTextCache: caches} = this;\r\n    const widths = [];\r\n    const heights = [];\r\n    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\r\n    let widestLabelSize = 0;\r\n    let highestLabelSize = 0;\r\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\r\n\r\n    for (i = 0; i < length; i += increment) {\r\n      label = ticks[i].label;\r\n      tickFont = this._resolveTickFontOptions(i);\r\n      ctx.font = fontString = tickFont.string;\r\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\r\n      lineHeight = tickFont.lineHeight;\r\n      width = height = 0;\r\n      // Undefined labels and arrays should not be measured\r\n      if (!isNullOrUndef(label) && !isArray(label)) {\r\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\r\n        height = lineHeight;\r\n      } else if (isArray(label)) {\r\n        // if it is an array let's measure each element\r\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\r\n          nestedLabel = /** @type {string} */ (label[j]);\r\n          // Undefined labels and arrays should not be measured\r\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\r\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\r\n            height += lineHeight;\r\n          }\r\n        }\r\n      }\r\n      widths.push(width);\r\n      heights.push(height);\r\n      widestLabelSize = Math.max(width, widestLabelSize);\r\n      highestLabelSize = Math.max(height, highestLabelSize);\r\n    }\r\n    garbageCollect(caches, length);\r\n\r\n    const widest = widths.indexOf(widestLabelSize);\r\n    const highest = heights.indexOf(highestLabelSize);\r\n\r\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\r\n\r\n    return {\r\n      first: valueAt(0),\r\n      last: valueAt(length - 1),\r\n      widest: valueAt(widest),\r\n      highest: valueAt(highest),\r\n      widths,\r\n      heights,\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * Used to get the label to display in the tooltip for the given value\r\n\t * @param {*} value\r\n\t * @return {string}\r\n\t */\r\n  getLabelForValue(value) {\r\n    return value;\r\n  }\r\n\r\n  /**\r\n\t * Returns the location of the given data point. Value can either be an index or a numerical value\r\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t * @param {*} value\r\n\t * @param {number} [index]\r\n\t * @return {number}\r\n\t */\r\n  getPixelForValue(value, index) { // eslint-disable-line no-unused-vars\r\n    return NaN;\r\n  }\r\n\r\n  /**\r\n\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\r\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t * @param {number} pixel\r\n\t * @return {*}\r\n\t */\r\n  getValueForPixel(pixel) {} // eslint-disable-line no-unused-vars\r\n\r\n  /**\r\n\t * Returns the location of the tick at the given index\r\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t * @param {number} index\r\n\t * @return {number}\r\n\t */\r\n  getPixelForTick(index) {\r\n    const ticks = this.ticks;\r\n    if (index < 0 || index > ticks.length - 1) {\r\n      return null;\r\n    }\r\n    return this.getPixelForValue(ticks[index].value);\r\n  }\r\n\r\n  /**\r\n\t * Utility for getting the pixel location of a percentage of scale\r\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t * @param {number} decimal\r\n\t * @return {number}\r\n\t */\r\n  getPixelForDecimal(decimal) {\r\n    if (this._reversePixels) {\r\n      decimal = 1 - decimal;\r\n    }\r\n\r\n    const pixel = this._startPixel + decimal * this._length;\r\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\r\n  }\r\n\r\n  /**\r\n\t * @param {number} pixel\r\n\t * @return {number}\r\n\t */\r\n  getDecimalForPixel(pixel) {\r\n    const decimal = (pixel - this._startPixel) / this._length;\r\n    return this._reversePixels ? 1 - decimal : decimal;\r\n  }\r\n\r\n  /**\r\n\t * Returns the pixel for the minimum chart value\r\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\r\n\t * @return {number}\r\n\t */\r\n  getBasePixel() {\r\n    return this.getPixelForValue(this.getBaseValue());\r\n  }\r\n\r\n  /**\r\n\t * @return {number}\r\n\t */\r\n  getBaseValue() {\r\n    const {min, max} = this;\r\n\r\n    return min < 0 && max < 0 ? max :\r\n      min > 0 && max > 0 ? min :\r\n      0;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getContext(index) {\r\n    const ticks = this.ticks || [];\r\n\r\n    if (index >= 0 && index < ticks.length) {\r\n      const tick = ticks[index];\r\n      return tick.$context ||\r\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\r\n    }\r\n    return this.$context ||\r\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\r\n  }\r\n\r\n  /**\r\n\t * @return {number}\r\n\t * @private\r\n\t */\r\n  _tickSize() {\r\n    const optionTicks = this.options.ticks;\r\n\r\n    // Calculate space needed by label in axis direction.\r\n    const rot = toRadians(this.labelRotation);\r\n    const cos = Math.abs(Math.cos(rot));\r\n    const sin = Math.abs(Math.sin(rot));\r\n\r\n    const labelSizes = this._getLabelSizes();\r\n    const padding = optionTicks.autoSkipPadding || 0;\r\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\r\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\r\n\r\n    // Calculate space needed for 1 tick in axis direction.\r\n    return this.isHorizontal()\r\n      ? h * cos > w * sin ? w / cos : h / sin\r\n      : h * sin < w * cos ? h / cos : w / sin;\r\n  }\r\n\r\n  /**\r\n\t * @return {boolean}\r\n\t * @private\r\n\t */\r\n  _isVisible() {\r\n    const display = this.options.display;\r\n\r\n    if (display !== 'auto') {\r\n      return !!display;\r\n    }\r\n\r\n    return this.getMatchingVisibleMetas().length > 0;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _computeGridLineItems(chartArea) {\r\n    const axis = this.axis;\r\n    const chart = this.chart;\r\n    const options = this.options;\r\n    const {grid, position, border} = options;\r\n    const offset = grid.offset;\r\n    const isHorizontal = this.isHorizontal();\r\n    const ticks = this.ticks;\r\n    const ticksLength = ticks.length + (offset ? 1 : 0);\r\n    const tl = getTickMarkLength(grid);\r\n    const items = [];\r\n\r\n    const borderOpts = border.setContext(this.getContext());\r\n    const axisWidth = borderOpts.display ? borderOpts.width : 0;\r\n    const axisHalfWidth = axisWidth / 2;\r\n    const alignBorderValue = function(pixel) {\r\n      return _alignPixel(chart, pixel, axisWidth);\r\n    };\r\n    let borderValue, i, lineValue, alignedLineValue;\r\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\r\n\r\n    if (position === 'top') {\r\n      borderValue = alignBorderValue(this.bottom);\r\n      ty1 = this.bottom - tl;\r\n      ty2 = borderValue - axisHalfWidth;\r\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\r\n      y2 = chartArea.bottom;\r\n    } else if (position === 'bottom') {\r\n      borderValue = alignBorderValue(this.top);\r\n      y1 = chartArea.top;\r\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\r\n      ty1 = borderValue + axisHalfWidth;\r\n      ty2 = this.top + tl;\r\n    } else if (position === 'left') {\r\n      borderValue = alignBorderValue(this.right);\r\n      tx1 = this.right - tl;\r\n      tx2 = borderValue - axisHalfWidth;\r\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\r\n      x2 = chartArea.right;\r\n    } else if (position === 'right') {\r\n      borderValue = alignBorderValue(this.left);\r\n      x1 = chartArea.left;\r\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\r\n      tx1 = borderValue + axisHalfWidth;\r\n      tx2 = this.left + tl;\r\n    } else if (axis === 'x') {\r\n      if (position === 'center') {\r\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\r\n      } else if (isObject(position)) {\r\n        const positionAxisID = Object.keys(position)[0];\r\n        const value = position[positionAxisID];\r\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\r\n      }\r\n\r\n      y1 = chartArea.top;\r\n      y2 = chartArea.bottom;\r\n      ty1 = borderValue + axisHalfWidth;\r\n      ty2 = ty1 + tl;\r\n    } else if (axis === 'y') {\r\n      if (position === 'center') {\r\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\r\n      } else if (isObject(position)) {\r\n        const positionAxisID = Object.keys(position)[0];\r\n        const value = position[positionAxisID];\r\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\r\n      }\r\n\r\n      tx1 = borderValue - axisHalfWidth;\r\n      tx2 = tx1 - tl;\r\n      x1 = chartArea.left;\r\n      x2 = chartArea.right;\r\n    }\r\n\r\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\r\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\r\n    for (i = 0; i < ticksLength; i += step) {\r\n      const context = this.getContext(i);\r\n      const optsAtIndex = grid.setContext(context);\r\n      const optsAtIndexBorder = border.setContext(context);\r\n\r\n      const lineWidth = optsAtIndex.lineWidth;\r\n      const lineColor = optsAtIndex.color;\r\n      const borderDash = optsAtIndexBorder.dash || [];\r\n      const borderDashOffset = optsAtIndexBorder.dashOffset;\r\n\r\n      const tickWidth = optsAtIndex.tickWidth;\r\n      const tickColor = optsAtIndex.tickColor;\r\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\r\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\r\n\r\n      lineValue = getPixelForGridLine(this, i, offset);\r\n\r\n      // Skip if the pixel is out of the range\r\n      if (lineValue === undefined) {\r\n        continue;\r\n      }\r\n\r\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\r\n\r\n      if (isHorizontal) {\r\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\r\n      } else {\r\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\r\n      }\r\n\r\n      items.push({\r\n        tx1,\r\n        ty1,\r\n        tx2,\r\n        ty2,\r\n        x1,\r\n        y1,\r\n        x2,\r\n        y2,\r\n        width: lineWidth,\r\n        color: lineColor,\r\n        borderDash,\r\n        borderDashOffset,\r\n        tickWidth,\r\n        tickColor,\r\n        tickBorderDash,\r\n        tickBorderDashOffset,\r\n      });\r\n    }\r\n\r\n    this._ticksLength = ticksLength;\r\n    this._borderValue = borderValue;\r\n\r\n    return items;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _computeLabelItems(chartArea) {\r\n    const axis = this.axis;\r\n    const options = this.options;\r\n    const {position, ticks: optionTicks} = options;\r\n    const isHorizontal = this.isHorizontal();\r\n    const ticks = this.ticks;\r\n    const {align, crossAlign, padding, mirror} = optionTicks;\r\n    const tl = getTickMarkLength(options.grid);\r\n    const tickAndPadding = tl + padding;\r\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\r\n    const rotation = -toRadians(this.labelRotation);\r\n    const items = [];\r\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\r\n    let textBaseline = 'middle';\r\n\r\n    if (position === 'top') {\r\n      y = this.bottom - hTickAndPadding;\r\n      textAlign = this._getXAxisLabelAlignment();\r\n    } else if (position === 'bottom') {\r\n      y = this.top + hTickAndPadding;\r\n      textAlign = this._getXAxisLabelAlignment();\r\n    } else if (position === 'left') {\r\n      const ret = this._getYAxisLabelAlignment(tl);\r\n      textAlign = ret.textAlign;\r\n      x = ret.x;\r\n    } else if (position === 'right') {\r\n      const ret = this._getYAxisLabelAlignment(tl);\r\n      textAlign = ret.textAlign;\r\n      x = ret.x;\r\n    } else if (axis === 'x') {\r\n      if (position === 'center') {\r\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\r\n      } else if (isObject(position)) {\r\n        const positionAxisID = Object.keys(position)[0];\r\n        const value = position[positionAxisID];\r\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\r\n      }\r\n      textAlign = this._getXAxisLabelAlignment();\r\n    } else if (axis === 'y') {\r\n      if (position === 'center') {\r\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\r\n      } else if (isObject(position)) {\r\n        const positionAxisID = Object.keys(position)[0];\r\n        const value = position[positionAxisID];\r\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\r\n      }\r\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\r\n    }\r\n\r\n    if (axis === 'y') {\r\n      if (align === 'start') {\r\n        textBaseline = 'top';\r\n      } else if (align === 'end') {\r\n        textBaseline = 'bottom';\r\n      }\r\n    }\r\n\r\n    const labelSizes = this._getLabelSizes();\r\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n      tick = ticks[i];\r\n      label = tick.label;\r\n\r\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\r\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\r\n      font = this._resolveTickFontOptions(i);\r\n      lineHeight = font.lineHeight;\r\n      lineCount = isArray(label) ? label.length : 1;\r\n      const halfCount = lineCount / 2;\r\n      const color = optsAtIndex.color;\r\n      const strokeColor = optsAtIndex.textStrokeColor;\r\n      const strokeWidth = optsAtIndex.textStrokeWidth;\r\n      let tickTextAlign = textAlign;\r\n\r\n      if (isHorizontal) {\r\n        x = pixel;\r\n\r\n        if (textAlign === 'inner') {\r\n          if (i === ilen - 1) {\r\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\r\n          } else if (i === 0) {\r\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\r\n          } else {\r\n            tickTextAlign = 'center';\r\n          }\r\n        }\r\n\r\n        if (position === 'top') {\r\n          if (crossAlign === 'near' || rotation !== 0) {\r\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\r\n          } else if (crossAlign === 'center') {\r\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\r\n          } else {\r\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\r\n          }\r\n        } else {\r\n          // eslint-disable-next-line no-lonely-if\r\n          if (crossAlign === 'near' || rotation !== 0) {\r\n            textOffset = lineHeight / 2;\r\n          } else if (crossAlign === 'center') {\r\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\r\n          } else {\r\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\r\n          }\r\n        }\r\n        if (mirror) {\r\n          textOffset *= -1;\r\n        }\r\n        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\r\n          x += (lineHeight / 2) * Math.sin(rotation);\r\n        }\r\n      } else {\r\n        y = pixel;\r\n        textOffset = (1 - lineCount) * lineHeight / 2;\r\n      }\r\n\r\n      let backdrop;\r\n\r\n      if (optsAtIndex.showLabelBackdrop) {\r\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\r\n        const height = labelSizes.heights[i];\r\n        const width = labelSizes.widths[i];\r\n\r\n        let top = textOffset - labelPadding.top;\r\n        let left = 0 - labelPadding.left;\r\n\r\n        switch (textBaseline) {\r\n        case 'middle':\r\n          top -= height / 2;\r\n          break;\r\n        case 'bottom':\r\n          top -= height;\r\n          break;\r\n        default:\r\n          break;\r\n        }\r\n\r\n        switch (textAlign) {\r\n        case 'center':\r\n          left -= width / 2;\r\n          break;\r\n        case 'right':\r\n          left -= width;\r\n          break;\r\n        default:\r\n          break;\r\n        }\r\n\r\n        backdrop = {\r\n          left,\r\n          top,\r\n          width: width + labelPadding.width,\r\n          height: height + labelPadding.height,\r\n\r\n          color: optsAtIndex.backdropColor,\r\n        };\r\n      }\r\n\r\n      items.push({\r\n        label,\r\n        font,\r\n        textOffset,\r\n        options: {\r\n          rotation,\r\n          color,\r\n          strokeColor,\r\n          strokeWidth,\r\n          textAlign: tickTextAlign,\r\n          textBaseline,\r\n          translation: [x, y],\r\n          backdrop,\r\n        }\r\n      });\r\n    }\r\n\r\n    return items;\r\n  }\r\n\r\n  _getXAxisLabelAlignment() {\r\n    const {position, ticks} = this.options;\r\n    const rotation = -toRadians(this.labelRotation);\r\n\r\n    if (rotation) {\r\n      return position === 'top' ? 'left' : 'right';\r\n    }\r\n\r\n    let align = 'center';\r\n\r\n    if (ticks.align === 'start') {\r\n      align = 'left';\r\n    } else if (ticks.align === 'end') {\r\n      align = 'right';\r\n    } else if (ticks.align === 'inner') {\r\n      align = 'inner';\r\n    }\r\n\r\n    return align;\r\n  }\r\n\r\n  _getYAxisLabelAlignment(tl) {\r\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\r\n    const labelSizes = this._getLabelSizes();\r\n    const tickAndPadding = tl + padding;\r\n    const widest = labelSizes.widest.width;\r\n\r\n    let textAlign;\r\n    let x;\r\n\r\n    if (position === 'left') {\r\n      if (mirror) {\r\n        x = this.right + padding;\r\n\r\n        if (crossAlign === 'near') {\r\n          textAlign = 'left';\r\n        } else if (crossAlign === 'center') {\r\n          textAlign = 'center';\r\n          x += (widest / 2);\r\n        } else {\r\n          textAlign = 'right';\r\n          x += widest;\r\n        }\r\n      } else {\r\n        x = this.right - tickAndPadding;\r\n\r\n        if (crossAlign === 'near') {\r\n          textAlign = 'right';\r\n        } else if (crossAlign === 'center') {\r\n          textAlign = 'center';\r\n          x -= (widest / 2);\r\n        } else {\r\n          textAlign = 'left';\r\n          x = this.left;\r\n        }\r\n      }\r\n    } else if (position === 'right') {\r\n      if (mirror) {\r\n        x = this.left + padding;\r\n\r\n        if (crossAlign === 'near') {\r\n          textAlign = 'right';\r\n        } else if (crossAlign === 'center') {\r\n          textAlign = 'center';\r\n          x -= (widest / 2);\r\n        } else {\r\n          textAlign = 'left';\r\n          x -= widest;\r\n        }\r\n      } else {\r\n        x = this.left + tickAndPadding;\r\n\r\n        if (crossAlign === 'near') {\r\n          textAlign = 'left';\r\n        } else if (crossAlign === 'center') {\r\n          textAlign = 'center';\r\n          x += widest / 2;\r\n        } else {\r\n          textAlign = 'right';\r\n          x = this.right;\r\n        }\r\n      }\r\n    } else {\r\n      textAlign = 'right';\r\n    }\r\n\r\n    return {textAlign, x};\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _computeLabelArea() {\r\n    if (this.options.ticks.mirror) {\r\n      return;\r\n    }\r\n\r\n    const chart = this.chart;\r\n    const position = this.options.position;\r\n\r\n    if (position === 'left' || position === 'right') {\r\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\r\n    } if (position === 'top' || position === 'bottom') {\r\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  drawBackground() {\r\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\r\n    if (backgroundColor) {\r\n      ctx.save();\r\n      ctx.fillStyle = backgroundColor;\r\n      ctx.fillRect(left, top, width, height);\r\n      ctx.restore();\r\n    }\r\n  }\r\n\r\n  getLineWidthForValue(value) {\r\n    const grid = this.options.grid;\r\n    if (!this._isVisible() || !grid.display) {\r\n      return 0;\r\n    }\r\n    const ticks = this.ticks;\r\n    const index = ticks.findIndex(t => t.value === value);\r\n    if (index >= 0) {\r\n      const opts = grid.setContext(this.getContext(index));\r\n      return opts.lineWidth;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawGrid(chartArea) {\r\n    const grid = this.options.grid;\r\n    const ctx = this.ctx;\r\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\r\n    let i, ilen;\r\n\r\n    const drawLine = (p1, p2, style) => {\r\n      if (!style.width || !style.color) {\r\n        return;\r\n      }\r\n      ctx.save();\r\n      ctx.lineWidth = style.width;\r\n      ctx.strokeStyle = style.color;\r\n      ctx.setLineDash(style.borderDash || []);\r\n      ctx.lineDashOffset = style.borderDashOffset;\r\n\r\n      ctx.beginPath();\r\n      ctx.moveTo(p1.x, p1.y);\r\n      ctx.lineTo(p2.x, p2.y);\r\n      ctx.stroke();\r\n      ctx.restore();\r\n    };\r\n\r\n    if (grid.display) {\r\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n        const item = items[i];\r\n\r\n        if (grid.drawOnChartArea) {\r\n          drawLine(\r\n            {x: item.x1, y: item.y1},\r\n            {x: item.x2, y: item.y2},\r\n            item\r\n          );\r\n        }\r\n\r\n        if (grid.drawTicks) {\r\n          drawLine(\r\n            {x: item.tx1, y: item.ty1},\r\n            {x: item.tx2, y: item.ty2},\r\n            {\r\n              color: item.tickColor,\r\n              width: item.tickWidth,\r\n              borderDash: item.tickBorderDash,\r\n              borderDashOffset: item.tickBorderDashOffset\r\n            }\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawBorder() {\r\n    const {chart, ctx, options: {border, grid}} = this;\r\n    const borderOpts = border.setContext(this.getContext());\r\n    const axisWidth = border.display ? borderOpts.width : 0;\r\n    if (!axisWidth) {\r\n      return;\r\n    }\r\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\r\n    const borderValue = this._borderValue;\r\n    let x1, x2, y1, y2;\r\n\r\n    if (this.isHorizontal()) {\r\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\r\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\r\n      y1 = y2 = borderValue;\r\n    } else {\r\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\r\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\r\n      x1 = x2 = borderValue;\r\n    }\r\n    ctx.save();\r\n    ctx.lineWidth = borderOpts.width;\r\n    ctx.strokeStyle = borderOpts.color;\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(x1, y1);\r\n    ctx.lineTo(x2, y2);\r\n    ctx.stroke();\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawLabels(chartArea) {\r\n    const optionTicks = this.options.ticks;\r\n\r\n    if (!optionTicks.display) {\r\n      return;\r\n    }\r\n\r\n    const ctx = this.ctx;\r\n\r\n    const area = this._computeLabelArea();\r\n    if (area) {\r\n      clipArea(ctx, area);\r\n    }\r\n\r\n    const items = this.getLabelItems(chartArea);\r\n    for (const item of items) {\r\n      const renderTextOptions = item.options;\r\n      const tickFont = item.font;\r\n      const label = item.label;\r\n      const y = item.textOffset;\r\n      renderText(ctx, label, 0, y, tickFont, renderTextOptions);\r\n    }\r\n\r\n    if (area) {\r\n      unclipArea(ctx);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawTitle() {\r\n    const {ctx, options: {position, title, reverse}} = this;\r\n\r\n    if (!title.display) {\r\n      return;\r\n    }\r\n\r\n    const font = toFont(title.font);\r\n    const padding = toPadding(title.padding);\r\n    const align = title.align;\r\n    let offset = font.lineHeight / 2;\r\n\r\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\r\n      offset += padding.bottom;\r\n      if (isArray(title.text)) {\r\n        offset += font.lineHeight * (title.text.length - 1);\r\n      }\r\n    } else {\r\n      offset += padding.top;\r\n    }\r\n\r\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\r\n\r\n    renderText(ctx, title.text, 0, 0, font, {\r\n      color: title.color,\r\n      maxWidth,\r\n      rotation,\r\n      textAlign: titleAlign(align, position, reverse),\r\n      textBaseline: 'middle',\r\n      translation: [titleX, titleY],\r\n    });\r\n  }\r\n\r\n  draw(chartArea) {\r\n    if (!this._isVisible()) {\r\n      return;\r\n    }\r\n\r\n    this.drawBackground();\r\n    this.drawGrid(chartArea);\r\n    this.drawBorder();\r\n    this.drawTitle();\r\n    this.drawLabels(chartArea);\r\n  }\r\n\r\n  /**\r\n\t * @return {object[]}\r\n\t * @private\r\n\t */\r\n  _layers() {\r\n    const opts = this.options;\r\n    const tz = opts.ticks && opts.ticks.z || 0;\r\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\r\n    const bz = valueOrDefault(opts.border && opts.border.z, 0);\r\n\r\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\r\n      // backward compatibility: draw has been overridden by custom scale\r\n      return [{\r\n        z: tz,\r\n        draw: (chartArea) => {\r\n          this.draw(chartArea);\r\n        }\r\n      }];\r\n    }\r\n\r\n    return [{\r\n      z: gz,\r\n      draw: (chartArea) => {\r\n        this.drawBackground();\r\n        this.drawGrid(chartArea);\r\n        this.drawTitle();\r\n      }\r\n    }, {\r\n      z: bz,\r\n      draw: () => {\r\n        this.drawBorder();\r\n      }\r\n    }, {\r\n      z: tz,\r\n      draw: (chartArea) => {\r\n        this.drawLabels(chartArea);\r\n      }\r\n    }];\r\n  }\r\n\r\n  /**\r\n\t * Returns visible dataset metas that are attached to this scale\r\n\t * @param {string} [type] - if specified, also filter by dataset type\r\n\t * @return {object[]}\r\n\t */\r\n  getMatchingVisibleMetas(type) {\r\n    const metas = this.chart.getSortedVisibleDatasetMetas();\r\n    const axisID = this.axis + 'AxisID';\r\n    const result = [];\r\n    let i, ilen;\r\n\r\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\r\n      const meta = metas[i];\r\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\r\n        result.push(meta);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n\t * @param {number} index\r\n\t * @return {object}\r\n\t * @protected\r\n \t */\r\n  _resolveTickFontOptions(index) {\r\n    const opts = this.options.ticks.setContext(this.getContext(index));\r\n    return toFont(opts.font);\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  _maxDigits() {\r\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\r\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\r\n  }\r\n}\r\n","import {merge} from '../helpers/index.js';\r\nimport defaults, {overrides} from './core.defaults.js';\r\n\r\n/**\r\n * @typedef {{id: string, defaults: any, overrides?: any, defaultRoutes: any}} IChartComponent\r\n */\r\n\r\nexport default class TypedRegistry {\r\n  constructor(type, scope, override) {\r\n    this.type = type;\r\n    this.scope = scope;\r\n    this.override = override;\r\n    this.items = Object.create(null);\r\n  }\r\n\r\n  isForType(type) {\r\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\r\n  }\r\n\r\n  /**\r\n\t * @param {IChartComponent} item\r\n\t * @returns {string} The scope where items defaults were registered to.\r\n\t */\r\n  register(item) {\r\n    const proto = Object.getPrototypeOf(item);\r\n    let parentScope;\r\n\r\n    if (isIChartComponent(proto)) {\r\n      // Make sure the parent is registered and note the scope where its defaults are.\r\n      parentScope = this.register(proto);\r\n    }\r\n\r\n    const items = this.items;\r\n    const id = item.id;\r\n    const scope = this.scope + '.' + id;\r\n\r\n    if (!id) {\r\n      throw new Error('class does not have id: ' + item);\r\n    }\r\n\r\n    if (id in items) {\r\n      // already registered\r\n      return scope;\r\n    }\r\n\r\n    items[id] = item;\r\n    registerDefaults(item, scope, parentScope);\r\n    if (this.override) {\r\n      defaults.override(item.id, item.overrides);\r\n    }\r\n\r\n    return scope;\r\n  }\r\n\r\n  /**\r\n\t * @param {string} id\r\n\t * @returns {object?}\r\n\t */\r\n  get(id) {\r\n    return this.items[id];\r\n  }\r\n\r\n  /**\r\n\t * @param {IChartComponent} item\r\n\t */\r\n  unregister(item) {\r\n    const items = this.items;\r\n    const id = item.id;\r\n    const scope = this.scope;\r\n\r\n    if (id in items) {\r\n      delete items[id];\r\n    }\r\n\r\n    if (scope && id in defaults[scope]) {\r\n      delete defaults[scope][id];\r\n      if (this.override) {\r\n        delete overrides[id];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction registerDefaults(item, scope, parentScope) {\r\n  // Inherit the parent's defaults and keep existing defaults\r\n  const itemDefaults = merge(Object.create(null), [\r\n    parentScope ? defaults.get(parentScope) : {},\r\n    defaults.get(scope),\r\n    item.defaults\r\n  ]);\r\n\r\n  defaults.set(scope, itemDefaults);\r\n\r\n  if (item.defaultRoutes) {\r\n    routeDefaults(scope, item.defaultRoutes);\r\n  }\r\n\r\n  if (item.descriptors) {\r\n    defaults.describe(scope, item.descriptors);\r\n  }\r\n}\r\n\r\nfunction routeDefaults(scope, routes) {\r\n  Object.keys(routes).forEach(property => {\r\n    const propertyParts = property.split('.');\r\n    const sourceName = propertyParts.pop();\r\n    const sourceScope = [scope].concat(propertyParts).join('.');\r\n    const parts = routes[property].split('.');\r\n    const targetName = parts.pop();\r\n    const targetScope = parts.join('.');\r\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\r\n  });\r\n}\r\n\r\nfunction isIChartComponent(proto) {\r\n  return 'id' in proto && 'defaults' in proto;\r\n}\r\n","import DatasetController from './core.datasetController.js';\r\nimport Element from './core.element.js';\r\nimport Scale from './core.scale.js';\r\nimport TypedRegistry from './core.typedRegistry.js';\r\nimport {each, callback as call, _capitalize} from '../helpers/helpers.core.js';\r\n\r\n/**\r\n * Please use the module's default export which provides a singleton instance\r\n * Note: class is exported for typedoc\r\n */\r\nexport class Registry {\r\n  constructor() {\r\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\r\n    this.elements = new TypedRegistry(Element, 'elements');\r\n    this.plugins = new TypedRegistry(Object, 'plugins');\r\n    this.scales = new TypedRegistry(Scale, 'scales');\r\n    // Order is important, Scale has Element in prototype chain,\r\n    // so Scales must be before Elements. Plugins are a fallback, so not listed here.\r\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\r\n  }\r\n\r\n  /**\r\n\t * @param  {...any} args\r\n\t */\r\n  add(...args) {\r\n    this._each('register', args);\r\n  }\r\n\r\n  remove(...args) {\r\n    this._each('unregister', args);\r\n  }\r\n\r\n  /**\r\n\t * @param  {...typeof DatasetController} args\r\n\t */\r\n  addControllers(...args) {\r\n    this._each('register', args, this.controllers);\r\n  }\r\n\r\n  /**\r\n\t * @param  {...typeof Element} args\r\n\t */\r\n  addElements(...args) {\r\n    this._each('register', args, this.elements);\r\n  }\r\n\r\n  /**\r\n\t * @param  {...any} args\r\n\t */\r\n  addPlugins(...args) {\r\n    this._each('register', args, this.plugins);\r\n  }\r\n\r\n  /**\r\n\t * @param  {...typeof Scale} args\r\n\t */\r\n  addScales(...args) {\r\n    this._each('register', args, this.scales);\r\n  }\r\n\r\n  /**\r\n\t * @param {string} id\r\n\t * @returns {typeof DatasetController}\r\n\t */\r\n  getController(id) {\r\n    return this._get(id, this.controllers, 'controller');\r\n  }\r\n\r\n  /**\r\n\t * @param {string} id\r\n\t * @returns {typeof Element}\r\n\t */\r\n  getElement(id) {\r\n    return this._get(id, this.elements, 'element');\r\n  }\r\n\r\n  /**\r\n\t * @param {string} id\r\n\t * @returns {object}\r\n\t */\r\n  getPlugin(id) {\r\n    return this._get(id, this.plugins, 'plugin');\r\n  }\r\n\r\n  /**\r\n\t * @param {string} id\r\n\t * @returns {typeof Scale}\r\n\t */\r\n  getScale(id) {\r\n    return this._get(id, this.scales, 'scale');\r\n  }\r\n\r\n  /**\r\n\t * @param  {...typeof DatasetController} args\r\n\t */\r\n  removeControllers(...args) {\r\n    this._each('unregister', args, this.controllers);\r\n  }\r\n\r\n  /**\r\n\t * @param  {...typeof Element} args\r\n\t */\r\n  removeElements(...args) {\r\n    this._each('unregister', args, this.elements);\r\n  }\r\n\r\n  /**\r\n\t * @param  {...any} args\r\n\t */\r\n  removePlugins(...args) {\r\n    this._each('unregister', args, this.plugins);\r\n  }\r\n\r\n  /**\r\n\t * @param  {...typeof Scale} args\r\n\t */\r\n  removeScales(...args) {\r\n    this._each('unregister', args, this.scales);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _each(method, args, typedRegistry) {\r\n    [...args].forEach(arg => {\r\n      const reg = typedRegistry || this._getRegistryForType(arg);\r\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\r\n        this._exec(method, reg, arg);\r\n      } else {\r\n        // Handle loopable args\r\n        // Use case:\r\n        //  import * as plugins from './plugins.js';\r\n        //  Chart.register(plugins);\r\n        each(arg, item => {\r\n          // If there are mixed types in the loopable, make sure those are\r\n          // registered in correct registry\r\n          // Use case: (treemap exporting controller, elements etc)\r\n          //  import * as treemap from 'chartjs-chart-treemap.js';\r\n          //  Chart.register(treemap);\r\n\r\n          const itemReg = typedRegistry || this._getRegistryForType(item);\r\n          this._exec(method, itemReg, item);\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _exec(method, registry, component) {\r\n    const camelMethod = _capitalize(method);\r\n    call(component['before' + camelMethod], [], component); // beforeRegister / beforeUnregister\r\n    registry[method](component);\r\n    call(component['after' + camelMethod], [], component); // afterRegister / afterUnregister\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getRegistryForType(type) {\r\n    for (let i = 0; i < this._typedRegistries.length; i++) {\r\n      const reg = this._typedRegistries[i];\r\n      if (reg.isForType(type)) {\r\n        return reg;\r\n      }\r\n    }\r\n    // plugins is the fallback registry\r\n    return this.plugins;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _get(id, typedRegistry, type) {\r\n    const item = typedRegistry.get(id);\r\n    if (item === undefined) {\r\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\r\n    }\r\n    return item;\r\n  }\r\n\r\n}\r\n\r\n// singleton instance\r\nexport default /* #__PURE__ */ new Registry();\r\n","import registry from './core.registry.js';\r\nimport {callback as callCallback, isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\r\n\r\n/**\r\n * @typedef { import('./core.controller.js').default } Chart\r\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\r\n * @typedef { import('../plugins/plugin.tooltip.js').default } Tooltip\r\n */\r\n\r\n/**\r\n * @callback filterCallback\r\n * @param {{plugin: object, options: object}} value\r\n * @param {number} [index]\r\n * @param {array} [array]\r\n * @param {object} [thisArg]\r\n * @return {boolean}\r\n */\r\n\r\n\r\nexport default class PluginService {\r\n  constructor() {\r\n    this._init = [];\r\n  }\r\n\r\n  /**\r\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\r\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\r\n\t * returned value can be used, for instance, to interrupt the current action.\r\n\t * @param {Chart} chart - The chart instance for which plugins should be called.\r\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\r\n\t * @param {object} [args] - Extra arguments to apply to the hook call.\r\n   * @param {filterCallback} [filter] - Filtering function for limiting which plugins are notified\r\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\r\n\t */\r\n  notify(chart, hook, args, filter) {\r\n    if (hook === 'beforeInit') {\r\n      this._init = this._createDescriptors(chart, true);\r\n      this._notify(this._init, chart, 'install');\r\n    }\r\n\r\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\r\n    const result = this._notify(descriptors, chart, hook, args);\r\n\r\n    if (hook === 'afterDestroy') {\r\n      this._notify(descriptors, chart, 'stop');\r\n      this._notify(this._init, chart, 'uninstall');\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _notify(descriptors, chart, hook, args) {\r\n    args = args || {};\r\n    for (const descriptor of descriptors) {\r\n      const plugin = descriptor.plugin;\r\n      const method = plugin[hook];\r\n      const params = [chart, args, descriptor.options];\r\n      if (callCallback(method, params, plugin) === false && args.cancelable) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  invalidate() {\r\n    // When plugins are registered, there is the possibility of a double\r\n    // invalidate situation. In this case, we only want to invalidate once.\r\n    // If we invalidate multiple times, the `_oldCache` is lost and all of the\r\n    // plugins are restarted without being correctly stopped.\r\n    // See https://github.com/chartjs/Chart.js/issues/8147\r\n    if (!isNullOrUndef(this._cache)) {\r\n      this._oldCache = this._cache;\r\n      this._cache = undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @param {Chart} chart\r\n\t * @private\r\n\t */\r\n  _descriptors(chart) {\r\n    if (this._cache) {\r\n      return this._cache;\r\n    }\r\n\r\n    const descriptors = this._cache = this._createDescriptors(chart);\r\n\r\n    this._notifyStateChanges(chart);\r\n\r\n    return descriptors;\r\n  }\r\n\r\n  _createDescriptors(chart, all) {\r\n    const config = chart && chart.config;\r\n    const options = valueOrDefault(config.options && config.options.plugins, {});\r\n    const plugins = allPlugins(config);\r\n    // options === false => all plugins are disabled\r\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\r\n  }\r\n\r\n  /**\r\n\t * @param {Chart} chart\r\n\t * @private\r\n\t */\r\n  _notifyStateChanges(chart) {\r\n    const previousDescriptors = this._oldCache || [];\r\n    const descriptors = this._cache;\r\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\r\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\r\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import('./core.config.js').default} config\r\n */\r\nfunction allPlugins(config) {\r\n  const localIds = {};\r\n  const plugins = [];\r\n  const keys = Object.keys(registry.plugins.items);\r\n  for (let i = 0; i < keys.length; i++) {\r\n    plugins.push(registry.getPlugin(keys[i]));\r\n  }\r\n\r\n  const local = config.plugins || [];\r\n  for (let i = 0; i < local.length; i++) {\r\n    const plugin = local[i];\r\n\r\n    if (plugins.indexOf(plugin) === -1) {\r\n      plugins.push(plugin);\r\n      localIds[plugin.id] = true;\r\n    }\r\n  }\r\n\r\n  return {plugins, localIds};\r\n}\r\n\r\nfunction getOpts(options, all) {\r\n  if (!all && options === false) {\r\n    return null;\r\n  }\r\n  if (options === true) {\r\n    return {};\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\r\n  const result = [];\r\n  const context = chart.getContext();\r\n\r\n  for (const plugin of plugins) {\r\n    const id = plugin.id;\r\n    const opts = getOpts(options[id], all);\r\n    if (opts === null) {\r\n      continue;\r\n    }\r\n    result.push({\r\n      plugin,\r\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\r\n    });\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction pluginOpts(config, {plugin, local}, opts, context) {\r\n  const keys = config.pluginScopeKeys(plugin);\r\n  const scopes = config.getOptionScopes(opts, keys);\r\n  if (local && plugin.defaults) {\r\n    // make sure plugin defaults are in scopes for local (not registered) plugins\r\n    scopes.push(plugin.defaults);\r\n  }\r\n  return config.createResolver(scopes, context, [''], {\r\n    // These are just defaults that plugins can override\r\n    scriptable: false,\r\n    indexable: false,\r\n    allKeys: true\r\n  });\r\n}\r\n","import defaults, {overrides, descriptors} from './core.defaults.js';\r\nimport {mergeIf, resolveObjectKey, isArray, isFunction, valueOrDefault, isObject} from '../helpers/helpers.core.js';\r\nimport {_attachContext, _createResolver, _descriptors} from '../helpers/helpers.config.js';\r\n\r\nexport function getIndexAxis(type, options) {\r\n  const datasetDefaults = defaults.datasets[type] || {};\r\n  const datasetOptions = (options.datasets || {})[type] || {};\r\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\r\n}\r\n\r\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\r\n  let axis = id;\r\n  if (id === '_index_') {\r\n    axis = indexAxis;\r\n  } else if (id === '_value_') {\r\n    axis = indexAxis === 'x' ? 'y' : 'x';\r\n  }\r\n  return axis;\r\n}\r\n\r\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\r\n  return axis === indexAxis ? '_index_' : '_value_';\r\n}\r\n\r\nfunction idMatchesAxis(id) {\r\n  if (id === 'x' || id === 'y' || id === 'r') {\r\n    return id;\r\n  }\r\n}\r\n\r\nfunction axisFromPosition(position) {\r\n  if (position === 'top' || position === 'bottom') {\r\n    return 'x';\r\n  }\r\n  if (position === 'left' || position === 'right') {\r\n    return 'y';\r\n  }\r\n}\r\n\r\nexport function determineAxis(id, ...scaleOptions) {\r\n  if (idMatchesAxis(id)) {\r\n    return id;\r\n  }\r\n  for (const opts of scaleOptions) {\r\n    const axis = opts.axis\r\n      || axisFromPosition(opts.position)\r\n      || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\r\n    if (axis) {\r\n      return axis;\r\n    }\r\n  }\r\n  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\r\n}\r\n\r\nfunction getAxisFromDataset(id, axis, dataset) {\r\n  if (dataset[axis + 'AxisID'] === id) {\r\n    return {axis};\r\n  }\r\n}\r\n\r\nfunction retrieveAxisFromDatasets(id, config) {\r\n  if (config.data && config.data.datasets) {\r\n    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);\r\n    if (boundDs.length) {\r\n      return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\r\n    }\r\n  }\r\n  return {};\r\n}\r\n\r\nfunction mergeScaleConfig(config, options) {\r\n  const chartDefaults = overrides[config.type] || {scales: {}};\r\n  const configScales = options.scales || {};\r\n  const chartIndexAxis = getIndexAxis(config.type, options);\r\n  const scales = Object.create(null);\r\n\r\n  // First figure out first scale id's per axis.\r\n  Object.keys(configScales).forEach(id => {\r\n    const scaleConf = configScales[id];\r\n    if (!isObject(scaleConf)) {\r\n      return console.error(`Invalid scale configuration for scale: ${id}`);\r\n    }\r\n    if (scaleConf._proxy) {\r\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\r\n    }\r\n    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\r\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\r\n    const defaultScaleOptions = chartDefaults.scales || {};\r\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\r\n  });\r\n\r\n  // Then merge dataset defaults to scale configs\r\n  config.data.datasets.forEach(dataset => {\r\n    const type = dataset.type || config.type;\r\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\r\n    const datasetDefaults = overrides[type] || {};\r\n    const defaultScaleOptions = datasetDefaults.scales || {};\r\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\r\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\r\n      const id = dataset[axis + 'AxisID'] || axis;\r\n      scales[id] = scales[id] || Object.create(null);\r\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\r\n    });\r\n  });\r\n\r\n  // apply scale defaults, if not overridden by dataset defaults\r\n  Object.keys(scales).forEach(key => {\r\n    const scale = scales[key];\r\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\r\n  });\r\n\r\n  return scales;\r\n}\r\n\r\nfunction initOptions(config) {\r\n  const options = config.options || (config.options = {});\r\n\r\n  options.plugins = valueOrDefault(options.plugins, {});\r\n  options.scales = mergeScaleConfig(config, options);\r\n}\r\n\r\nfunction initData(data) {\r\n  data = data || {};\r\n  data.datasets = data.datasets || [];\r\n  data.labels = data.labels || [];\r\n  return data;\r\n}\r\n\r\nfunction initConfig(config) {\r\n  config = config || {};\r\n  config.data = initData(config.data);\r\n\r\n  initOptions(config);\r\n\r\n  return config;\r\n}\r\n\r\nconst keyCache = new Map();\r\nconst keysCached = new Set();\r\n\r\nfunction cachedKeys(cacheKey, generate) {\r\n  let keys = keyCache.get(cacheKey);\r\n  if (!keys) {\r\n    keys = generate();\r\n    keyCache.set(cacheKey, keys);\r\n    keysCached.add(keys);\r\n  }\r\n  return keys;\r\n}\r\n\r\nconst addIfFound = (set, obj, key) => {\r\n  const opts = resolveObjectKey(obj, key);\r\n  if (opts !== undefined) {\r\n    set.add(opts);\r\n  }\r\n};\r\n\r\nexport default class Config {\r\n  constructor(config) {\r\n    this._config = initConfig(config);\r\n    this._scopeCache = new Map();\r\n    this._resolverCache = new Map();\r\n  }\r\n\r\n  get platform() {\r\n    return this._config.platform;\r\n  }\r\n\r\n  get type() {\r\n    return this._config.type;\r\n  }\r\n\r\n  set type(type) {\r\n    this._config.type = type;\r\n  }\r\n\r\n  get data() {\r\n    return this._config.data;\r\n  }\r\n\r\n  set data(data) {\r\n    this._config.data = initData(data);\r\n  }\r\n\r\n  get options() {\r\n    return this._config.options;\r\n  }\r\n\r\n  set options(options) {\r\n    this._config.options = options;\r\n  }\r\n\r\n  get plugins() {\r\n    return this._config.plugins;\r\n  }\r\n\r\n  update() {\r\n    const config = this._config;\r\n    this.clearCache();\r\n    initOptions(config);\r\n  }\r\n\r\n  clearCache() {\r\n    this._scopeCache.clear();\r\n    this._resolverCache.clear();\r\n  }\r\n\r\n  /**\r\n   * Returns the option scope keys for resolving dataset options.\r\n   * These keys do not include the dataset itself, because it is not under options.\r\n   * @param {string} datasetType\r\n   * @return {string[][]}\r\n   */\r\n  datasetScopeKeys(datasetType) {\r\n    return cachedKeys(datasetType,\r\n      () => [[\r\n        `datasets.${datasetType}`,\r\n        ''\r\n      ]]);\r\n  }\r\n\r\n  /**\r\n   * Returns the option scope keys for resolving dataset animation options.\r\n   * These keys do not include the dataset itself, because it is not under options.\r\n   * @param {string} datasetType\r\n   * @param {string} transition\r\n   * @return {string[][]}\r\n   */\r\n  datasetAnimationScopeKeys(datasetType, transition) {\r\n    return cachedKeys(`${datasetType}.transition.${transition}`,\r\n      () => [\r\n        [\r\n          `datasets.${datasetType}.transitions.${transition}`,\r\n          `transitions.${transition}`,\r\n        ],\r\n        // The following are used for looking up the `animations` and `animation` keys\r\n        [\r\n          `datasets.${datasetType}`,\r\n          ''\r\n        ]\r\n      ]);\r\n  }\r\n\r\n  /**\r\n   * Returns the options scope keys for resolving element options that belong\r\n   * to an dataset. These keys do not include the dataset itself, because it\r\n   * is not under options.\r\n   * @param {string} datasetType\r\n   * @param {string} elementType\r\n   * @return {string[][]}\r\n   */\r\n  datasetElementScopeKeys(datasetType, elementType) {\r\n    return cachedKeys(`${datasetType}-${elementType}`,\r\n      () => [[\r\n        `datasets.${datasetType}.elements.${elementType}`,\r\n        `datasets.${datasetType}`,\r\n        `elements.${elementType}`,\r\n        ''\r\n      ]]);\r\n  }\r\n\r\n  /**\r\n   * Returns the options scope keys for resolving plugin options.\r\n   * @param {{id: string, additionalOptionScopes?: string[]}} plugin\r\n   * @return {string[][]}\r\n   */\r\n  pluginScopeKeys(plugin) {\r\n    const id = plugin.id;\r\n    const type = this.type;\r\n    return cachedKeys(`${type}-plugin-${id}`,\r\n      () => [[\r\n        `plugins.${id}`,\r\n        ...plugin.additionalOptionScopes || [],\r\n      ]]);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _cachedScopes(mainScope, resetCache) {\r\n    const _scopeCache = this._scopeCache;\r\n    let cache = _scopeCache.get(mainScope);\r\n    if (!cache || resetCache) {\r\n      cache = new Map();\r\n      _scopeCache.set(mainScope, cache);\r\n    }\r\n    return cache;\r\n  }\r\n\r\n  /**\r\n   * Resolves the objects from options and defaults for option value resolution.\r\n   * @param {object} mainScope - The main scope object for options\r\n   * @param {string[][]} keyLists - The arrays of keys in resolution order\r\n   * @param {boolean} [resetCache] - reset the cache for this mainScope\r\n   */\r\n  getOptionScopes(mainScope, keyLists, resetCache) {\r\n    const {options, type} = this;\r\n    const cache = this._cachedScopes(mainScope, resetCache);\r\n    const cached = cache.get(keyLists);\r\n    if (cached) {\r\n      return cached;\r\n    }\r\n\r\n    const scopes = new Set();\r\n\r\n    keyLists.forEach(keys => {\r\n      if (mainScope) {\r\n        scopes.add(mainScope);\r\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\r\n      }\r\n      keys.forEach(key => addIfFound(scopes, options, key));\r\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\r\n      keys.forEach(key => addIfFound(scopes, defaults, key));\r\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\r\n    });\r\n\r\n    const array = Array.from(scopes);\r\n    if (array.length === 0) {\r\n      array.push(Object.create(null));\r\n    }\r\n    if (keysCached.has(keyLists)) {\r\n      cache.set(keyLists, array);\r\n    }\r\n    return array;\r\n  }\r\n\r\n  /**\r\n   * Returns the option scopes for resolving chart options\r\n   * @return {object[]}\r\n   */\r\n  chartOptionScopes() {\r\n    const {options, type} = this;\r\n\r\n    return [\r\n      options,\r\n      overrides[type] || {},\r\n      defaults.datasets[type] || {}, // https://github.com/chartjs/Chart.js/issues/8531\r\n      {type},\r\n      defaults,\r\n      descriptors\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * @param {object[]} scopes\r\n   * @param {string[]} names\r\n   * @param {function|object} context\r\n   * @param {string[]} [prefixes]\r\n   * @return {object}\r\n   */\r\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\r\n    const result = {$shared: true};\r\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\r\n    let options = resolver;\r\n    if (needContext(resolver, names)) {\r\n      result.$shared = false;\r\n      context = isFunction(context) ? context() : context;\r\n      // subResolver is passed to scriptable options. It should not resolve to hover options.\r\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\r\n      options = _attachContext(resolver, context, subResolver);\r\n    }\r\n\r\n    for (const prop of names) {\r\n      result[prop] = options[prop];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * @param {object[]} scopes\r\n   * @param {object} [context]\r\n   * @param {string[]} [prefixes]\r\n   * @param {{scriptable: boolean, indexable: boolean, allKeys?: boolean}} [descriptorDefaults]\r\n   */\r\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\r\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\r\n    return isObject(context)\r\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\r\n      : resolver;\r\n  }\r\n}\r\n\r\nfunction getResolver(resolverCache, scopes, prefixes) {\r\n  let cache = resolverCache.get(scopes);\r\n  if (!cache) {\r\n    cache = new Map();\r\n    resolverCache.set(scopes, cache);\r\n  }\r\n  const cacheKey = prefixes.join();\r\n  let cached = cache.get(cacheKey);\r\n  if (!cached) {\r\n    const resolver = _createResolver(scopes, prefixes);\r\n    cached = {\r\n      resolver,\r\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\r\n    };\r\n    cache.set(cacheKey, cached);\r\n  }\r\n  return cached;\r\n}\r\n\r\nconst hasFunction = value => isObject(value)\r\n  && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);\r\n\r\nfunction needContext(proxy, names) {\r\n  const {isScriptable, isIndexable} = _descriptors(proxy);\r\n\r\n  for (const prop of names) {\r\n    const scriptable = isScriptable(prop);\r\n    const indexable = isIndexable(prop);\r\n    const value = (indexable || scriptable) && proxy[prop];\r\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\r\n      || (indexable && isArray(value))) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n","import animator from './core.animator.js';\r\nimport defaults, {overrides} from './core.defaults.js';\r\nimport Interaction from './core.interaction.js';\r\nimport layouts from './core.layouts.js';\r\nimport {_detectPlatform} from '../platform/index.js';\r\nimport PluginService from './core.plugins.js';\r\nimport registry from './core.registry.js';\r\nimport Config, {determineAxis, getIndexAxis} from './core.config.js';\r\nimport {retinaScale, _isDomSupported} from '../helpers/helpers.dom.js';\r\nimport {each, callback as callCallback, uid, valueOrDefault, _elementsEqual, isNullOrUndef, setsEqual, defined, isFunction, _isClickEvent} from '../helpers/helpers.core.js';\r\nimport {clearCanvas, clipArea, createContext, unclipArea, _isPointInArea} from '../helpers/index.js';\r\n// @ts-ignore\r\nimport {version} from '../../package.json';\r\nimport {debounce} from '../helpers/helpers.extras.js';\r\n\r\n/**\r\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\r\n * @typedef { import('../types/index.js').Point } Point\r\n */\r\n\r\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\r\nfunction positionIsHorizontal(position, axis) {\r\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\r\n}\r\n\r\nfunction compare2Level(l1, l2) {\r\n  return function(a, b) {\r\n    return a[l1] === b[l1]\r\n      ? a[l2] - b[l2]\r\n      : a[l1] - b[l1];\r\n  };\r\n}\r\n\r\nfunction onAnimationsComplete(context) {\r\n  const chart = context.chart;\r\n  const animationOptions = chart.options.animation;\r\n\r\n  chart.notifyPlugins('afterRender');\r\n  callCallback(animationOptions && animationOptions.onComplete, [context], chart);\r\n}\r\n\r\nfunction onAnimationProgress(context) {\r\n  const chart = context.chart;\r\n  const animationOptions = chart.options.animation;\r\n  callCallback(animationOptions && animationOptions.onProgress, [context], chart);\r\n}\r\n\r\n/**\r\n * Chart.js can take a string id of a canvas element, a 2d context, or a canvas element itself.\r\n * Attempt to unwrap the item passed into the chart constructor so that it is a canvas element (if possible).\r\n */\r\nfunction getCanvas(item) {\r\n  if (_isDomSupported() && typeof item === 'string') {\r\n    item = document.getElementById(item);\r\n  } else if (item && item.length) {\r\n    // Support for array based queries (such as jQuery)\r\n    item = item[0];\r\n  }\r\n\r\n  if (item && item.canvas) {\r\n    // Support for any object associated to a canvas (including a context2d)\r\n    item = item.canvas;\r\n  }\r\n  return item;\r\n}\r\n\r\nconst instances = {};\r\nconst getChart = (key) => {\r\n  const canvas = getCanvas(key);\r\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\r\n};\r\n\r\nfunction moveNumericKeys(obj, start, move) {\r\n  const keys = Object.keys(obj);\r\n  for (const key of keys) {\r\n    const intKey = +key;\r\n    if (intKey >= start) {\r\n      const value = obj[key];\r\n      delete obj[key];\r\n      if (move > 0 || intKey > start) {\r\n        obj[intKey + move] = value;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {ChartEvent} e\r\n * @param {ChartEvent|null} lastEvent\r\n * @param {boolean} inChartArea\r\n * @param {boolean} isClick\r\n * @returns {ChartEvent|null}\r\n */\r\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\r\n  if (!inChartArea || e.type === 'mouseout') {\r\n    return null;\r\n  }\r\n  if (isClick) {\r\n    return lastEvent;\r\n  }\r\n  return e;\r\n}\r\n\r\nfunction getDatasetArea(meta) {\r\n  const {xScale, yScale} = meta;\r\n  if (xScale && yScale) {\r\n    return {\r\n      left: xScale.left,\r\n      right: xScale.right,\r\n      top: yScale.top,\r\n      bottom: yScale.bottom\r\n    };\r\n  }\r\n}\r\n\r\nclass Chart {\r\n\r\n  static defaults = defaults;\r\n  static instances = instances;\r\n  static overrides = overrides;\r\n  static registry = registry;\r\n  static version = version;\r\n  static getChart = getChart;\r\n\r\n  static register(...items) {\r\n    registry.add(...items);\r\n    invalidatePlugins();\r\n  }\r\n\r\n  static unregister(...items) {\r\n    registry.remove(...items);\r\n    invalidatePlugins();\r\n  }\r\n\r\n  // eslint-disable-next-line max-statements\r\n  constructor(item, userConfig) {\r\n    const config = this.config = new Config(userConfig);\r\n    const initialCanvas = getCanvas(item);\r\n    const existingChart = getChart(initialCanvas);\r\n    if (existingChart) {\r\n      throw new Error(\r\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\r\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\r\n      );\r\n    }\r\n\r\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\r\n\r\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\r\n    this.platform.updateConfig(config);\r\n\r\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\r\n    const canvas = context && context.canvas;\r\n    const height = canvas && canvas.height;\r\n    const width = canvas && canvas.width;\r\n\r\n    this.id = uid();\r\n    this.ctx = context;\r\n    this.canvas = canvas;\r\n    this.width = width;\r\n    this.height = height;\r\n    this._options = options;\r\n    // Store the previously used aspect ratio to determine if a resize\r\n    // is needed during updates. Do this after _options is set since\r\n    // aspectRatio uses a getter\r\n    this._aspectRatio = this.aspectRatio;\r\n    this._layers = [];\r\n    this._metasets = [];\r\n    this._stacks = undefined;\r\n    this.boxes = [];\r\n    this.currentDevicePixelRatio = undefined;\r\n    this.chartArea = undefined;\r\n    this._active = [];\r\n    this._lastEvent = undefined;\r\n    this._listeners = {};\r\n    /** @type {?{attach?: function, detach?: function, resize?: function}} */\r\n    this._responsiveListeners = undefined;\r\n    this._sortedMetasets = [];\r\n    this.scales = {};\r\n    this._plugins = new PluginService();\r\n    this.$proxies = {};\r\n    this._hiddenIndices = {};\r\n    this.attached = false;\r\n    this._animationsDisabled = undefined;\r\n    this.$context = undefined;\r\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\r\n    this._dataChanges = [];\r\n\r\n    // Add the chart instance to the global namespace\r\n    instances[this.id] = this;\r\n\r\n    if (!context || !canvas) {\r\n      // The given item is not a compatible context2d element, let's return before finalizing\r\n      // the chart initialization but after setting basic chart / controller properties that\r\n      // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\r\n      // https://github.com/chartjs/Chart.js/issues/2807\r\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\r\n      return;\r\n    }\r\n\r\n    animator.listen(this, 'complete', onAnimationsComplete);\r\n    animator.listen(this, 'progress', onAnimationProgress);\r\n\r\n    this._initialize();\r\n    if (this.attached) {\r\n      this.update();\r\n    }\r\n  }\r\n\r\n  get aspectRatio() {\r\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\r\n    if (!isNullOrUndef(aspectRatio)) {\r\n      // If aspectRatio is defined in options, use that.\r\n      return aspectRatio;\r\n    }\r\n\r\n    if (maintainAspectRatio && _aspectRatio) {\r\n      // If maintainAspectRatio is truthly and we had previously determined _aspectRatio, use that\r\n      return _aspectRatio;\r\n    }\r\n\r\n    // Calculate\r\n    return height ? width / height : null;\r\n  }\r\n\r\n  get data() {\r\n    return this.config.data;\r\n  }\r\n\r\n  set data(data) {\r\n    this.config.data = data;\r\n  }\r\n\r\n  get options() {\r\n    return this._options;\r\n  }\r\n\r\n  set options(options) {\r\n    this.config.options = options;\r\n  }\r\n\r\n  get registry() {\r\n    return registry;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _initialize() {\r\n    // Before init plugin notification\r\n    this.notifyPlugins('beforeInit');\r\n\r\n    if (this.options.responsive) {\r\n      this.resize();\r\n    } else {\r\n      retinaScale(this, this.options.devicePixelRatio);\r\n    }\r\n\r\n    this.bindEvents();\r\n\r\n    // After init plugin notification\r\n    this.notifyPlugins('afterInit');\r\n\r\n    return this;\r\n  }\r\n\r\n  clear() {\r\n    clearCanvas(this.canvas, this.ctx);\r\n    return this;\r\n  }\r\n\r\n  stop() {\r\n    animator.stop(this);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n\t * Resize the chart to its container or to explicit dimensions.\r\n\t * @param {number} [width]\r\n\t * @param {number} [height]\r\n\t */\r\n  resize(width, height) {\r\n    if (!animator.running(this)) {\r\n      this._resize(width, height);\r\n    } else {\r\n      this._resizeBeforeDraw = {width, height};\r\n    }\r\n  }\r\n\r\n  _resize(width, height) {\r\n    const options = this.options;\r\n    const canvas = this.canvas;\r\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\r\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\r\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\r\n    const mode = this.width ? 'resize' : 'attach';\r\n\r\n    this.width = newSize.width;\r\n    this.height = newSize.height;\r\n    this._aspectRatio = this.aspectRatio;\r\n    if (!retinaScale(this, newRatio, true)) {\r\n      return;\r\n    }\r\n\r\n    this.notifyPlugins('resize', {size: newSize});\r\n\r\n    callCallback(options.onResize, [this, newSize], this);\r\n\r\n    if (this.attached) {\r\n      if (this._doResize(mode)) {\r\n        // The resize update is delayed, only draw without updating.\r\n        this.render();\r\n      }\r\n    }\r\n  }\r\n\r\n  ensureScalesHaveIDs() {\r\n    const options = this.options;\r\n    const scalesOptions = options.scales || {};\r\n\r\n    each(scalesOptions, (axisOptions, axisID) => {\r\n      axisOptions.id = axisID;\r\n    });\r\n  }\r\n\r\n  /**\r\n\t * Builds a map of scale ID to scale object for future lookup.\r\n\t */\r\n  buildOrUpdateScales() {\r\n    const options = this.options;\r\n    const scaleOpts = options.scales;\r\n    const scales = this.scales;\r\n    const updated = Object.keys(scales).reduce((obj, id) => {\r\n      obj[id] = false;\r\n      return obj;\r\n    }, {});\r\n    let items = [];\r\n\r\n    if (scaleOpts) {\r\n      items = items.concat(\r\n        Object.keys(scaleOpts).map((id) => {\r\n          const scaleOptions = scaleOpts[id];\r\n          const axis = determineAxis(id, scaleOptions);\r\n          const isRadial = axis === 'r';\r\n          const isHorizontal = axis === 'x';\r\n          return {\r\n            options: scaleOptions,\r\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\r\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\r\n          };\r\n        })\r\n      );\r\n    }\r\n\r\n    each(items, (item) => {\r\n      const scaleOptions = item.options;\r\n      const id = scaleOptions.id;\r\n      const axis = determineAxis(id, scaleOptions);\r\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\r\n\r\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\r\n        scaleOptions.position = item.dposition;\r\n      }\r\n\r\n      updated[id] = true;\r\n      let scale = null;\r\n      if (id in scales && scales[id].type === scaleType) {\r\n        scale = scales[id];\r\n      } else {\r\n        const scaleClass = registry.getScale(scaleType);\r\n        scale = new scaleClass({\r\n          id,\r\n          type: scaleType,\r\n          ctx: this.ctx,\r\n          chart: this\r\n        });\r\n        scales[scale.id] = scale;\r\n      }\r\n\r\n      scale.init(scaleOptions, options);\r\n    });\r\n    // clear up discarded scales\r\n    each(updated, (hasUpdated, id) => {\r\n      if (!hasUpdated) {\r\n        delete scales[id];\r\n      }\r\n    });\r\n\r\n    each(scales, (scale) => {\r\n      layouts.configure(this, scale, scale.options);\r\n      layouts.addBox(this, scale);\r\n    });\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _updateMetasets() {\r\n    const metasets = this._metasets;\r\n    const numData = this.data.datasets.length;\r\n    const numMeta = metasets.length;\r\n\r\n    metasets.sort((a, b) => a.index - b.index);\r\n    if (numMeta > numData) {\r\n      for (let i = numData; i < numMeta; ++i) {\r\n        this._destroyDatasetMeta(i);\r\n      }\r\n      metasets.splice(numData, numMeta - numData);\r\n    }\r\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _removeUnreferencedMetasets() {\r\n    const {_metasets: metasets, data: {datasets}} = this;\r\n    if (metasets.length > datasets.length) {\r\n      delete this._stacks;\r\n    }\r\n    metasets.forEach((meta, index) => {\r\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\r\n        this._destroyDatasetMeta(index);\r\n      }\r\n    });\r\n  }\r\n\r\n  buildOrUpdateControllers() {\r\n    const newControllers = [];\r\n    const datasets = this.data.datasets;\r\n    let i, ilen;\r\n\r\n    this._removeUnreferencedMetasets();\r\n\r\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\r\n      const dataset = datasets[i];\r\n      let meta = this.getDatasetMeta(i);\r\n      const type = dataset.type || this.config.type;\r\n\r\n      if (meta.type && meta.type !== type) {\r\n        this._destroyDatasetMeta(i);\r\n        meta = this.getDatasetMeta(i);\r\n      }\r\n      meta.type = type;\r\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\r\n      meta.order = dataset.order || 0;\r\n      meta.index = i;\r\n      meta.label = '' + dataset.label;\r\n      meta.visible = this.isDatasetVisible(i);\r\n\r\n      if (meta.controller) {\r\n        meta.controller.updateIndex(i);\r\n        meta.controller.linkScales();\r\n      } else {\r\n        const ControllerClass = registry.getController(type);\r\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\r\n        Object.assign(ControllerClass, {\r\n          dataElementType: registry.getElement(dataElementType),\r\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\r\n        });\r\n        meta.controller = new ControllerClass(this, i);\r\n        newControllers.push(meta.controller);\r\n      }\r\n    }\r\n\r\n    this._updateMetasets();\r\n    return newControllers;\r\n  }\r\n\r\n  /**\r\n\t * Reset the elements of all datasets\r\n\t * @private\r\n\t */\r\n  _resetElements() {\r\n    each(this.data.datasets, (dataset, datasetIndex) => {\r\n      this.getDatasetMeta(datasetIndex).controller.reset();\r\n    }, this);\r\n  }\r\n\r\n  /**\r\n\t* Resets the chart back to its state before the initial animation\r\n\t*/\r\n  reset() {\r\n    this._resetElements();\r\n    this.notifyPlugins('reset');\r\n  }\r\n\r\n  update(mode) {\r\n    const config = this.config;\r\n\r\n    config.update();\r\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\r\n    const animsDisabled = this._animationsDisabled = !options.animation;\r\n\r\n    this._updateScales();\r\n    this._checkEventBindings();\r\n    this._updateHiddenIndices();\r\n\r\n    // plugins options references might have change, let's invalidate the cache\r\n    // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\r\n    this._plugins.invalidate();\r\n\r\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\r\n      return;\r\n    }\r\n\r\n    // Make sure dataset controllers are updated and new controllers are reset\r\n    const newControllers = this.buildOrUpdateControllers();\r\n\r\n    this.notifyPlugins('beforeElementsUpdate');\r\n\r\n    // Make sure all dataset controllers have correct meta data counts\r\n    let minPadding = 0;\r\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\r\n      const {controller} = this.getDatasetMeta(i);\r\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\r\n      // New controllers will be reset after the layout pass, so we only want to modify\r\n      // elements added to new datasets\r\n      controller.buildOrUpdateElements(reset);\r\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\r\n    }\r\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\r\n    this._updateLayout(minPadding);\r\n\r\n    // Only reset the controllers if we have animations\r\n    if (!animsDisabled) {\r\n      // Can only reset the new controllers after the scales have been updated\r\n      // Reset is done to get the starting point for the initial animation\r\n      each(newControllers, (controller) => {\r\n        controller.reset();\r\n      });\r\n    }\r\n\r\n    this._updateDatasets(mode);\r\n\r\n    // Do this before render so that any plugins that need final scale updates can use it\r\n    this.notifyPlugins('afterUpdate', {mode});\r\n\r\n    this._layers.sort(compare2Level('z', '_idx'));\r\n\r\n    // Replay last event from before update, or set hover styles on active elements\r\n    const {_active, _lastEvent} = this;\r\n    if (_lastEvent) {\r\n      this._eventHandler(_lastEvent, true);\r\n    } else if (_active.length) {\r\n      this._updateHoverStyles(_active, _active, true);\r\n    }\r\n\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _updateScales() {\r\n    each(this.scales, (scale) => {\r\n      layouts.removeBox(this, scale);\r\n    });\r\n\r\n    this.ensureScalesHaveIDs();\r\n    this.buildOrUpdateScales();\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _checkEventBindings() {\r\n    const options = this.options;\r\n    const existingEvents = new Set(Object.keys(this._listeners));\r\n    const newEvents = new Set(options.events);\r\n\r\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\r\n      // The configured events have changed. Rebind.\r\n      this.unbindEvents();\r\n      this.bindEvents();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _updateHiddenIndices() {\r\n    const {_hiddenIndices} = this;\r\n    const changes = this._getUniformDataChanges() || [];\r\n    for (const {method, start, count} of changes) {\r\n      const move = method === '_removeElements' ? -count : count;\r\n      moveNumericKeys(_hiddenIndices, start, move);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _getUniformDataChanges() {\r\n    const _dataChanges = this._dataChanges;\r\n    if (!_dataChanges || !_dataChanges.length) {\r\n      return;\r\n    }\r\n\r\n    this._dataChanges = [];\r\n    const datasetCount = this.data.datasets.length;\r\n    const makeSet = (idx) => new Set(\r\n      _dataChanges\r\n        .filter(c => c[0] === idx)\r\n        .map((c, i) => i + ',' + c.splice(1).join(','))\r\n    );\r\n\r\n    const changeSet = makeSet(0);\r\n    for (let i = 1; i < datasetCount; i++) {\r\n      if (!setsEqual(changeSet, makeSet(i))) {\r\n        return;\r\n      }\r\n    }\r\n    return Array.from(changeSet)\r\n      .map(c => c.split(','))\r\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\r\n  }\r\n\r\n  /**\r\n\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\r\n\t * hook, in which case, plugins will not be called on `afterLayout`.\r\n\t * @private\r\n\t */\r\n  _updateLayout(minPadding) {\r\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\r\n      return;\r\n    }\r\n\r\n    layouts.update(this, this.width, this.height, minPadding);\r\n\r\n    const area = this.chartArea;\r\n    const noArea = area.width <= 0 || area.height <= 0;\r\n\r\n    this._layers = [];\r\n    each(this.boxes, (box) => {\r\n      if (noArea && box.position === 'chartArea') {\r\n        // Skip drawing and configuring chartArea boxes when chartArea is zero or negative\r\n        return;\r\n      }\r\n\r\n      // configure is called twice, once in core.scale.update and once here.\r\n      // Here the boxes are fully updated and at their final positions.\r\n      if (box.configure) {\r\n        box.configure();\r\n      }\r\n      this._layers.push(...box._layers());\r\n    }, this);\r\n\r\n    this._layers.forEach((item, index) => {\r\n      item._idx = index;\r\n    });\r\n\r\n    this.notifyPlugins('afterLayout');\r\n  }\r\n\r\n  /**\r\n\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\r\n\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\r\n\t * @private\r\n\t */\r\n  _updateDatasets(mode) {\r\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\r\n      return;\r\n    }\r\n\r\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\r\n      this.getDatasetMeta(i).controller.configure();\r\n    }\r\n\r\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\r\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\r\n    }\r\n\r\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\r\n  }\r\n\r\n  /**\r\n\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\r\n\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\r\n\t * @private\r\n\t */\r\n  _updateDataset(index, mode) {\r\n    const meta = this.getDatasetMeta(index);\r\n    const args = {meta, index, mode, cancelable: true};\r\n\r\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\r\n      return;\r\n    }\r\n\r\n    meta.controller._update(mode);\r\n\r\n    args.cancelable = false;\r\n    this.notifyPlugins('afterDatasetUpdate', args);\r\n  }\r\n\r\n  render() {\r\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\r\n      return;\r\n    }\r\n\r\n    if (animator.has(this)) {\r\n      if (this.attached && !animator.running(this)) {\r\n        animator.start(this);\r\n      }\r\n    } else {\r\n      this.draw();\r\n      onAnimationsComplete({chart: this});\r\n    }\r\n  }\r\n\r\n  draw() {\r\n    let i;\r\n    if (this._resizeBeforeDraw) {\r\n      const {width, height} = this._resizeBeforeDraw;\r\n      this._resize(width, height);\r\n      this._resizeBeforeDraw = null;\r\n    }\r\n    this.clear();\r\n\r\n    if (this.width <= 0 || this.height <= 0) {\r\n      return;\r\n    }\r\n\r\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\r\n      return;\r\n    }\r\n\r\n    // Because of plugin hooks (before/afterDatasetsDraw), datasets can't\r\n    // currently be part of layers. Instead, we draw\r\n    // layers <= 0 before(default, backward compat), and the rest after\r\n    const layers = this._layers;\r\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\r\n      layers[i].draw(this.chartArea);\r\n    }\r\n\r\n    this._drawDatasets();\r\n\r\n    // Rest of layers\r\n    for (; i < layers.length; ++i) {\r\n      layers[i].draw(this.chartArea);\r\n    }\r\n\r\n    this.notifyPlugins('afterDraw');\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getSortedDatasetMetas(filterVisible) {\r\n    const metasets = this._sortedMetasets;\r\n    const result = [];\r\n    let i, ilen;\r\n\r\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n      const meta = metasets[i];\r\n      if (!filterVisible || meta.visible) {\r\n        result.push(meta);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n\t * Gets the visible dataset metas in drawing order\r\n\t * @return {object[]}\r\n\t */\r\n  getSortedVisibleDatasetMetas() {\r\n    return this._getSortedDatasetMetas(true);\r\n  }\r\n\r\n  /**\r\n\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\r\n\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\r\n\t * @private\r\n\t */\r\n  _drawDatasets() {\r\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\r\n      return;\r\n    }\r\n\r\n    const metasets = this.getSortedVisibleDatasetMetas();\r\n    for (let i = metasets.length - 1; i >= 0; --i) {\r\n      this._drawDataset(metasets[i]);\r\n    }\r\n\r\n    this.notifyPlugins('afterDatasetsDraw');\r\n  }\r\n\r\n  /**\r\n\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\r\n\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\r\n\t * @private\r\n\t */\r\n  _drawDataset(meta) {\r\n    const ctx = this.ctx;\r\n    const clip = meta._clip;\r\n    const useClip = !clip.disabled;\r\n    const area = getDatasetArea(meta) || this.chartArea;\r\n    const args = {\r\n      meta,\r\n      index: meta.index,\r\n      cancelable: true\r\n    };\r\n\r\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\r\n      return;\r\n    }\r\n\r\n    if (useClip) {\r\n      clipArea(ctx, {\r\n        left: clip.left === false ? 0 : area.left - clip.left,\r\n        right: clip.right === false ? this.width : area.right + clip.right,\r\n        top: clip.top === false ? 0 : area.top - clip.top,\r\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\r\n      });\r\n    }\r\n\r\n    meta.controller.draw();\r\n\r\n    if (useClip) {\r\n      unclipArea(ctx);\r\n    }\r\n\r\n    args.cancelable = false;\r\n    this.notifyPlugins('afterDatasetDraw', args);\r\n  }\r\n\r\n  /**\r\n   * Checks whether the given point is in the chart area.\r\n   * @param {Point} point - in relative coordinates (see, e.g., getRelativePosition)\r\n   * @returns {boolean}\r\n   */\r\n  isPointInArea(point) {\r\n    return _isPointInArea(point, this.chartArea, this._minPadding);\r\n  }\r\n\r\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\r\n    const method = Interaction.modes[mode];\r\n    if (typeof method === 'function') {\r\n      return method(this, e, options, useFinalPosition);\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  getDatasetMeta(datasetIndex) {\r\n    const dataset = this.data.datasets[datasetIndex];\r\n    const metasets = this._metasets;\r\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\r\n\r\n    if (!meta) {\r\n      meta = {\r\n        type: null,\r\n        data: [],\r\n        dataset: null,\r\n        controller: null,\r\n        hidden: null,\t\t\t// See isDatasetVisible() comment\r\n        xAxisID: null,\r\n        yAxisID: null,\r\n        order: dataset && dataset.order || 0,\r\n        index: datasetIndex,\r\n        _dataset: dataset,\r\n        _parsed: [],\r\n        _sorted: false\r\n      };\r\n      metasets.push(meta);\r\n    }\r\n\r\n    return meta;\r\n  }\r\n\r\n  getContext() {\r\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\r\n  }\r\n\r\n  getVisibleDatasetCount() {\r\n    return this.getSortedVisibleDatasetMetas().length;\r\n  }\r\n\r\n  isDatasetVisible(datasetIndex) {\r\n    const dataset = this.data.datasets[datasetIndex];\r\n    if (!dataset) {\r\n      return false;\r\n    }\r\n\r\n    const meta = this.getDatasetMeta(datasetIndex);\r\n\r\n    // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\r\n    // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\r\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\r\n  }\r\n\r\n  setDatasetVisibility(datasetIndex, visible) {\r\n    const meta = this.getDatasetMeta(datasetIndex);\r\n    meta.hidden = !visible;\r\n  }\r\n\r\n  toggleDataVisibility(index) {\r\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\r\n  }\r\n\r\n  getDataVisibility(index) {\r\n    return !this._hiddenIndices[index];\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _updateVisibility(datasetIndex, dataIndex, visible) {\r\n    const mode = visible ? 'show' : 'hide';\r\n    const meta = this.getDatasetMeta(datasetIndex);\r\n    const anims = meta.controller._resolveAnimations(undefined, mode);\r\n\r\n    if (defined(dataIndex)) {\r\n      meta.data[dataIndex].hidden = !visible;\r\n      this.update();\r\n    } else {\r\n      this.setDatasetVisibility(datasetIndex, visible);\r\n      // Animate visible state, so hide animation can be seen. This could be handled better if update / updateDataset returned a Promise.\r\n      anims.update(meta, {visible});\r\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\r\n    }\r\n  }\r\n\r\n  hide(datasetIndex, dataIndex) {\r\n    this._updateVisibility(datasetIndex, dataIndex, false);\r\n  }\r\n\r\n  show(datasetIndex, dataIndex) {\r\n    this._updateVisibility(datasetIndex, dataIndex, true);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _destroyDatasetMeta(datasetIndex) {\r\n    const meta = this._metasets[datasetIndex];\r\n    if (meta && meta.controller) {\r\n      meta.controller._destroy();\r\n    }\r\n    delete this._metasets[datasetIndex];\r\n  }\r\n\r\n  _stop() {\r\n    let i, ilen;\r\n    this.stop();\r\n    animator.remove(this);\r\n\r\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\r\n      this._destroyDatasetMeta(i);\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    this.notifyPlugins('beforeDestroy');\r\n    const {canvas, ctx} = this;\r\n\r\n    this._stop();\r\n    this.config.clearCache();\r\n\r\n    if (canvas) {\r\n      this.unbindEvents();\r\n      clearCanvas(canvas, ctx);\r\n      this.platform.releaseContext(ctx);\r\n      this.canvas = null;\r\n      this.ctx = null;\r\n    }\r\n\r\n    delete instances[this.id];\r\n\r\n    this.notifyPlugins('afterDestroy');\r\n  }\r\n\r\n  toBase64Image(...args) {\r\n    return this.canvas.toDataURL(...args);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  bindEvents() {\r\n    this.bindUserEvents();\r\n    if (this.options.responsive) {\r\n      this.bindResponsiveEvents();\r\n    } else {\r\n      this.attached = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  bindUserEvents() {\r\n    const listeners = this._listeners;\r\n    const platform = this.platform;\r\n\r\n    const _add = (type, listener) => {\r\n      platform.addEventListener(this, type, listener);\r\n      listeners[type] = listener;\r\n    };\r\n\r\n    const listener = (e, x, y) => {\r\n      e.offsetX = x;\r\n      e.offsetY = y;\r\n      this._eventHandler(e);\r\n    };\r\n\r\n    each(this.options.events, (type) => _add(type, listener));\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  bindResponsiveEvents() {\r\n    if (!this._responsiveListeners) {\r\n      this._responsiveListeners = {};\r\n    }\r\n    const listeners = this._responsiveListeners;\r\n    const platform = this.platform;\r\n\r\n    const _add = (type, listener) => {\r\n      platform.addEventListener(this, type, listener);\r\n      listeners[type] = listener;\r\n    };\r\n    const _remove = (type, listener) => {\r\n      if (listeners[type]) {\r\n        platform.removeEventListener(this, type, listener);\r\n        delete listeners[type];\r\n      }\r\n    };\r\n\r\n    const listener = (width, height) => {\r\n      if (this.canvas) {\r\n        this.resize(width, height);\r\n      }\r\n    };\r\n\r\n    let detached; // eslint-disable-line prefer-const\r\n    const attached = () => {\r\n      _remove('attach', attached);\r\n\r\n      this.attached = true;\r\n      this.resize();\r\n\r\n      _add('resize', listener);\r\n      _add('detach', detached);\r\n    };\r\n\r\n    detached = () => {\r\n      this.attached = false;\r\n\r\n      _remove('resize', listener);\r\n\r\n      // Stop animating and remove metasets, so when re-attached, the animations start from beginning.\r\n      this._stop();\r\n      this._resize(0, 0);\r\n\r\n      _add('attach', attached);\r\n    };\r\n\r\n    if (platform.isAttached(this.canvas)) {\r\n      attached();\r\n    } else {\r\n      detached();\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  unbindEvents() {\r\n    each(this._listeners, (listener, type) => {\r\n      this.platform.removeEventListener(this, type, listener);\r\n    });\r\n    this._listeners = {};\r\n\r\n    each(this._responsiveListeners, (listener, type) => {\r\n      this.platform.removeEventListener(this, type, listener);\r\n    });\r\n    this._responsiveListeners = undefined;\r\n  }\r\n\r\n  updateHoverStyle(items, mode, enabled) {\r\n    const prefix = enabled ? 'set' : 'remove';\r\n    let meta, item, i, ilen;\r\n\r\n    if (mode === 'dataset') {\r\n      meta = this.getDatasetMeta(items[0].datasetIndex);\r\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\r\n    }\r\n\r\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n      item = items[i];\r\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\r\n      if (controller) {\r\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Get active (hovered) elements\r\n\t * @returns array\r\n\t */\r\n  getActiveElements() {\r\n    return this._active || [];\r\n  }\r\n\r\n  /**\r\n\t * Set active (hovered) elements\r\n\t * @param {array} activeElements New active data points\r\n\t */\r\n  setActiveElements(activeElements) {\r\n    const lastActive = this._active || [];\r\n    const active = activeElements.map(({datasetIndex, index}) => {\r\n      const meta = this.getDatasetMeta(datasetIndex);\r\n      if (!meta) {\r\n        throw new Error('No dataset found at index ' + datasetIndex);\r\n      }\r\n\r\n      return {\r\n        datasetIndex,\r\n        element: meta.data[index],\r\n        index,\r\n      };\r\n    });\r\n    const changed = !_elementsEqual(active, lastActive);\r\n\r\n    if (changed) {\r\n      this._active = active;\r\n      // Make sure we don't use the previous mouse event to override the active elements in update.\r\n      this._lastEvent = null;\r\n      this._updateHoverStyles(active, lastActive);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Calls enabled plugins on the specified hook and with the given args.\r\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\r\n\t * returned value can be used, for instance, to interrupt the current action.\r\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\r\n\t * @param {Object} [args] - Extra arguments to apply to the hook call.\r\n   * @param {import('./core.plugins.js').filterCallback} [filter] - Filtering function for limiting which plugins are notified\r\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\r\n\t */\r\n  notifyPlugins(hook, args, filter) {\r\n    return this._plugins.notify(this, hook, args, filter);\r\n  }\r\n\r\n  /**\r\n   * Check if a plugin with the specific ID is registered and enabled\r\n   * @param {string} pluginId - The ID of the plugin of which to check if it is enabled\r\n   * @returns {boolean}\r\n   */\r\n  isPluginEnabled(pluginId) {\r\n    return this._plugins._cache.filter(p => p.plugin.id === pluginId).length === 1;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _updateHoverStyles(active, lastActive, replay) {\r\n    const hoverOptions = this.options.hover;\r\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\r\n    const deactivated = diff(lastActive, active);\r\n    const activated = replay ? active : diff(active, lastActive);\r\n\r\n    if (deactivated.length) {\r\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\r\n    }\r\n\r\n    if (activated.length && hoverOptions.mode) {\r\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _eventHandler(e, replay) {\r\n    const args = {\r\n      event: e,\r\n      replay,\r\n      cancelable: true,\r\n      inChartArea: this.isPointInArea(e)\r\n    };\r\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\r\n\r\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\r\n      return;\r\n    }\r\n\r\n    const changed = this._handleEvent(e, replay, args.inChartArea);\r\n\r\n    args.cancelable = false;\r\n    this.notifyPlugins('afterEvent', args, eventFilter);\r\n\r\n    if (changed || args.changed) {\r\n      this.render();\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n\t * Handle an event\r\n\t * @param {ChartEvent} e the event to handle\r\n\t * @param {boolean} [replay] - true if the event was replayed by `update`\r\n   * @param {boolean} [inChartArea] - true if the event is inside chartArea\r\n\t * @return {boolean} true if the chart needs to re-render\r\n\t * @private\r\n\t */\r\n  _handleEvent(e, replay, inChartArea) {\r\n    const {_active: lastActive = [], options} = this;\r\n\r\n    // If the event is replayed from `update`, we should evaluate with the final positions.\r\n    //\r\n    // The `replay`:\r\n    // It's the last event (excluding click) that has occurred before `update`.\r\n    // So mouse has not moved. It's also over the chart, because there is a `replay`.\r\n    //\r\n    // The why:\r\n    // If animations are active, the elements haven't moved yet compared to state before update.\r\n    // But if they will, we are activating the elements that would be active, if this check\r\n    // was done after the animations have completed. => \"final positions\".\r\n    // If there is no animations, the \"final\" and \"current\" positions are equal.\r\n    // This is done so we do not have to evaluate the active elements each animation frame\r\n    // - it would be expensive.\r\n    const useFinalPosition = replay;\r\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\r\n    const isClick = _isClickEvent(e);\r\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\r\n\r\n    if (inChartArea) {\r\n      // Set _lastEvent to null while we are processing the event handlers.\r\n      // This prevents recursion if the handler calls chart.update()\r\n      this._lastEvent = null;\r\n\r\n      // Invoke onHover hook\r\n      callCallback(options.onHover, [e, active, this], this);\r\n\r\n      if (isClick) {\r\n        callCallback(options.onClick, [e, active, this], this);\r\n      }\r\n    }\r\n\r\n    const changed = !_elementsEqual(active, lastActive);\r\n    if (changed || replay) {\r\n      this._active = active;\r\n      this._updateHoverStyles(active, lastActive, replay);\r\n    }\r\n\r\n    this._lastEvent = lastEvent;\r\n\r\n    return changed;\r\n  }\r\n\r\n  /**\r\n   * @param {ChartEvent} e - The event\r\n   * @param {import('../types/index.js').ActiveElement[]} lastActive - Previously active elements\r\n   * @param {boolean} inChartArea - Is the envent inside chartArea\r\n   * @param {boolean} useFinalPosition - Should the evaluation be done with current or final (after animation) element positions\r\n   * @returns {import('../types/index.js').ActiveElement[]} - The active elements\r\n   * @pravate\r\n   */\r\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\r\n    if (e.type === 'mouseout') {\r\n      return [];\r\n    }\r\n\r\n    if (!inChartArea) {\r\n      // Let user control the active elements outside chartArea. Eg. using Legend.\r\n      return lastActive;\r\n    }\r\n\r\n    const hoverOptions = this.options.hover;\r\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\r\n  }\r\n}\r\n\r\n// @ts-ignore\r\nfunction invalidatePlugins() {\r\n  return each(Chart.instances, (chart) => chart._plugins.invalidate());\r\n}\r\n\r\nexport default Chart;\r\n","/**\r\n * @namespace Chart._adapters\r\n * @since 2.8.0\r\n * @private\r\n */\r\n\r\nimport type {AnyObject} from '../types/basic.js';\r\nimport type {ChartOptions} from '../types/index.js';\r\n\r\nexport type TimeUnit = 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';\r\n\r\nexport interface DateAdapter<T extends AnyObject = AnyObject> {\r\n  readonly options: T;\r\n  /**\r\n   * Will called with chart options after adapter creation.\r\n   */\r\n  init(this: DateAdapter<T>, chartOptions: ChartOptions): void;\r\n  /**\r\n   * Returns a map of time formats for the supported formatting units defined\r\n   * in Unit as well as 'datetime' representing a detailed date/time string.\r\n   */\r\n  formats(this: DateAdapter<T>): Record<string, string>;\r\n  /**\r\n   * Parses the given `value` and return the associated timestamp.\r\n   * @param value - the value to parse (usually comes from the data)\r\n   * @param [format] - the expected data format\r\n   */\r\n  parse(this: DateAdapter<T>, value: unknown, format?: TimeUnit): number | null;\r\n  /**\r\n   * Returns the formatted date in the specified `format` for a given `timestamp`.\r\n   * @param timestamp - the timestamp to format\r\n   * @param format - the date/time token\r\n   */\r\n  format(this: DateAdapter<T>, timestamp: number, format: TimeUnit): string;\r\n  /**\r\n   * Adds the specified `amount` of `unit` to the given `timestamp`.\r\n   * @param timestamp - the input timestamp\r\n   * @param amount - the amount to add\r\n   * @param unit - the unit as string\r\n   */\r\n  add(this: DateAdapter<T>, timestamp: number, amount: number, unit: TimeUnit): number;\r\n  /**\r\n   * Returns the number of `unit` between the given timestamps.\r\n   * @param a - the input timestamp (reference)\r\n   * @param b - the timestamp to subtract\r\n   * @param unit - the unit as string\r\n   */\r\n  diff(this: DateAdapter<T>, a: number, b: number, unit: TimeUnit): number;\r\n  /**\r\n   * Returns start of `unit` for the given `timestamp`.\r\n   * @param timestamp - the input timestamp\r\n   * @param unit - the unit as string\r\n   * @param [weekday] - the ISO day of the week with 1 being Monday\r\n   * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\r\n   */\r\n  startOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek', weekday?: number): number;\r\n  /**\r\n   * Returns end of `unit` for the given `timestamp`.\r\n   * @param timestamp - the input timestamp\r\n   * @param unit - the unit as string\r\n   */\r\n  endOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek'): number;\r\n}\r\n\r\nfunction abstract<T = void>(): T {\r\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\r\n}\r\n\r\n/**\r\n * Date adapter (current used by the time scale)\r\n * @namespace Chart._adapters._date\r\n * @memberof Chart._adapters\r\n * @private\r\n */\r\nclass DateAdapterBase implements DateAdapter {\r\n\r\n  /**\r\n   * Override default date adapter methods.\r\n   * Accepts type parameter to define options type.\r\n   * @example\r\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\r\n   *   init() {\r\n   *     console.log(this.options.myAdapterOption);\r\n   *   }\r\n   * })\r\n   */\r\n  static override<T extends AnyObject = AnyObject>(\r\n    members: Partial<Omit<DateAdapter<T>, 'options'>>\r\n  ) {\r\n    Object.assign(DateAdapterBase.prototype, members);\r\n  }\r\n\r\n  readonly options: AnyObject;\r\n\r\n  constructor(options: AnyObject) {\r\n    this.options = options || {};\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n  init() {}\r\n\r\n  formats(): Record<string, string> {\r\n    return abstract();\r\n  }\r\n\r\n  parse(): number | null {\r\n    return abstract();\r\n  }\r\n\r\n  format(): string {\r\n    return abstract();\r\n  }\r\n\r\n  add(): number {\r\n    return abstract();\r\n  }\r\n\r\n  diff(): number {\r\n    return abstract();\r\n  }\r\n\r\n  startOf(): number {\r\n    return abstract();\r\n  }\r\n\r\n  endOf(): number {\r\n    return abstract();\r\n  }\r\n}\r\n\r\nexport default {\r\n  _date: DateAdapterBase\r\n};\r\n","import DatasetController from '../core/core.datasetController.js';\r\nimport {\r\n  _arrayUnique, isArray, isNullOrUndef,\r\n  valueOrDefault, resolveObjectKey, sign, defined\r\n} from '../helpers/index.js';\r\n\r\nfunction getAllScaleValues(scale, type) {\r\n  if (!scale._cache.$bar) {\r\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\r\n    let values = [];\r\n\r\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\r\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\r\n    }\r\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\r\n  }\r\n  return scale._cache.$bar;\r\n}\r\n\r\n/**\r\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\r\n * @private\r\n */\r\nfunction computeMinSampleSize(meta) {\r\n  const scale = meta.iScale;\r\n  const values = getAllScaleValues(scale, meta.type);\r\n  let min = scale._length;\r\n  let i, ilen, curr, prev;\r\n  const updateMinAndPrev = () => {\r\n    if (curr === 32767 || curr === -32768) {\r\n      // Ignore truncated pixels\r\n      return;\r\n    }\r\n    if (defined(prev)) {\r\n      // curr - prev === 0 is ignored\r\n      min = Math.min(min, Math.abs(curr - prev) || min);\r\n    }\r\n    prev = curr;\r\n  };\r\n\r\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\r\n    curr = scale.getPixelForValue(values[i]);\r\n    updateMinAndPrev();\r\n  }\r\n\r\n  prev = undefined;\r\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\r\n    curr = scale.getPixelForTick(i);\r\n    updateMinAndPrev();\r\n  }\r\n\r\n  return min;\r\n}\r\n\r\n/**\r\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\r\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\r\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\r\n * @private\r\n */\r\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\r\n  const thickness = options.barThickness;\r\n  let size, ratio;\r\n\r\n  if (isNullOrUndef(thickness)) {\r\n    size = ruler.min * options.categoryPercentage;\r\n    ratio = options.barPercentage;\r\n  } else {\r\n    // When bar thickness is enforced, category and bar percentages are ignored.\r\n    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\r\n    // and deprecate barPercentage since this value is ignored when thickness is absolute.\r\n    size = thickness * stackCount;\r\n    ratio = 1;\r\n  }\r\n\r\n  return {\r\n    chunk: size / stackCount,\r\n    ratio,\r\n    start: ruler.pixels[index] - (size / 2)\r\n  };\r\n}\r\n\r\n/**\r\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\r\n * percentage options are 1), based on the previous and following categories. This mode\r\n * generates bars with different widths when data are not evenly spaced.\r\n * @private\r\n */\r\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\r\n  const pixels = ruler.pixels;\r\n  const curr = pixels[index];\r\n  let prev = index > 0 ? pixels[index - 1] : null;\r\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\r\n  const percent = options.categoryPercentage;\r\n\r\n  if (prev === null) {\r\n    // first data: its size is double based on the next point or,\r\n    // if it's also the last data, we use the scale size.\r\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\r\n  }\r\n\r\n  if (next === null) {\r\n    // last data: its size is also double based on the previous point.\r\n    next = curr + curr - prev;\r\n  }\r\n\r\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\r\n  const size = Math.abs(next - prev) / 2 * percent;\r\n\r\n  return {\r\n    chunk: size / stackCount,\r\n    ratio: options.barPercentage,\r\n    start\r\n  };\r\n}\r\n\r\nfunction parseFloatBar(entry, item, vScale, i) {\r\n  const startValue = vScale.parse(entry[0], i);\r\n  const endValue = vScale.parse(entry[1], i);\r\n  const min = Math.min(startValue, endValue);\r\n  const max = Math.max(startValue, endValue);\r\n  let barStart = min;\r\n  let barEnd = max;\r\n\r\n  if (Math.abs(min) > Math.abs(max)) {\r\n    barStart = max;\r\n    barEnd = min;\r\n  }\r\n\r\n  // Store `barEnd` (furthest away from origin) as parsed value,\r\n  // to make stacking straight forward\r\n  item[vScale.axis] = barEnd;\r\n\r\n  item._custom = {\r\n    barStart,\r\n    barEnd,\r\n    start: startValue,\r\n    end: endValue,\r\n    min,\r\n    max\r\n  };\r\n}\r\n\r\nfunction parseValue(entry, item, vScale, i) {\r\n  if (isArray(entry)) {\r\n    parseFloatBar(entry, item, vScale, i);\r\n  } else {\r\n    item[vScale.axis] = vScale.parse(entry, i);\r\n  }\r\n  return item;\r\n}\r\n\r\nfunction parseArrayOrPrimitive(meta, data, start, count) {\r\n  const iScale = meta.iScale;\r\n  const vScale = meta.vScale;\r\n  const labels = iScale.getLabels();\r\n  const singleScale = iScale === vScale;\r\n  const parsed = [];\r\n  let i, ilen, item, entry;\r\n\r\n  for (i = start, ilen = start + count; i < ilen; ++i) {\r\n    entry = data[i];\r\n    item = {};\r\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\r\n    parsed.push(parseValue(entry, item, vScale, i));\r\n  }\r\n  return parsed;\r\n}\r\n\r\nfunction isFloatBar(custom) {\r\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\r\n}\r\n\r\nfunction barSign(size, vScale, actualBase) {\r\n  if (size !== 0) {\r\n    return sign(size);\r\n  }\r\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\r\n}\r\n\r\nfunction borderProps(properties) {\r\n  let reverse, start, end, top, bottom;\r\n  if (properties.horizontal) {\r\n    reverse = properties.base > properties.x;\r\n    start = 'left';\r\n    end = 'right';\r\n  } else {\r\n    reverse = properties.base < properties.y;\r\n    start = 'bottom';\r\n    end = 'top';\r\n  }\r\n  if (reverse) {\r\n    top = 'end';\r\n    bottom = 'start';\r\n  } else {\r\n    top = 'start';\r\n    bottom = 'end';\r\n  }\r\n  return {start, end, reverse, top, bottom};\r\n}\r\n\r\nfunction setBorderSkipped(properties, options, stack, index) {\r\n  let edge = options.borderSkipped;\r\n  const res = {};\r\n\r\n  if (!edge) {\r\n    properties.borderSkipped = res;\r\n    return;\r\n  }\r\n\r\n  if (edge === true) {\r\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\r\n    return;\r\n  }\r\n\r\n  const {start, end, reverse, top, bottom} = borderProps(properties);\r\n\r\n  if (edge === 'middle' && stack) {\r\n    properties.enableBorderRadius = true;\r\n    if ((stack._top || 0) === index) {\r\n      edge = top;\r\n    } else if ((stack._bottom || 0) === index) {\r\n      edge = bottom;\r\n    } else {\r\n      res[parseEdge(bottom, start, end, reverse)] = true;\r\n      edge = top;\r\n    }\r\n  }\r\n\r\n  res[parseEdge(edge, start, end, reverse)] = true;\r\n  properties.borderSkipped = res;\r\n}\r\n\r\nfunction parseEdge(edge, a, b, reverse) {\r\n  if (reverse) {\r\n    edge = swap(edge, a, b);\r\n    edge = startEnd(edge, b, a);\r\n  } else {\r\n    edge = startEnd(edge, a, b);\r\n  }\r\n  return edge;\r\n}\r\n\r\nfunction swap(orig, v1, v2) {\r\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\r\n}\r\n\r\nfunction startEnd(v, start, end) {\r\n  return v === 'start' ? start : v === 'end' ? end : v;\r\n}\r\n\r\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\r\n  properties.inflateAmount = inflateAmount === 'auto'\r\n    ? ratio === 1 ? 0.33 : 0\r\n    : inflateAmount;\r\n}\r\n\r\nexport default class BarController extends DatasetController {\r\n\r\n  static id = 'bar';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    datasetElementType: false,\r\n    dataElementType: 'bar',\r\n\r\n    categoryPercentage: 0.8,\r\n    barPercentage: 0.9,\r\n    grouped: true,\r\n\r\n    animations: {\r\n      numbers: {\r\n        type: 'number',\r\n        properties: ['x', 'y', 'base', 'width', 'height']\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static overrides = {\r\n    scales: {\r\n      _index_: {\r\n        type: 'category',\r\n        offset: true,\r\n        grid: {\r\n          offset: true\r\n        }\r\n      },\r\n      _value_: {\r\n        type: 'linear',\r\n        beginAtZero: true,\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n\t * Overriding primitive data parsing since we support mixed primitive/array\r\n\t * data for float bars\r\n\t * @protected\r\n\t */\r\n  parsePrimitiveData(meta, data, start, count) {\r\n    return parseArrayOrPrimitive(meta, data, start, count);\r\n  }\r\n\r\n  /**\r\n\t * Overriding array data parsing since we support mixed primitive/array\r\n\t * data for float bars\r\n\t * @protected\r\n\t */\r\n  parseArrayData(meta, data, start, count) {\r\n    return parseArrayOrPrimitive(meta, data, start, count);\r\n  }\r\n\r\n  /**\r\n\t * Overriding object data parsing since we support mixed primitive/array\r\n\t * value-scale data for float bars\r\n\t * @protected\r\n\t */\r\n  parseObjectData(meta, data, start, count) {\r\n    const {iScale, vScale} = meta;\r\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\r\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\r\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\r\n    const parsed = [];\r\n    let i, ilen, item, obj;\r\n    for (i = start, ilen = start + count; i < ilen; ++i) {\r\n      obj = data[i];\r\n      item = {};\r\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\r\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\r\n    }\r\n    return parsed;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  updateRangeFromParsed(range, scale, parsed, stack) {\r\n    super.updateRangeFromParsed(range, scale, parsed, stack);\r\n    const custom = parsed._custom;\r\n    if (custom && scale === this._cachedMeta.vScale) {\r\n      // float bar: only one end of the bar is considered by `super`\r\n      range.min = Math.min(range.min, custom.min);\r\n      range.max = Math.max(range.max, custom.max);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @return {number|boolean}\r\n\t * @protected\r\n\t */\r\n  getMaxOverflow() {\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const {iScale, vScale} = meta;\r\n    const parsed = this.getParsed(index);\r\n    const custom = parsed._custom;\r\n    const value = isFloatBar(custom)\r\n      ? '[' + custom.start + ', ' + custom.end + ']'\r\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\r\n\r\n    return {\r\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\r\n      value\r\n    };\r\n  }\r\n\r\n  initialize() {\r\n    this.enableOptionSharing = true;\r\n\r\n    super.initialize();\r\n\r\n    const meta = this._cachedMeta;\r\n    meta.stack = this.getDataset().stack;\r\n  }\r\n\r\n  update(mode) {\r\n    const meta = this._cachedMeta;\r\n    this.updateElements(meta.data, 0, meta.data.length, mode);\r\n  }\r\n\r\n  updateElements(bars, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const {index, _cachedMeta: {vScale}} = this;\r\n    const base = vScale.getBasePixel();\r\n    const horizontal = vScale.isHorizontal();\r\n    const ruler = this._getRuler();\r\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\r\n\r\n    for (let i = start; i < start + count; i++) {\r\n      const parsed = this.getParsed(i);\r\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\r\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\r\n      const stack = (parsed._stacks || {})[vScale.axis];\r\n\r\n      const properties = {\r\n        horizontal,\r\n        base: vpixels.base,\r\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\r\n        x: horizontal ? vpixels.head : ipixels.center,\r\n        y: horizontal ? ipixels.center : vpixels.head,\r\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\r\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\r\n      };\r\n\r\n      if (includeOptions) {\r\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\r\n      }\r\n      const options = properties.options || bars[i].options;\r\n      setBorderSkipped(properties, options, stack, index);\r\n      setInflateAmount(properties, options, ruler.ratio);\r\n      this.updateElement(bars[i], i, properties, mode);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Returns the stacks based on groups and bar visibility.\r\n\t * @param {number} [last] - The dataset index\r\n\t * @param {number} [dataIndex] - The data index of the ruler\r\n\t * @returns {string[]} The list of stack IDs\r\n\t * @private\r\n\t */\r\n  _getStacks(last, dataIndex) {\r\n    const {iScale} = this._cachedMeta;\r\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\r\n      .filter(meta => meta.controller.options.grouped);\r\n    const stacked = iScale.options.stacked;\r\n    const stacks = [];\r\n\r\n    const skipNull = (meta) => {\r\n      const parsed = meta.controller.getParsed(dataIndex);\r\n      const val = parsed && parsed[meta.vScale.axis];\r\n\r\n      if (isNullOrUndef(val) || isNaN(val)) {\r\n        return true;\r\n      }\r\n    };\r\n\r\n    for (const meta of metasets) {\r\n      if (dataIndex !== undefined && skipNull(meta)) {\r\n        continue;\r\n      }\r\n\r\n      // stacked   | meta.stack\r\n      //           | found | not found | undefined\r\n      // false     |   x   |     x     |     x\r\n      // true      |       |     x     |\r\n      // undefined |       |     x     |     x\r\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\r\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\r\n        stacks.push(meta.stack);\r\n      }\r\n      if (meta.index === last) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // No stacks? that means there is no visible data. Let's still initialize an `undefined`\r\n    // stack where possible invisible bars will be located.\r\n    // https://github.com/chartjs/Chart.js/issues/6368\r\n    if (!stacks.length) {\r\n      stacks.push(undefined);\r\n    }\r\n\r\n    return stacks;\r\n  }\r\n\r\n  /**\r\n\t * Returns the effective number of stacks based on groups and bar visibility.\r\n\t * @private\r\n\t */\r\n  _getStackCount(index) {\r\n    return this._getStacks(undefined, index).length;\r\n  }\r\n\r\n  /**\r\n\t * Returns the stack index for the given dataset based on groups and bar visibility.\r\n\t * @param {number} [datasetIndex] - The dataset index\r\n\t * @param {string} [name] - The stack name to find\r\n   * @param {number} [dataIndex]\r\n\t * @returns {number} The stack index\r\n\t * @private\r\n\t */\r\n  _getStackIndex(datasetIndex, name, dataIndex) {\r\n    const stacks = this._getStacks(datasetIndex, dataIndex);\r\n    const index = (name !== undefined)\r\n      ? stacks.indexOf(name)\r\n      : -1; // indexOf returns -1 if element is not present\r\n\r\n    return (index === -1)\r\n      ? stacks.length - 1\r\n      : index;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getRuler() {\r\n    const opts = this.options;\r\n    const meta = this._cachedMeta;\r\n    const iScale = meta.iScale;\r\n    const pixels = [];\r\n    let i, ilen;\r\n\r\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\r\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\r\n    }\r\n\r\n    const barThickness = opts.barThickness;\r\n    const min = barThickness || computeMinSampleSize(meta);\r\n\r\n    return {\r\n      min,\r\n      pixels,\r\n      start: iScale._startPixel,\r\n      end: iScale._endPixel,\r\n      stackCount: this._getStackCount(),\r\n      scale: iScale,\r\n      grouped: opts.grouped,\r\n      // bar thickness ratio used for non-grouped bars\r\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * Note: pixel values are not clamped to the scale area.\r\n\t * @private\r\n\t */\r\n  _calculateBarValuePixels(index) {\r\n    const {_cachedMeta: {vScale, _stacked, index: datasetIndex}, options: {base: baseValue, minBarLength}} = this;\r\n    const actualBase = baseValue || 0;\r\n    const parsed = this.getParsed(index);\r\n    const custom = parsed._custom;\r\n    const floating = isFloatBar(custom);\r\n    let value = parsed[vScale.axis];\r\n    let start = 0;\r\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\r\n    let head, size;\r\n\r\n    if (length !== value) {\r\n      start = length - value;\r\n      length = value;\r\n    }\r\n\r\n    if (floating) {\r\n      value = custom.barStart;\r\n      length = custom.barEnd - custom.barStart;\r\n      // bars crossing origin are not stacked\r\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\r\n        start = 0;\r\n      }\r\n      start += value;\r\n    }\r\n\r\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\r\n    let base = vScale.getPixelForValue(startValue);\r\n\r\n    if (this.chart.getDataVisibility(index)) {\r\n      head = vScale.getPixelForValue(start + length);\r\n    } else {\r\n      // When not visible, no height\r\n      head = base;\r\n    }\r\n\r\n    size = head - base;\r\n\r\n    if (Math.abs(size) < minBarLength) {\r\n      size = barSign(size, vScale, actualBase) * minBarLength;\r\n      if (value === actualBase) {\r\n        base -= size / 2;\r\n      }\r\n      const startPixel = vScale.getPixelForDecimal(0);\r\n      const endPixel = vScale.getPixelForDecimal(1);\r\n      const min = Math.min(startPixel, endPixel);\r\n      const max = Math.max(startPixel, endPixel);\r\n      base = Math.max(Math.min(base, max), min);\r\n      head = base + size;\r\n\r\n      if (_stacked && !floating) {\r\n        // visual data coordinates after applying minBarLength\r\n        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\r\n      }\r\n    }\r\n\r\n    if (base === vScale.getPixelForValue(actualBase)) {\r\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\r\n      base += halfGrid;\r\n      size -= halfGrid;\r\n    }\r\n\r\n    return {\r\n      size,\r\n      base,\r\n      head,\r\n      center: head + size / 2\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _calculateBarIndexPixels(index, ruler) {\r\n    const scale = ruler.scale;\r\n    const options = this.options;\r\n    const skipNull = options.skipNull;\r\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\r\n    let center, size;\r\n    if (ruler.grouped) {\r\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\r\n      const range = options.barThickness === 'flex'\r\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\r\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\r\n\r\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\r\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\r\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\r\n    } else {\r\n      // For non-grouped bar charts, exact pixel values are used\r\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\r\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\r\n    }\r\n\r\n    return {\r\n      base: center - size / 2,\r\n      head: center + size / 2,\r\n      center,\r\n      size\r\n    };\r\n  }\r\n\r\n  draw() {\r\n    const meta = this._cachedMeta;\r\n    const vScale = meta.vScale;\r\n    const rects = meta.data;\r\n    const ilen = rects.length;\r\n    let i = 0;\r\n\r\n    for (; i < ilen; ++i) {\r\n      if (this.getParsed(i)[vScale.axis] !== null) {\r\n        rects[i].draw(this._ctx);\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n","import DatasetController from '../core/core.datasetController.js';\r\nimport {isObject, resolveObjectKey, toPercentage, toDimension, valueOrDefault} from '../helpers/helpers.core.js';\r\nimport {formatNumber} from '../helpers/helpers.intl.js';\r\nimport {toRadians, PI, TAU, HALF_PI, _angleBetween} from '../helpers/helpers.math.js';\r\n\r\n/**\r\n * @typedef { import('../core/core.controller.js').default } Chart\r\n */\r\n\r\nfunction getRatioAndOffset(rotation, circumference, cutout) {\r\n  let ratioX = 1;\r\n  let ratioY = 1;\r\n  let offsetX = 0;\r\n  let offsetY = 0;\r\n  // If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc\r\n  if (circumference < TAU) {\r\n    const startAngle = rotation;\r\n    const endAngle = startAngle + circumference;\r\n    const startX = Math.cos(startAngle);\r\n    const startY = Math.sin(startAngle);\r\n    const endX = Math.cos(endAngle);\r\n    const endY = Math.sin(endAngle);\r\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\r\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\r\n    const maxX = calcMax(0, startX, endX);\r\n    const maxY = calcMax(HALF_PI, startY, endY);\r\n    const minX = calcMin(PI, startX, endX);\r\n    const minY = calcMin(PI + HALF_PI, startY, endY);\r\n    ratioX = (maxX - minX) / 2;\r\n    ratioY = (maxY - minY) / 2;\r\n    offsetX = -(maxX + minX) / 2;\r\n    offsetY = -(maxY + minY) / 2;\r\n  }\r\n  return {ratioX, ratioY, offsetX, offsetY};\r\n}\r\n\r\nexport default class DoughnutController extends DatasetController {\r\n\r\n  static id = 'doughnut';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    datasetElementType: false,\r\n    dataElementType: 'arc',\r\n    animation: {\r\n      // Boolean - Whether we animate the rotation of the Doughnut\r\n      animateRotate: true,\r\n      // Boolean - Whether we animate scaling the Doughnut from the centre\r\n      animateScale: false\r\n    },\r\n    animations: {\r\n      numbers: {\r\n        type: 'number',\r\n        properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\r\n      },\r\n    },\r\n    // The percentage of the chart that we cut out of the middle.\r\n    cutout: '50%',\r\n\r\n    // The rotation of the chart, where the first data arc begins.\r\n    rotation: 0,\r\n\r\n    // The total circumference of the chart.\r\n    circumference: 360,\r\n\r\n    // The outr radius of the chart\r\n    radius: '100%',\r\n\r\n    // Spacing between arcs\r\n    spacing: 0,\r\n\r\n    indexAxis: 'r',\r\n  };\r\n\r\n  static descriptors = {\r\n    _scriptable: (name) => name !== 'spacing',\r\n    _indexable: (name) => name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash'),\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static overrides = {\r\n    aspectRatio: 1,\r\n\r\n    // Need to override these to give a nice default\r\n    plugins: {\r\n      legend: {\r\n        labels: {\r\n          generateLabels(chart) {\r\n            const data = chart.data;\r\n            if (data.labels.length && data.datasets.length) {\r\n              const {labels: {pointStyle, color}} = chart.legend.options;\r\n\r\n              return data.labels.map((label, i) => {\r\n                const meta = chart.getDatasetMeta(0);\r\n                const style = meta.controller.getStyle(i);\r\n\r\n                return {\r\n                  text: label,\r\n                  fillStyle: style.backgroundColor,\r\n                  strokeStyle: style.borderColor,\r\n                  fontColor: color,\r\n                  lineWidth: style.borderWidth,\r\n                  pointStyle: pointStyle,\r\n                  hidden: !chart.getDataVisibility(i),\r\n\r\n                  // Extra data used for toggling the correct item\r\n                  index: i\r\n                };\r\n              });\r\n            }\r\n            return [];\r\n          }\r\n        },\r\n\r\n        onClick(e, legendItem, legend) {\r\n          legend.chart.toggleDataVisibility(legendItem.index);\r\n          legend.chart.update();\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  constructor(chart, datasetIndex) {\r\n    super(chart, datasetIndex);\r\n\r\n    this.enableOptionSharing = true;\r\n    this.innerRadius = undefined;\r\n    this.outerRadius = undefined;\r\n    this.offsetX = undefined;\r\n    this.offsetY = undefined;\r\n  }\r\n\r\n  linkScales() {}\r\n\r\n  /**\r\n\t * Override data parsing, since we are not using scales\r\n\t */\r\n  parse(start, count) {\r\n    const data = this.getDataset().data;\r\n    const meta = this._cachedMeta;\r\n\r\n    if (this._parsing === false) {\r\n      meta._parsed = data;\r\n    } else {\r\n      let getter = (i) => +data[i];\r\n\r\n      if (isObject(data[start])) {\r\n        const {key = 'value'} = this._parsing;\r\n        getter = (i) => +resolveObjectKey(data[i], key);\r\n      }\r\n\r\n      let i, ilen;\r\n      for (i = start, ilen = start + count; i < ilen; ++i) {\r\n        meta._parsed[i] = getter(i);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getRotation() {\r\n    return toRadians(this.options.rotation - 90);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getCircumference() {\r\n    return toRadians(this.options.circumference);\r\n  }\r\n\r\n  /**\r\n\t * Get the maximal rotation & circumference extents\r\n\t * across all visible datasets.\r\n\t */\r\n  _getRotationExtents() {\r\n    let min = TAU;\r\n    let max = -TAU;\r\n\r\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\r\n      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\r\n        const controller = this.chart.getDatasetMeta(i).controller;\r\n        const rotation = controller._getRotation();\r\n        const circumference = controller._getCircumference();\r\n\r\n        min = Math.min(min, rotation);\r\n        max = Math.max(max, rotation + circumference);\r\n      }\r\n    }\r\n\r\n    return {\r\n      rotation: min,\r\n      circumference: max - min,\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * @param {string} mode\r\n\t */\r\n  update(mode) {\r\n    const chart = this.chart;\r\n    const {chartArea} = chart;\r\n    const meta = this._cachedMeta;\r\n    const arcs = meta.data;\r\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\r\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\r\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\r\n    const chartWeight = this._getRingWeight(this.index);\r\n\r\n    // Compute the maximal rotation & circumference limits.\r\n    // If we only consider our dataset, this can cause problems when two datasets\r\n    // are both less than a circle with different rotations (starting angles)\r\n    const {circumference, rotation} = this._getRotationExtents();\r\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\r\n    const maxWidth = (chartArea.width - spacing) / ratioX;\r\n    const maxHeight = (chartArea.height - spacing) / ratioY;\r\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\r\n    const outerRadius = toDimension(this.options.radius, maxRadius);\r\n    const innerRadius = Math.max(outerRadius * cutout, 0);\r\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\r\n    this.offsetX = offsetX * outerRadius;\r\n    this.offsetY = offsetY * outerRadius;\r\n\r\n    meta.total = this.calculateTotal();\r\n\r\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\r\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\r\n\r\n    this.updateElements(arcs, 0, arcs.length, mode);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _circumference(i, reset) {\r\n    const opts = this.options;\r\n    const meta = this._cachedMeta;\r\n    const circumference = this._getCircumference();\r\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\r\n      return 0;\r\n    }\r\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\r\n  }\r\n\r\n  updateElements(arcs, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const chart = this.chart;\r\n    const chartArea = chart.chartArea;\r\n    const opts = chart.options;\r\n    const animationOpts = opts.animation;\r\n    const centerX = (chartArea.left + chartArea.right) / 2;\r\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\r\n    const animateScale = reset && animationOpts.animateScale;\r\n    const innerRadius = animateScale ? 0 : this.innerRadius;\r\n    const outerRadius = animateScale ? 0 : this.outerRadius;\r\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\r\n    let startAngle = this._getRotation();\r\n    let i;\r\n\r\n    for (i = 0; i < start; ++i) {\r\n      startAngle += this._circumference(i, reset);\r\n    }\r\n\r\n    for (i = start; i < start + count; ++i) {\r\n      const circumference = this._circumference(i, reset);\r\n      const arc = arcs[i];\r\n      const properties = {\r\n        x: centerX + this.offsetX,\r\n        y: centerY + this.offsetY,\r\n        startAngle,\r\n        endAngle: startAngle + circumference,\r\n        circumference,\r\n        outerRadius,\r\n        innerRadius\r\n      };\r\n      if (includeOptions) {\r\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\r\n      }\r\n      startAngle += circumference;\r\n\r\n      this.updateElement(arc, i, properties, mode);\r\n    }\r\n  }\r\n\r\n  calculateTotal() {\r\n    const meta = this._cachedMeta;\r\n    const metaData = meta.data;\r\n    let total = 0;\r\n    let i;\r\n\r\n    for (i = 0; i < metaData.length; i++) {\r\n      const value = meta._parsed[i];\r\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\r\n        total += Math.abs(value);\r\n      }\r\n    }\r\n\r\n    return total;\r\n  }\r\n\r\n  calculateCircumference(value) {\r\n    const total = this._cachedMeta.total;\r\n    if (total > 0 && !isNaN(value)) {\r\n      return TAU * (Math.abs(value) / total);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const chart = this.chart;\r\n    const labels = chart.data.labels || [];\r\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\r\n\r\n    return {\r\n      label: labels[index] || '',\r\n      value,\r\n    };\r\n  }\r\n\r\n  getMaxBorderWidth(arcs) {\r\n    let max = 0;\r\n    const chart = this.chart;\r\n    let i, ilen, meta, controller, options;\r\n\r\n    if (!arcs) {\r\n      // Find the outmost visible dataset\r\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\r\n        if (chart.isDatasetVisible(i)) {\r\n          meta = chart.getDatasetMeta(i);\r\n          arcs = meta.data;\r\n          controller = meta.controller;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!arcs) {\r\n      return 0;\r\n    }\r\n\r\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\r\n      options = controller.resolveDataElementOptions(i);\r\n      if (options.borderAlign !== 'inner') {\r\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\r\n      }\r\n    }\r\n    return max;\r\n  }\r\n\r\n  getMaxOffset(arcs) {\r\n    let max = 0;\r\n\r\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\r\n      const options = this.resolveDataElementOptions(i);\r\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\r\n    }\r\n    return max;\r\n  }\r\n\r\n  /**\r\n\t * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\r\n\t * @private\r\n\t */\r\n  _getRingWeightOffset(datasetIndex) {\r\n    let ringWeightOffset = 0;\r\n\r\n    for (let i = 0; i < datasetIndex; ++i) {\r\n      if (this.chart.isDatasetVisible(i)) {\r\n        ringWeightOffset += this._getRingWeight(i);\r\n      }\r\n    }\r\n\r\n    return ringWeightOffset;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getRingWeight(datasetIndex) {\r\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\r\n  }\r\n\r\n  /**\r\n\t * Returns the sum of all visible data set weights.\r\n\t * @private\r\n\t */\r\n  _getVisibleDatasetWeightTotal() {\r\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\r\n  }\r\n}\r\n","import DatasetController from '../core/core.datasetController.js';\r\nimport {toRadians, PI, formatNumber, _parseObjectDataRadialScale} from '../helpers/index.js';\r\n\r\nexport default class PolarAreaController extends DatasetController {\r\n\r\n  static id = 'polarArea';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    dataElementType: 'arc',\r\n    animation: {\r\n      animateRotate: true,\r\n      animateScale: true\r\n    },\r\n    animations: {\r\n      numbers: {\r\n        type: 'number',\r\n        properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\r\n      },\r\n    },\r\n    indexAxis: 'r',\r\n    startAngle: 0,\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static overrides = {\r\n    aspectRatio: 1,\r\n\r\n    plugins: {\r\n      legend: {\r\n        labels: {\r\n          generateLabels(chart) {\r\n            const data = chart.data;\r\n            if (data.labels.length && data.datasets.length) {\r\n              const {labels: {pointStyle, color}} = chart.legend.options;\r\n\r\n              return data.labels.map((label, i) => {\r\n                const meta = chart.getDatasetMeta(0);\r\n                const style = meta.controller.getStyle(i);\r\n\r\n                return {\r\n                  text: label,\r\n                  fillStyle: style.backgroundColor,\r\n                  strokeStyle: style.borderColor,\r\n                  fontColor: color,\r\n                  lineWidth: style.borderWidth,\r\n                  pointStyle: pointStyle,\r\n                  hidden: !chart.getDataVisibility(i),\r\n\r\n                  // Extra data used for toggling the correct item\r\n                  index: i\r\n                };\r\n              });\r\n            }\r\n            return [];\r\n          }\r\n        },\r\n\r\n        onClick(e, legendItem, legend) {\r\n          legend.chart.toggleDataVisibility(legendItem.index);\r\n          legend.chart.update();\r\n        }\r\n      }\r\n    },\r\n\r\n    scales: {\r\n      r: {\r\n        type: 'radialLinear',\r\n        angleLines: {\r\n          display: false\r\n        },\r\n        beginAtZero: true,\r\n        grid: {\r\n          circular: true\r\n        },\r\n        pointLabels: {\r\n          display: false\r\n        },\r\n        startAngle: 0\r\n      }\r\n    }\r\n  };\r\n\r\n  constructor(chart, datasetIndex) {\r\n    super(chart, datasetIndex);\r\n\r\n    this.innerRadius = undefined;\r\n    this.outerRadius = undefined;\r\n  }\r\n\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const chart = this.chart;\r\n    const labels = chart.data.labels || [];\r\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\r\n\r\n    return {\r\n      label: labels[index] || '',\r\n      value,\r\n    };\r\n  }\r\n\r\n  parseObjectData(meta, data, start, count) {\r\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\r\n  }\r\n\r\n  update(mode) {\r\n    const arcs = this._cachedMeta.data;\r\n\r\n    this._updateRadius();\r\n    this.updateElements(arcs, 0, arcs.length, mode);\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  getMinMax() {\r\n    const meta = this._cachedMeta;\r\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\r\n\r\n    meta.data.forEach((element, index) => {\r\n      const parsed = this.getParsed(index).r;\r\n\r\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\r\n        if (parsed < range.min) {\r\n          range.min = parsed;\r\n        }\r\n\r\n        if (parsed > range.max) {\r\n          range.max = parsed;\r\n        }\r\n      }\r\n    });\r\n\r\n    return range;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _updateRadius() {\r\n    const chart = this.chart;\r\n    const chartArea = chart.chartArea;\r\n    const opts = chart.options;\r\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\r\n\r\n    const outerRadius = Math.max(minSize / 2, 0);\r\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\r\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\r\n\r\n    this.outerRadius = outerRadius - (radiusLength * this.index);\r\n    this.innerRadius = this.outerRadius - radiusLength;\r\n  }\r\n\r\n  updateElements(arcs, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const chart = this.chart;\r\n    const opts = chart.options;\r\n    const animationOpts = opts.animation;\r\n    const scale = this._cachedMeta.rScale;\r\n    const centerX = scale.xCenter;\r\n    const centerY = scale.yCenter;\r\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\r\n    let angle = datasetStartAngle;\r\n    let i;\r\n\r\n    const defaultAngle = 360 / this.countVisibleElements();\r\n\r\n    for (i = 0; i < start; ++i) {\r\n      angle += this._computeAngle(i, mode, defaultAngle);\r\n    }\r\n    for (i = start; i < start + count; i++) {\r\n      const arc = arcs[i];\r\n      let startAngle = angle;\r\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\r\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\r\n      angle = endAngle;\r\n\r\n      if (reset) {\r\n        if (animationOpts.animateScale) {\r\n          outerRadius = 0;\r\n        }\r\n        if (animationOpts.animateRotate) {\r\n          startAngle = endAngle = datasetStartAngle;\r\n        }\r\n      }\r\n\r\n      const properties = {\r\n        x: centerX,\r\n        y: centerY,\r\n        innerRadius: 0,\r\n        outerRadius,\r\n        startAngle,\r\n        endAngle,\r\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\r\n      };\r\n\r\n      this.updateElement(arc, i, properties, mode);\r\n    }\r\n  }\r\n\r\n  countVisibleElements() {\r\n    const meta = this._cachedMeta;\r\n    let count = 0;\r\n\r\n    meta.data.forEach((element, index) => {\r\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\r\n        count++;\r\n      }\r\n    });\r\n\r\n    return count;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _computeAngle(index, mode, defaultAngle) {\r\n    return this.chart.getDataVisibility(index)\r\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\r\n      : 0;\r\n  }\r\n}\r\n","import DatasetController from '../core/core.datasetController.js';\r\nimport {valueOrDefault} from '../helpers/helpers.core.js';\r\n\r\nexport default class BubbleController extends DatasetController {\r\n\r\n  static id = 'bubble';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    datasetElementType: false,\r\n    dataElementType: 'point',\r\n\r\n    animations: {\r\n      numbers: {\r\n        type: 'number',\r\n        properties: ['x', 'y', 'borderWidth', 'radius']\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static overrides = {\r\n    scales: {\r\n      x: {\r\n        type: 'linear'\r\n      },\r\n      y: {\r\n        type: 'linear'\r\n      }\r\n    }\r\n  };\r\n\r\n  initialize() {\r\n    this.enableOptionSharing = true;\r\n    super.initialize();\r\n  }\r\n\r\n  /**\r\n\t * Parse array of primitive values\r\n\t * @protected\r\n\t */\r\n  parsePrimitiveData(meta, data, start, count) {\r\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\r\n    for (let i = 0; i < parsed.length; i++) {\r\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\r\n    }\r\n    return parsed;\r\n  }\r\n\r\n  /**\r\n\t * Parse array of arrays\r\n\t * @protected\r\n\t */\r\n  parseArrayData(meta, data, start, count) {\r\n    const parsed = super.parseArrayData(meta, data, start, count);\r\n    for (let i = 0; i < parsed.length; i++) {\r\n      const item = data[start + i];\r\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\r\n    }\r\n    return parsed;\r\n  }\r\n\r\n  /**\r\n\t * Parse array of objects\r\n\t * @protected\r\n\t */\r\n  parseObjectData(meta, data, start, count) {\r\n    const parsed = super.parseObjectData(meta, data, start, count);\r\n    for (let i = 0; i < parsed.length; i++) {\r\n      const item = data[start + i];\r\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\r\n    }\r\n    return parsed;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getMaxOverflow() {\r\n    const data = this._cachedMeta.data;\r\n\r\n    let max = 0;\r\n    for (let i = data.length - 1; i >= 0; --i) {\r\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\r\n    }\r\n    return max > 0 && max;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const labels = this.chart.data.labels || [];\r\n    const {xScale, yScale} = meta;\r\n    const parsed = this.getParsed(index);\r\n    const x = xScale.getLabelForValue(parsed.x);\r\n    const y = yScale.getLabelForValue(parsed.y);\r\n    const r = parsed._custom;\r\n\r\n    return {\r\n      label: labels[index] || '',\r\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\r\n    };\r\n  }\r\n\r\n  update(mode) {\r\n    const points = this._cachedMeta.data;\r\n\r\n    // Update Points\r\n    this.updateElements(points, 0, points.length, mode);\r\n  }\r\n\r\n  updateElements(points, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const {iScale, vScale} = this._cachedMeta;\r\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\r\n    const iAxis = iScale.axis;\r\n    const vAxis = vScale.axis;\r\n\r\n    for (let i = start; i < start + count; i++) {\r\n      const point = points[i];\r\n      const parsed = !reset && this.getParsed(i);\r\n      const properties = {};\r\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\r\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\r\n\r\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\r\n\r\n      if (includeOptions) {\r\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\r\n\r\n        if (reset) {\r\n          properties.options.radius = 0;\r\n        }\r\n      }\r\n\r\n      this.updateElement(point, i, properties, mode);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @param {number} index\r\n\t * @param {string} [mode]\r\n\t * @protected\r\n\t */\r\n  resolveDataElementOptions(index, mode) {\r\n    const parsed = this.getParsed(index);\r\n    let values = super.resolveDataElementOptions(index, mode);\r\n\r\n    // In case values were cached (and thus frozen), we need to clone the values\r\n    if (values.$shared) {\r\n      values = Object.assign({}, values, {$shared: false});\r\n    }\r\n\r\n    // Custom radius resolution\r\n    const radius = values.radius;\r\n    if (mode !== 'active') {\r\n      values.radius = 0;\r\n    }\r\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\r\n\r\n    return values;\r\n  }\r\n}\r\n","import DatasetController from '../core/core.datasetController.js';\r\nimport {isNullOrUndef} from '../helpers/index.js';\r\nimport {isNumber} from '../helpers/helpers.math.js';\r\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\r\n\r\nexport default class LineController extends DatasetController {\r\n\r\n  static id = 'line';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    datasetElementType: 'line',\r\n    dataElementType: 'point',\r\n\r\n    showLine: true,\r\n    spanGaps: false,\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static overrides = {\r\n    scales: {\r\n      _index_: {\r\n        type: 'category',\r\n      },\r\n      _value_: {\r\n        type: 'linear',\r\n      },\r\n    }\r\n  };\r\n\r\n  initialize() {\r\n    this.enableOptionSharing = true;\r\n    this.supportsDecimation = true;\r\n    super.initialize();\r\n  }\r\n\r\n  update(mode) {\r\n    const meta = this._cachedMeta;\r\n    const {dataset: line, data: points = [], _dataset} = meta;\r\n    // @ts-ignore\r\n    const animationsDisabled = this.chart._animationsDisabled;\r\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\r\n\r\n    this._drawStart = start;\r\n    this._drawCount = count;\r\n\r\n    if (_scaleRangesChanged(meta)) {\r\n      start = 0;\r\n      count = points.length;\r\n    }\r\n\r\n    // Update Line\r\n    line._chart = this.chart;\r\n    line._datasetIndex = this.index;\r\n    line._decimated = !!_dataset._decimated;\r\n    line.points = points;\r\n\r\n    const options = this.resolveDatasetElementOptions(mode);\r\n    if (!this.options.showLine) {\r\n      options.borderWidth = 0;\r\n    }\r\n    options.segment = this.options.segment;\r\n    this.updateElement(line, undefined, {\r\n      animated: !animationsDisabled,\r\n      options\r\n    }, mode);\r\n\r\n    // Update Points\r\n    this.updateElements(points, start, count, mode);\r\n  }\r\n\r\n  updateElements(points, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\r\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\r\n    const iAxis = iScale.axis;\r\n    const vAxis = vScale.axis;\r\n    const {spanGaps, segment} = this.options;\r\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\r\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\r\n    const end = start + count;\r\n    const pointsCount = points.length;\r\n    let prevParsed = start > 0 && this.getParsed(start - 1);\r\n\r\n    for (let i = 0; i < pointsCount; ++i) {\r\n      const point = points[i];\r\n      const properties = directUpdate ? point : {};\r\n\r\n      if (i < start || i >= end) {\r\n        properties.skip = true;\r\n        continue;\r\n      }\r\n\r\n      const parsed = this.getParsed(i);\r\n      const nullData = isNullOrUndef(parsed[vAxis]);\r\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\r\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\r\n\r\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\r\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\r\n      if (segment) {\r\n        properties.parsed = parsed;\r\n        properties.raw = _dataset.data[i];\r\n      }\r\n\r\n      if (includeOptions) {\r\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\r\n      }\r\n\r\n      if (!directUpdate) {\r\n        this.updateElement(point, i, properties, mode);\r\n      }\r\n\r\n      prevParsed = parsed;\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getMaxOverflow() {\r\n    const meta = this._cachedMeta;\r\n    const dataset = meta.dataset;\r\n    const border = dataset.options && dataset.options.borderWidth || 0;\r\n    const data = meta.data || [];\r\n    if (!data.length) {\r\n      return border;\r\n    }\r\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\r\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\r\n    return Math.max(border, firstPoint, lastPoint) / 2;\r\n  }\r\n\r\n  draw() {\r\n    const meta = this._cachedMeta;\r\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\r\n    super.draw();\r\n  }\r\n}\r\n","import DoughnutController from './controller.doughnut.js';\r\n\r\n// Pie charts are Doughnut chart with different defaults\r\nexport default class PieController extends DoughnutController {\r\n\r\n  static id = 'pie';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    // The percentage of the chart that we cut out of the middle.\r\n    cutout: 0,\r\n\r\n    // The rotation of the chart, where the first data arc begins.\r\n    rotation: 0,\r\n\r\n    // The total circumference of the chart.\r\n    circumference: 360,\r\n\r\n    // The outr radius of the chart\r\n    radius: '100%'\r\n  };\r\n}\r\n","import DatasetController from '../core/core.datasetController.js';\r\nimport {_parseObjectDataRadialScale} from '../helpers/index.js';\r\n\r\nexport default class RadarController extends DatasetController {\r\n\r\n  static id = 'radar';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    datasetElementType: 'line',\r\n    dataElementType: 'point',\r\n    indexAxis: 'r',\r\n    showLine: true,\r\n    elements: {\r\n      line: {\r\n        fill: 'start'\r\n      }\r\n    },\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static overrides = {\r\n    aspectRatio: 1,\r\n\r\n    scales: {\r\n      r: {\r\n        type: 'radialLinear',\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getLabelAndValue(index) {\r\n    const vScale = this._cachedMeta.vScale;\r\n    const parsed = this.getParsed(index);\r\n\r\n    return {\r\n      label: vScale.getLabels()[index],\r\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\r\n    };\r\n  }\r\n\r\n  parseObjectData(meta, data, start, count) {\r\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\r\n  }\r\n\r\n  update(mode) {\r\n    const meta = this._cachedMeta;\r\n    const line = meta.dataset;\r\n    const points = meta.data || [];\r\n    const labels = meta.iScale.getLabels();\r\n\r\n    // Update Line\r\n    line.points = points;\r\n    // In resize mode only point locations change, so no need to set the points or options.\r\n    if (mode !== 'resize') {\r\n      const options = this.resolveDatasetElementOptions(mode);\r\n      if (!this.options.showLine) {\r\n        options.borderWidth = 0;\r\n      }\r\n\r\n      const properties = {\r\n        _loop: true,\r\n        _fullLoop: labels.length === points.length,\r\n        options\r\n      };\r\n\r\n      this.updateElement(line, undefined, properties, mode);\r\n    }\r\n\r\n    // Update Points\r\n    this.updateElements(points, 0, points.length, mode);\r\n  }\r\n\r\n  updateElements(points, start, count, mode) {\r\n    const scale = this._cachedMeta.rScale;\r\n    const reset = mode === 'reset';\r\n\r\n    for (let i = start; i < start + count; i++) {\r\n      const point = points[i];\r\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\r\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\r\n\r\n      const x = reset ? scale.xCenter : pointPosition.x;\r\n      const y = reset ? scale.yCenter : pointPosition.y;\r\n\r\n      const properties = {\r\n        x,\r\n        y,\r\n        angle: pointPosition.angle,\r\n        skip: isNaN(x) || isNaN(y),\r\n        options\r\n      };\r\n\r\n      this.updateElement(point, i, properties, mode);\r\n    }\r\n  }\r\n}\r\n","import DatasetController from '../core/core.datasetController.js';\r\nimport {isNullOrUndef} from '../helpers/index.js';\r\nimport {isNumber} from '../helpers/helpers.math.js';\r\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\r\n\r\nexport default class ScatterController extends DatasetController {\r\n\r\n  static id = 'scatter';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    datasetElementType: false,\r\n    dataElementType: 'point',\r\n    showLine: false,\r\n    fill: false\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static overrides = {\r\n\r\n    interaction: {\r\n      mode: 'point'\r\n    },\r\n\r\n    scales: {\r\n      x: {\r\n        type: 'linear'\r\n      },\r\n      y: {\r\n        type: 'linear'\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const labels = this.chart.data.labels || [];\r\n    const {xScale, yScale} = meta;\r\n    const parsed = this.getParsed(index);\r\n    const x = xScale.getLabelForValue(parsed.x);\r\n    const y = yScale.getLabelForValue(parsed.y);\r\n\r\n    return {\r\n      label: labels[index] || '',\r\n      value: '(' + x + ', ' + y + ')'\r\n    };\r\n  }\r\n\r\n  update(mode) {\r\n    const meta = this._cachedMeta;\r\n    const {data: points = []} = meta;\r\n    // @ts-ignore\r\n    const animationsDisabled = this.chart._animationsDisabled;\r\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\r\n\r\n    this._drawStart = start;\r\n    this._drawCount = count;\r\n\r\n    if (_scaleRangesChanged(meta)) {\r\n      start = 0;\r\n      count = points.length;\r\n    }\r\n\r\n    if (this.options.showLine) {\r\n\r\n      const {dataset: line, _dataset} = meta;\r\n\r\n      // Update Line\r\n      line._chart = this.chart;\r\n      line._datasetIndex = this.index;\r\n      line._decimated = !!_dataset._decimated;\r\n      line.points = points;\r\n\r\n      const options = this.resolveDatasetElementOptions(mode);\r\n      options.segment = this.options.segment;\r\n      this.updateElement(line, undefined, {\r\n        animated: !animationsDisabled,\r\n        options\r\n      }, mode);\r\n    }\r\n\r\n    // Update Points\r\n    this.updateElements(points, start, count, mode);\r\n  }\r\n\r\n  addElements() {\r\n    const {showLine} = this.options;\r\n\r\n    if (!this.datasetElementType && showLine) {\r\n      this.datasetElementType = this.chart.registry.getElement('line');\r\n    }\r\n\r\n    super.addElements();\r\n  }\r\n\r\n  updateElements(points, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\r\n    const firstOpts = this.resolveDataElementOptions(start, mode);\r\n    const sharedOptions = this.getSharedOptions(firstOpts);\r\n    const includeOptions = this.includeOptions(mode, sharedOptions);\r\n    const iAxis = iScale.axis;\r\n    const vAxis = vScale.axis;\r\n    const {spanGaps, segment} = this.options;\r\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\r\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\r\n    let prevParsed = start > 0 && this.getParsed(start - 1);\r\n\r\n    for (let i = start; i < start + count; ++i) {\r\n      const point = points[i];\r\n      const parsed = this.getParsed(i);\r\n      const properties = directUpdate ? point : {};\r\n      const nullData = isNullOrUndef(parsed[vAxis]);\r\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\r\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\r\n\r\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\r\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\r\n      if (segment) {\r\n        properties.parsed = parsed;\r\n        properties.raw = _dataset.data[i];\r\n      }\r\n\r\n      if (includeOptions) {\r\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\r\n      }\r\n\r\n      if (!directUpdate) {\r\n        this.updateElement(point, i, properties, mode);\r\n      }\r\n\r\n      prevParsed = parsed;\r\n    }\r\n\r\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getMaxOverflow() {\r\n    const meta = this._cachedMeta;\r\n    const data = meta.data || [];\r\n\r\n    if (!this.options.showLine) {\r\n      let max = 0;\r\n      for (let i = data.length - 1; i >= 0; --i) {\r\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\r\n      }\r\n      return max > 0 && max;\r\n    }\r\n\r\n    const dataset = meta.dataset;\r\n    const border = dataset.options && dataset.options.borderWidth || 0;\r\n\r\n    if (!data.length) {\r\n      return border;\r\n    }\r\n\r\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\r\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\r\n    return Math.max(border, firstPoint, lastPoint) / 2;\r\n  }\r\n}\r\n","import Element from '../core/core.element.js';\r\nimport {_angleBetween, getAngleFromPoint, TAU, HALF_PI, valueOrDefault} from '../helpers/index.js';\r\nimport {PI, _isBetween, _limitValue} from '../helpers/helpers.math.js';\r\nimport {_readValueToProps} from '../helpers/helpers.options.js';\r\nimport type {ArcOptions, Point} from '../types/index.js';\r\n\r\n\r\nfunction clipArc(ctx: CanvasRenderingContext2D, element: ArcElement, endAngle: number) {\r\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\r\n  let angleMargin = pixelMargin / outerRadius;\r\n\r\n  // Draw an inner border by clipping the arc and drawing a double-width border\r\n  // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\r\n  if (innerRadius > pixelMargin) {\r\n    angleMargin = pixelMargin / innerRadius;\r\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\r\n  } else {\r\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\r\n  }\r\n  ctx.closePath();\r\n  ctx.clip();\r\n}\r\n\r\nfunction toRadiusCorners(value) {\r\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\r\n}\r\n\r\n/**\r\n * Parse border radius from the provided options\r\n */\r\nfunction parseBorderRadius(arc: ArcElement, innerRadius: number, outerRadius: number, angleDelta: number) {\r\n  const o = toRadiusCorners(arc.options.borderRadius);\r\n  const halfThickness = (outerRadius - innerRadius) / 2;\r\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\r\n\r\n  // Outer limits are complicated. We want to compute the available angular distance at\r\n  // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\r\n  // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\r\n  //\r\n  // If the borderRadius is large, that value can become negative.\r\n  // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\r\n  // we know that the thickness term will dominate and compute the limits at that point\r\n  const computeOuterLimit = (val) => {\r\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\r\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\r\n  };\r\n\r\n  return {\r\n    outerStart: computeOuterLimit(o.outerStart),\r\n    outerEnd: computeOuterLimit(o.outerEnd),\r\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\r\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\r\n  };\r\n}\r\n\r\n/**\r\n * Convert (r, ) to (x, y)\r\n */\r\nfunction rThetaToXY(r: number, theta: number, x: number, y: number) {\r\n  return {\r\n    x: x + r * Math.cos(theta),\r\n    y: y + r * Math.sin(theta),\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Path the arc, respecting border radius by separating into left and right halves.\r\n *\r\n *   Start      End\r\n *\r\n *    1--->a--->2    Outer\r\n *   /           \\\r\n *   8           3\r\n *   |           |\r\n *   |           |\r\n *   7           4\r\n *   \\           /\r\n *    6<---b<---5    Inner\r\n */\r\nfunction pathArc(\r\n  ctx: CanvasRenderingContext2D,\r\n  element: ArcElement,\r\n  offset: number,\r\n  spacing: number,\r\n  end: number,\r\n  circular: boolean,\r\n) {\r\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\r\n\r\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\r\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\r\n\r\n  let spacingOffset = 0;\r\n  const alpha = end - start;\r\n\r\n  if (spacing) {\r\n    // When spacing is present, it is the same for all items\r\n    // So we adjust the start and end angle of the arc such that\r\n    // the distance is the same as it would be without the spacing\r\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\r\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\r\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\r\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\r\n    spacingOffset = (alpha - adjustedAngle) / 2;\r\n  }\r\n\r\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\r\n  const angleOffset = (alpha - beta) / 2;\r\n  const startAngle = start + angleOffset + spacingOffset;\r\n  const endAngle = end - angleOffset - spacingOffset;\r\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius(element, innerRadius, outerRadius, endAngle - startAngle);\r\n\r\n  const outerStartAdjustedRadius = outerRadius - outerStart;\r\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\r\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\r\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\r\n\r\n  const innerStartAdjustedRadius = innerRadius + innerStart;\r\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\r\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\r\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\r\n\r\n  ctx.beginPath();\r\n\r\n  if (circular) {\r\n    // The first arc segments from point 1 to point a to point 2\r\n    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\r\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\r\n    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\r\n\r\n    // The corner segment from point 2 to point 3\r\n    if (outerEnd > 0) {\r\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\r\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\r\n    }\r\n\r\n    // The line from point 3 to point 4\r\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\r\n    ctx.lineTo(p4.x, p4.y);\r\n\r\n    // The corner segment from point 4 to point 5\r\n    if (innerEnd > 0) {\r\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\r\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\r\n    }\r\n\r\n    // The inner arc from point 5 to point b to point 6\r\n    const innerMidAdjustedAngle = ((endAngle - (innerEnd / innerRadius)) + (startAngle + (innerStart / innerRadius))) / 2;\r\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), innerMidAdjustedAngle, true);\r\n    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + (innerStart / innerRadius), true);\r\n\r\n    // The corner segment from point 6 to point 7\r\n    if (innerStart > 0) {\r\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\r\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\r\n    }\r\n\r\n    // The line from point 7 to point 8\r\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\r\n    ctx.lineTo(p8.x, p8.y);\r\n\r\n    // The corner segment from point 8 to point 1\r\n    if (outerStart > 0) {\r\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\r\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\r\n    }\r\n  } else {\r\n    ctx.moveTo(x, y);\r\n\r\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\r\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\r\n    ctx.lineTo(outerStartX, outerStartY);\r\n\r\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\r\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\r\n    ctx.lineTo(outerEndX, outerEndY);\r\n  }\r\n\r\n  ctx.closePath();\r\n}\r\n\r\nfunction drawArc(\r\n  ctx: CanvasRenderingContext2D,\r\n  element: ArcElement,\r\n  offset: number,\r\n  spacing: number,\r\n  circular: boolean,\r\n) {\r\n  const {fullCircles, startAngle, circumference} = element;\r\n  let endAngle = element.endAngle;\r\n  if (fullCircles) {\r\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\r\n    for (let i = 0; i < fullCircles; ++i) {\r\n      ctx.fill();\r\n    }\r\n    if (!isNaN(circumference)) {\r\n      endAngle = startAngle + (circumference % TAU || TAU);\r\n    }\r\n  }\r\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\r\n  ctx.fill();\r\n  return endAngle;\r\n}\r\n\r\nfunction drawBorder(\r\n  ctx: CanvasRenderingContext2D,\r\n  element: ArcElement,\r\n  offset: number,\r\n  spacing: number,\r\n  circular: boolean,\r\n) {\r\n  const {fullCircles, startAngle, circumference, options} = element;\r\n  const {borderWidth, borderJoinStyle, borderDash, borderDashOffset} = options;\r\n  const inner = options.borderAlign === 'inner';\r\n\r\n  if (!borderWidth) {\r\n    return;\r\n  }\r\n\r\n  ctx.setLineDash(borderDash || []);\r\n  ctx.lineDashOffset = borderDashOffset;\r\n\r\n  if (inner) {\r\n    ctx.lineWidth = borderWidth * 2;\r\n    ctx.lineJoin = borderJoinStyle || 'round';\r\n  } else {\r\n    ctx.lineWidth = borderWidth;\r\n    ctx.lineJoin = borderJoinStyle || 'bevel';\r\n  }\r\n\r\n  let endAngle = element.endAngle;\r\n  if (fullCircles) {\r\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\r\n    for (let i = 0; i < fullCircles; ++i) {\r\n      ctx.stroke();\r\n    }\r\n    if (!isNaN(circumference)) {\r\n      endAngle = startAngle + (circumference % TAU || TAU);\r\n    }\r\n  }\r\n\r\n  if (inner) {\r\n    clipArc(ctx, element, endAngle);\r\n  }\r\n\r\n  if (!fullCircles) {\r\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\r\n    ctx.stroke();\r\n  }\r\n}\r\n\r\nexport interface ArcProps extends Point {\r\n  startAngle: number;\r\n  endAngle: number;\r\n  innerRadius: number;\r\n  outerRadius: number;\r\n  circumference: number;\r\n}\r\n\r\nexport default class ArcElement extends Element<ArcProps, ArcOptions> {\r\n\r\n  static id = 'arc';\r\n\r\n  static defaults = {\r\n    borderAlign: 'center',\r\n    borderColor: '#fff',\r\n    borderDash: [],\r\n    borderDashOffset: 0,\r\n    borderJoinStyle: undefined,\r\n    borderRadius: 0,\r\n    borderWidth: 2,\r\n    offset: 0,\r\n    spacing: 0,\r\n    angle: undefined,\r\n    circular: true,\r\n  };\r\n\r\n  static defaultRoutes = {\r\n    backgroundColor: 'backgroundColor'\r\n  };\r\n\r\n  static descriptors = {\r\n    _scriptable: true,\r\n    _indexable: (name) => name !== 'borderDash'\r\n  };\r\n\r\n  circumference: number;\r\n  endAngle: number;\r\n  fullCircles: number;\r\n  innerRadius: number;\r\n  outerRadius: number;\r\n  pixelMargin: number;\r\n  startAngle: number;\r\n\r\n  constructor(cfg) {\r\n    super();\r\n\r\n    this.options = undefined;\r\n    this.circumference = undefined;\r\n    this.startAngle = undefined;\r\n    this.endAngle = undefined;\r\n    this.innerRadius = undefined;\r\n    this.outerRadius = undefined;\r\n    this.pixelMargin = 0;\r\n    this.fullCircles = 0;\r\n\r\n    if (cfg) {\r\n      Object.assign(this, cfg);\r\n    }\r\n  }\r\n\r\n  inRange(chartX: number, chartY: number, useFinalPosition: boolean) {\r\n    const point = this.getProps(['x', 'y'], useFinalPosition);\r\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\r\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\r\n      'startAngle',\r\n      'endAngle',\r\n      'innerRadius',\r\n      'outerRadius',\r\n      'circumference'\r\n    ], useFinalPosition);\r\n    const rAdjust = this.options.spacing / 2;\r\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\r\n    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\r\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\r\n\r\n    return (betweenAngles && withinRadius);\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition: boolean) {\r\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\r\n      'x',\r\n      'y',\r\n      'startAngle',\r\n      'endAngle',\r\n      'innerRadius',\r\n      'outerRadius'\r\n    ], useFinalPosition);\r\n    const {offset, spacing} = this.options;\r\n    const halfAngle = (startAngle + endAngle) / 2;\r\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\r\n    return {\r\n      x: x + Math.cos(halfAngle) * halfRadius,\r\n      y: y + Math.sin(halfAngle) * halfRadius\r\n    };\r\n  }\r\n\r\n  tooltipPosition(useFinalPosition: boolean) {\r\n    return this.getCenterPoint(useFinalPosition);\r\n  }\r\n\r\n  draw(ctx: CanvasRenderingContext2D) {\r\n    const {options, circumference} = this;\r\n    const offset = (options.offset || 0) / 4;\r\n    const spacing = (options.spacing || 0) / 2;\r\n    const circular = options.circular;\r\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\r\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\r\n\r\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\r\n      return;\r\n    }\r\n\r\n    ctx.save();\r\n\r\n    const halfAngle = (this.startAngle + this.endAngle) / 2;\r\n    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\r\n    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\r\n    const radiusOffset = offset * fix;\r\n\r\n    ctx.fillStyle = options.backgroundColor;\r\n    ctx.strokeStyle = options.borderColor;\r\n\r\n    drawArc(ctx, this, radiusOffset, spacing, circular);\r\n    drawBorder(ctx, this, radiusOffset, spacing, circular);\r\n\r\n    ctx.restore();\r\n  }\r\n}\r\n","import Element from '../core/core.element.js';\r\nimport {_bezierInterpolation, _pointInLine, _steppedInterpolation} from '../helpers/helpers.interpolation.js';\r\nimport {_computeSegments, _boundSegments} from '../helpers/helpers.segment.js';\r\nimport {_steppedLineTo, _bezierCurveTo} from '../helpers/helpers.canvas.js';\r\nimport {_updateBezierControlPoints} from '../helpers/helpers.curve.js';\r\nimport {valueOrDefault} from '../helpers/index.js';\r\n\r\n/**\r\n * @typedef { import('./element.point.js').default } PointElement\r\n */\r\n\r\nfunction setStyle(ctx, options, style = options) {\r\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\r\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\r\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\r\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\r\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\r\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\r\n}\r\n\r\nfunction lineTo(ctx, previous, target) {\r\n  ctx.lineTo(target.x, target.y);\r\n}\r\n\r\n/**\r\n * @returns {any}\r\n */\r\nfunction getLineMethod(options) {\r\n  if (options.stepped) {\r\n    return _steppedLineTo;\r\n  }\r\n\r\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\r\n    return _bezierCurveTo;\r\n  }\r\n\r\n  return lineTo;\r\n}\r\n\r\nfunction pathVars(points, segment, params = {}) {\r\n  const count = points.length;\r\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\r\n  const {start: segmentStart, end: segmentEnd} = segment;\r\n  const start = Math.max(paramsStart, segmentStart);\r\n  const end = Math.min(paramsEnd, segmentEnd);\r\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\r\n\r\n  return {\r\n    count,\r\n    start,\r\n    loop: segment.loop,\r\n    ilen: end < start && !outside ? count + end - start : end - start\r\n  };\r\n}\r\n\r\n/**\r\n * Create path from points, grouping by truncated x-coordinate\r\n * Points need to be in order by x-coordinate for this to work efficiently\r\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\r\n * @param {LineElement} line\r\n * @param {object} segment\r\n * @param {number} segment.start - start index of the segment, referring the points array\r\n * @param {number} segment.end - end index of the segment, referring the points array\r\n * @param {boolean} segment.loop - indicates that the segment is a loop\r\n * @param {object} params\r\n * @param {boolean} params.move - move to starting point (vs line to it)\r\n * @param {boolean} params.reverse - path the segment from end to start\r\n * @param {number} params.start - limit segment to points starting from `start` index\r\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\r\n */\r\nfunction pathSegment(ctx, line, segment, params) {\r\n  const {points, options} = line;\r\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\r\n  const lineMethod = getLineMethod(options);\r\n  // eslint-disable-next-line prefer-const\r\n  let {move = true, reverse} = params || {};\r\n  let i, point, prev;\r\n\r\n  for (i = 0; i <= ilen; ++i) {\r\n    point = points[(start + (reverse ? ilen - i : i)) % count];\r\n\r\n    if (point.skip) {\r\n      // If there is a skipped point inside a segment, spanGaps must be true\r\n      continue;\r\n    } else if (move) {\r\n      ctx.moveTo(point.x, point.y);\r\n      move = false;\r\n    } else {\r\n      lineMethod(ctx, prev, point, reverse, options.stepped);\r\n    }\r\n\r\n    prev = point;\r\n  }\r\n\r\n  if (loop) {\r\n    point = points[(start + (reverse ? ilen : 0)) % count];\r\n    lineMethod(ctx, prev, point, reverse, options.stepped);\r\n  }\r\n\r\n  return !!loop;\r\n}\r\n\r\n/**\r\n * Create path from points, grouping by truncated x-coordinate\r\n * Points need to be in order by x-coordinate for this to work efficiently\r\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\r\n * @param {LineElement} line\r\n * @param {object} segment\r\n * @param {number} segment.start - start index of the segment, referring the points array\r\n * @param {number} segment.end - end index of the segment, referring the points array\r\n * @param {boolean} segment.loop - indicates that the segment is a loop\r\n * @param {object} params\r\n * @param {boolean} params.move - move to starting point (vs line to it)\r\n * @param {boolean} params.reverse - path the segment from end to start\r\n * @param {number} params.start - limit segment to points starting from `start` index\r\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\r\n */\r\nfunction fastPathSegment(ctx, line, segment, params) {\r\n  const points = line.points;\r\n  const {count, start, ilen} = pathVars(points, segment, params);\r\n  const {move = true, reverse} = params || {};\r\n  let avgX = 0;\r\n  let countX = 0;\r\n  let i, point, prevX, minY, maxY, lastY;\r\n\r\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\r\n  const drawX = () => {\r\n    if (minY !== maxY) {\r\n      // Draw line to maxY and minY, using the average x-coordinate\r\n      ctx.lineTo(avgX, maxY);\r\n      ctx.lineTo(avgX, minY);\r\n      // Line to y-value of last point in group. So the line continues\r\n      // from correct position. Not using move, to have solid path.\r\n      ctx.lineTo(avgX, lastY);\r\n    }\r\n  };\r\n\r\n  if (move) {\r\n    point = points[pointIndex(0)];\r\n    ctx.moveTo(point.x, point.y);\r\n  }\r\n\r\n  for (i = 0; i <= ilen; ++i) {\r\n    point = points[pointIndex(i)];\r\n\r\n    if (point.skip) {\r\n      // If there is a skipped point inside a segment, spanGaps must be true\r\n      continue;\r\n    }\r\n\r\n    const x = point.x;\r\n    const y = point.y;\r\n    const truncX = x | 0; // truncated x-coordinate\r\n\r\n    if (truncX === prevX) {\r\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\r\n      if (y < minY) {\r\n        minY = y;\r\n      } else if (y > maxY) {\r\n        maxY = y;\r\n      }\r\n      // For first point in group, countX is `0`, so average will be `x` / 1.\r\n      avgX = (countX * avgX + x) / ++countX;\r\n    } else {\r\n      drawX();\r\n      // Draw line to next x-position, using the first (or only)\r\n      // y-value in that group\r\n      ctx.lineTo(x, y);\r\n\r\n      prevX = truncX;\r\n      countX = 0;\r\n      minY = maxY = y;\r\n    }\r\n    // Keep track of the last y-value in group\r\n    lastY = y;\r\n  }\r\n  drawX();\r\n}\r\n\r\n/**\r\n * @param {LineElement} line - the line\r\n * @returns {function}\r\n * @private\r\n */\r\nfunction _getSegmentMethod(line) {\r\n  const opts = line.options;\r\n  const borderDash = opts.borderDash && opts.borderDash.length;\r\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\r\n  return useFastPath ? fastPathSegment : pathSegment;\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nfunction _getInterpolationMethod(options) {\r\n  if (options.stepped) {\r\n    return _steppedInterpolation;\r\n  }\r\n\r\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\r\n    return _bezierInterpolation;\r\n  }\r\n\r\n  return _pointInLine;\r\n}\r\n\r\nfunction strokePathWithCache(ctx, line, start, count) {\r\n  let path = line._path;\r\n  if (!path) {\r\n    path = line._path = new Path2D();\r\n    if (line.path(path, start, count)) {\r\n      path.closePath();\r\n    }\r\n  }\r\n  setStyle(ctx, line.options);\r\n  ctx.stroke(path);\r\n}\r\n\r\nfunction strokePathDirect(ctx, line, start, count) {\r\n  const {segments, options} = line;\r\n  const segmentMethod = _getSegmentMethod(line);\r\n\r\n  for (const segment of segments) {\r\n    setStyle(ctx, options, segment.style);\r\n    ctx.beginPath();\r\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\r\n      ctx.closePath();\r\n    }\r\n    ctx.stroke();\r\n  }\r\n}\r\n\r\nconst usePath2D = typeof Path2D === 'function';\r\n\r\nfunction draw(ctx, line, start, count) {\r\n  if (usePath2D && !line.options.segment) {\r\n    strokePathWithCache(ctx, line, start, count);\r\n  } else {\r\n    strokePathDirect(ctx, line, start, count);\r\n  }\r\n}\r\n\r\nexport default class LineElement extends Element {\r\n\r\n  static id = 'line';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    borderCapStyle: 'butt',\r\n    borderDash: [],\r\n    borderDashOffset: 0,\r\n    borderJoinStyle: 'miter',\r\n    borderWidth: 3,\r\n    capBezierPoints: true,\r\n    cubicInterpolationMode: 'default',\r\n    fill: false,\r\n    spanGaps: false,\r\n    stepped: false,\r\n    tension: 0,\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaultRoutes = {\r\n    backgroundColor: 'backgroundColor',\r\n    borderColor: 'borderColor'\r\n  };\r\n\r\n\r\n  static descriptors = {\r\n    _scriptable: true,\r\n    _indexable: (name) => name !== 'borderDash' && name !== 'fill',\r\n  };\r\n\r\n\r\n  constructor(cfg) {\r\n    super();\r\n\r\n    this.animated = true;\r\n    this.options = undefined;\r\n    this._chart = undefined;\r\n    this._loop = undefined;\r\n    this._fullLoop = undefined;\r\n    this._path = undefined;\r\n    this._points = undefined;\r\n    this._segments = undefined;\r\n    this._decimated = false;\r\n    this._pointsUpdated = false;\r\n    this._datasetIndex = undefined;\r\n\r\n    if (cfg) {\r\n      Object.assign(this, cfg);\r\n    }\r\n  }\r\n\r\n  updateControlPoints(chartArea, indexAxis) {\r\n    const options = this.options;\r\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\r\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\r\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\r\n      this._pointsUpdated = true;\r\n    }\r\n  }\r\n\r\n  set points(points) {\r\n    this._points = points;\r\n    delete this._segments;\r\n    delete this._path;\r\n    this._pointsUpdated = false;\r\n  }\r\n\r\n  get points() {\r\n    return this._points;\r\n  }\r\n\r\n  get segments() {\r\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\r\n  }\r\n\r\n  /**\r\n\t * First non-skipped point on this line\r\n\t * @returns {PointElement|undefined}\r\n\t */\r\n  first() {\r\n    const segments = this.segments;\r\n    const points = this.points;\r\n    return segments.length && points[segments[0].start];\r\n  }\r\n\r\n  /**\r\n\t * Last non-skipped point on this line\r\n\t * @returns {PointElement|undefined}\r\n\t */\r\n  last() {\r\n    const segments = this.segments;\r\n    const points = this.points;\r\n    const count = segments.length;\r\n    return count && points[segments[count - 1].end];\r\n  }\r\n\r\n  /**\r\n\t * Interpolate a point in this line at the same value on `property` as\r\n\t * the reference `point` provided\r\n\t * @param {PointElement} point - the reference point\r\n\t * @param {string} property - the property to match on\r\n\t * @returns {PointElement|undefined}\r\n\t */\r\n  interpolate(point, property) {\r\n    const options = this.options;\r\n    const value = point[property];\r\n    const points = this.points;\r\n    const segments = _boundSegments(this, {property, start: value, end: value});\r\n\r\n    if (!segments.length) {\r\n      return;\r\n    }\r\n\r\n    const result = [];\r\n    const _interpolate = _getInterpolationMethod(options);\r\n    let i, ilen;\r\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\r\n      const {start, end} = segments[i];\r\n      const p1 = points[start];\r\n      const p2 = points[end];\r\n      if (p1 === p2) {\r\n        result.push(p1);\r\n        continue;\r\n      }\r\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\r\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\r\n      interpolated[property] = point[property];\r\n      result.push(interpolated);\r\n    }\r\n    return result.length === 1 ? result[0] : result;\r\n  }\r\n\r\n  /**\r\n\t * Append a segment of this line to current path.\r\n\t * @param {CanvasRenderingContext2D} ctx\r\n\t * @param {object} segment\r\n\t * @param {number} segment.start - start index of the segment, referring the points array\r\n \t * @param {number} segment.end - end index of the segment, referring the points array\r\n \t * @param {boolean} segment.loop - indicates that the segment is a loop\r\n\t * @param {object} params\r\n\t * @param {boolean} params.move - move to starting point (vs line to it)\r\n\t * @param {boolean} params.reverse - path the segment from end to start\r\n\t * @param {number} params.start - limit segment to points starting from `start` index\r\n\t * @param {number} params.end - limit segment to points ending at `start` + `count` index\r\n\t * @returns {undefined|boolean} - true if the segment is a full loop (path should be closed)\r\n\t */\r\n  pathSegment(ctx, segment, params) {\r\n    const segmentMethod = _getSegmentMethod(this);\r\n    return segmentMethod(ctx, this, segment, params);\r\n  }\r\n\r\n  /**\r\n\t * Append all segments of this line to current path.\r\n\t * @param {CanvasRenderingContext2D|Path2D} ctx\r\n\t * @param {number} [start]\r\n\t * @param {number} [count]\r\n\t * @returns {undefined|boolean} - true if line is a full loop (path should be closed)\r\n\t */\r\n  path(ctx, start, count) {\r\n    const segments = this.segments;\r\n    const segmentMethod = _getSegmentMethod(this);\r\n    let loop = this._loop;\r\n\r\n    start = start || 0;\r\n    count = count || (this.points.length - start);\r\n\r\n    for (const segment of segments) {\r\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\r\n    }\r\n    return !!loop;\r\n  }\r\n\r\n  /**\r\n\t * Draw\r\n\t * @param {CanvasRenderingContext2D} ctx\r\n\t * @param {object} chartArea\r\n\t * @param {number} [start]\r\n\t * @param {number} [count]\r\n\t */\r\n  draw(ctx, chartArea, start, count) {\r\n    const options = this.options || {};\r\n    const points = this.points || [];\r\n\r\n    if (points.length && options.borderWidth) {\r\n      ctx.save();\r\n\r\n      draw(ctx, this, start, count);\r\n\r\n      ctx.restore();\r\n    }\r\n\r\n    if (this.animated) {\r\n      // When line is animated, the control points and path are not cached.\r\n      this._pointsUpdated = false;\r\n      this._path = undefined;\r\n    }\r\n  }\r\n}\r\n","import Element from '../core/core.element.js';\r\nimport {drawPoint, _isPointInArea} from '../helpers/helpers.canvas.js';\r\nimport type {\r\n  CartesianParsedData,\r\n  ChartArea,\r\n  Point,\r\n  PointHoverOptions,\r\n  PointOptions,\r\n} from '../types/index.js';\r\n\r\nfunction inRange(el: PointElement, pos: number, axis: 'x' | 'y', useFinalPosition?: boolean) {\r\n  const options = el.options;\r\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\r\n\r\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\r\n}\r\n\r\nexport type PointProps = Point\r\n\r\nexport default class PointElement extends Element<PointProps, PointOptions & PointHoverOptions> {\r\n\r\n  static id = 'point';\r\n\r\n  parsed: CartesianParsedData;\r\n  skip?: boolean;\r\n  stop?: boolean;\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    borderWidth: 1,\r\n    hitRadius: 1,\r\n    hoverBorderWidth: 1,\r\n    hoverRadius: 4,\r\n    pointStyle: 'circle',\r\n    radius: 3,\r\n    rotation: 0\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaultRoutes = {\r\n    backgroundColor: 'backgroundColor',\r\n    borderColor: 'borderColor'\r\n  };\r\n\r\n  constructor(cfg) {\r\n    super();\r\n\r\n    this.options = undefined;\r\n    this.parsed = undefined;\r\n    this.skip = undefined;\r\n    this.stop = undefined;\r\n\r\n    if (cfg) {\r\n      Object.assign(this, cfg);\r\n    }\r\n  }\r\n\r\n  inRange(mouseX: number, mouseY: number, useFinalPosition?: boolean) {\r\n    const options = this.options;\r\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\r\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\r\n  }\r\n\r\n  inXRange(mouseX: number, useFinalPosition?: boolean) {\r\n    return inRange(this, mouseX, 'x', useFinalPosition);\r\n  }\r\n\r\n  inYRange(mouseY: number, useFinalPosition?: boolean) {\r\n    return inRange(this, mouseY, 'y', useFinalPosition);\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition?: boolean) {\r\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\r\n    return {x, y};\r\n  }\r\n\r\n  size(options?: Partial<PointOptions & PointHoverOptions>) {\r\n    options = options || this.options || {};\r\n    let radius = options.radius || 0;\r\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\r\n    const borderWidth = radius && options.borderWidth || 0;\r\n    return (radius + borderWidth) * 2;\r\n  }\r\n\r\n  draw(ctx: CanvasRenderingContext2D, area: ChartArea) {\r\n    const options = this.options;\r\n\r\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\r\n      return;\r\n    }\r\n\r\n    ctx.strokeStyle = options.borderColor;\r\n    ctx.lineWidth = options.borderWidth;\r\n    ctx.fillStyle = options.backgroundColor;\r\n    drawPoint(ctx, options, this.x, this.y);\r\n  }\r\n\r\n  getRange() {\r\n    const options = this.options || {};\r\n    // @ts-expect-error Fallbacks should never be hit in practice\r\n    return options.radius + options.hitRadius;\r\n  }\r\n}\r\n","import Element from '../core/core.element.js';\r\nimport {isObject, _isBetween, _limitValue} from '../helpers/index.js';\r\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\r\nimport {toTRBL, toTRBLCorners} from '../helpers/helpers.options.js';\r\n\r\n/** @typedef {{ x: number, y: number, base: number, horizontal: boolean, width: number, height: number }} BarProps */\r\n\r\n/**\r\n * Helper function to get the bounds of the bar regardless of the orientation\r\n * @param {BarElement} bar the bar\r\n * @param {boolean} [useFinalPosition]\r\n * @return {object} bounds of the bar\r\n * @private\r\n */\r\nfunction getBarBounds(bar, useFinalPosition) {\r\n  const {x, y, base, width, height} = /** @type {BarProps} */ (bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition));\r\n\r\n  let left, right, top, bottom, half;\r\n\r\n  if (bar.horizontal) {\r\n    half = height / 2;\r\n    left = Math.min(x, base);\r\n    right = Math.max(x, base);\r\n    top = y - half;\r\n    bottom = y + half;\r\n  } else {\r\n    half = width / 2;\r\n    left = x - half;\r\n    right = x + half;\r\n    top = Math.min(y, base);\r\n    bottom = Math.max(y, base);\r\n  }\r\n\r\n  return {left, top, right, bottom};\r\n}\r\n\r\nfunction skipOrLimit(skip, value, min, max) {\r\n  return skip ? 0 : _limitValue(value, min, max);\r\n}\r\n\r\nfunction parseBorderWidth(bar, maxW, maxH) {\r\n  const value = bar.options.borderWidth;\r\n  const skip = bar.borderSkipped;\r\n  const o = toTRBL(value);\r\n\r\n  return {\r\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\r\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\r\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\r\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\r\n  };\r\n}\r\n\r\nfunction parseBorderRadius(bar, maxW, maxH) {\r\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\r\n  const value = bar.options.borderRadius;\r\n  const o = toTRBLCorners(value);\r\n  const maxR = Math.min(maxW, maxH);\r\n  const skip = bar.borderSkipped;\r\n\r\n  // If the value is an object, assume the user knows what they are doing\r\n  // and apply as directed.\r\n  const enableBorder = enableBorderRadius || isObject(value);\r\n\r\n  return {\r\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\r\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\r\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\r\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\r\n  };\r\n}\r\n\r\nfunction boundingRects(bar) {\r\n  const bounds = getBarBounds(bar);\r\n  const width = bounds.right - bounds.left;\r\n  const height = bounds.bottom - bounds.top;\r\n  const border = parseBorderWidth(bar, width / 2, height / 2);\r\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\r\n\r\n  return {\r\n    outer: {\r\n      x: bounds.left,\r\n      y: bounds.top,\r\n      w: width,\r\n      h: height,\r\n      radius\r\n    },\r\n    inner: {\r\n      x: bounds.left + border.l,\r\n      y: bounds.top + border.t,\r\n      w: width - border.l - border.r,\r\n      h: height - border.t - border.b,\r\n      radius: {\r\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\r\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\r\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\r\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nfunction inRange(bar, x, y, useFinalPosition) {\r\n  const skipX = x === null;\r\n  const skipY = y === null;\r\n  const skipBoth = skipX && skipY;\r\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\r\n\r\n  return bounds\r\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\r\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\r\n}\r\n\r\nfunction hasRadius(radius) {\r\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\r\n}\r\n\r\n/**\r\n * Add a path of a rectangle to the current sub-path\r\n * @param {CanvasRenderingContext2D} ctx Context\r\n * @param {*} rect Bounding rect\r\n */\r\nfunction addNormalRectPath(ctx, rect) {\r\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\r\n}\r\n\r\nfunction inflateRect(rect, amount, refRect = {}) {\r\n  const x = rect.x !== refRect.x ? -amount : 0;\r\n  const y = rect.y !== refRect.y ? -amount : 0;\r\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\r\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\r\n  return {\r\n    x: rect.x + x,\r\n    y: rect.y + y,\r\n    w: rect.w + w,\r\n    h: rect.h + h,\r\n    radius: rect.radius\r\n  };\r\n}\r\n\r\nexport default class BarElement extends Element {\r\n\r\n  static id = 'bar';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    borderSkipped: 'start',\r\n    borderWidth: 0,\r\n    borderRadius: 0,\r\n    inflateAmount: 'auto',\r\n    pointStyle: undefined\r\n  };\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaultRoutes = {\r\n    backgroundColor: 'backgroundColor',\r\n    borderColor: 'borderColor'\r\n  };\r\n\r\n  constructor(cfg) {\r\n    super();\r\n\r\n    this.options = undefined;\r\n    this.horizontal = undefined;\r\n    this.base = undefined;\r\n    this.width = undefined;\r\n    this.height = undefined;\r\n    this.inflateAmount = undefined;\r\n\r\n    if (cfg) {\r\n      Object.assign(this, cfg);\r\n    }\r\n  }\r\n\r\n  draw(ctx) {\r\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\r\n    const {inner, outer} = boundingRects(this);\r\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\r\n\r\n    ctx.save();\r\n\r\n    if (outer.w !== inner.w || outer.h !== inner.h) {\r\n      ctx.beginPath();\r\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\r\n      ctx.clip();\r\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\r\n      ctx.fillStyle = borderColor;\r\n      ctx.fill('evenodd');\r\n    }\r\n\r\n    ctx.beginPath();\r\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\r\n    ctx.fillStyle = backgroundColor;\r\n    ctx.fill();\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  inRange(mouseX, mouseY, useFinalPosition) {\r\n    return inRange(this, mouseX, mouseY, useFinalPosition);\r\n  }\r\n\r\n  inXRange(mouseX, useFinalPosition) {\r\n    return inRange(this, mouseX, null, useFinalPosition);\r\n  }\r\n\r\n  inYRange(mouseY, useFinalPosition) {\r\n    return inRange(this, null, mouseY, useFinalPosition);\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition) {\r\n    const {x, y, base, horizontal} = /** @type {BarProps} */ (this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition));\r\n    return {\r\n      x: horizontal ? (x + base) / 2 : x,\r\n      y: horizontal ? y : (y + base) / 2\r\n    };\r\n  }\r\n\r\n  getRange(axis) {\r\n    return axis === 'x' ? this.width / 2 : this.height / 2;\r\n  }\r\n}\r\n","import Scale from '../core/core.scale.js';\r\nimport {isNullOrUndef, valueOrDefault, _limitValue} from '../helpers/index.js';\r\n\r\nconst addIfString = (labels, raw, index, addedLabels) => {\r\n  if (typeof raw === 'string') {\r\n    index = labels.push(raw) - 1;\r\n    addedLabels.unshift({index, label: raw});\r\n  } else if (isNaN(raw)) {\r\n    index = null;\r\n  }\r\n  return index;\r\n};\r\n\r\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\r\n  const first = labels.indexOf(raw);\r\n  if (first === -1) {\r\n    return addIfString(labels, raw, index, addedLabels);\r\n  }\r\n  const last = labels.lastIndexOf(raw);\r\n  return first !== last ? index : first;\r\n}\r\n\r\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\r\n\r\nfunction _getLabelForValue(value) {\r\n  const labels = this.getLabels();\r\n\r\n  if (value >= 0 && value < labels.length) {\r\n    return labels[value];\r\n  }\r\n  return value;\r\n}\r\n\r\nexport default class CategoryScale extends Scale {\r\n\r\n  static id = 'category';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    ticks: {\r\n      callback: _getLabelForValue\r\n    }\r\n  };\r\n\r\n  constructor(cfg) {\r\n    super(cfg);\r\n\r\n    /** @type {number} */\r\n    this._startValue = undefined;\r\n    this._valueRange = 0;\r\n    this._addedLabels = [];\r\n  }\r\n\r\n  init(scaleOptions) {\r\n    const added = this._addedLabels;\r\n    if (added.length) {\r\n      const labels = this.getLabels();\r\n      for (const {index, label} of added) {\r\n        if (labels[index] === label) {\r\n          labels.splice(index, 1);\r\n        }\r\n      }\r\n      this._addedLabels = [];\r\n    }\r\n    super.init(scaleOptions);\r\n  }\r\n\r\n  parse(raw, index) {\r\n    if (isNullOrUndef(raw)) {\r\n      return null;\r\n    }\r\n    const labels = this.getLabels();\r\n    index = isFinite(index) && labels[index] === raw ? index\r\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\r\n    return validIndex(index, labels.length - 1);\r\n  }\r\n\r\n  determineDataLimits() {\r\n    const {minDefined, maxDefined} = this.getUserBounds();\r\n    let {min, max} = this.getMinMax(true);\r\n\r\n    if (this.options.bounds === 'ticks') {\r\n      if (!minDefined) {\r\n        min = 0;\r\n      }\r\n      if (!maxDefined) {\r\n        max = this.getLabels().length - 1;\r\n      }\r\n    }\r\n\r\n    this.min = min;\r\n    this.max = max;\r\n  }\r\n\r\n  buildTicks() {\r\n    const min = this.min;\r\n    const max = this.max;\r\n    const offset = this.options.offset;\r\n    const ticks = [];\r\n    let labels = this.getLabels();\r\n\r\n    // If we are viewing some subset of labels, slice the original array\r\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\r\n\r\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\r\n    this._startValue = this.min - (offset ? 0.5 : 0);\r\n\r\n    for (let value = min; value <= max; value++) {\r\n      ticks.push({value});\r\n    }\r\n    return ticks;\r\n  }\r\n\r\n  getLabelForValue(value) {\r\n    return _getLabelForValue.call(this, value);\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  configure() {\r\n    super.configure();\r\n\r\n    if (!this.isHorizontal()) {\r\n      // For backward compatibility, vertical category scale reverse is inverted.\r\n      this._reversePixels = !this._reversePixels;\r\n    }\r\n  }\r\n\r\n  // Used to get data value locations. Value can either be an index or a numerical value\r\n  getPixelForValue(value) {\r\n    if (typeof value !== 'number') {\r\n      value = this.parse(value);\r\n    }\r\n\r\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\r\n  }\r\n\r\n  // Must override base implementation because it calls getPixelForValue\r\n  // and category scale can have duplicate values\r\n  getPixelForTick(index) {\r\n    const ticks = this.ticks;\r\n    if (index < 0 || index > ticks.length - 1) {\r\n      return null;\r\n    }\r\n    return this.getPixelForValue(ticks[index].value);\r\n  }\r\n\r\n  getValueForPixel(pixel) {\r\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\r\n  }\r\n\r\n  getBasePixel() {\r\n    return this.bottom;\r\n  }\r\n}\r\n","import {isNullOrUndef} from '../helpers/helpers.core.js';\r\nimport {almostEquals, almostWhole, niceNum, _decimalPlaces, _setMinAndMaxByKey, sign, toRadians} from '../helpers/helpers.math.js';\r\nimport Scale from '../core/core.scale.js';\r\nimport {formatNumber} from '../helpers/helpers.intl.js';\r\n\r\n/**\r\n * Generate a set of linear ticks for an axis\r\n * 1. If generationOptions.min, generationOptions.max, and generationOptions.step are defined:\r\n *    if (max - min) / step is an integer, ticks are generated as [min, min + step, ..., max]\r\n *    Note that the generationOptions.maxCount setting is respected in this scenario\r\n *\r\n * 2. If generationOptions.min, generationOptions.max, and generationOptions.count is defined\r\n *    spacing = (max - min) / count\r\n *    Ticks are generated as [min, min + spacing, ..., max]\r\n *\r\n * 3. If generationOptions.count is defined\r\n *    spacing = (niceMax - niceMin) / count\r\n *\r\n * 4. Compute optimal spacing of ticks using niceNum algorithm\r\n *\r\n * @param generationOptions the options used to generate the ticks\r\n * @param dataRange the range of the data\r\n * @returns {object[]} array of tick objects\r\n */\r\nfunction generateTicks(generationOptions, dataRange) {\r\n  const ticks = [];\r\n  // To get a \"nice\" value for the tick spacing, we will use the appropriately named\r\n  // \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\r\n  // for details.\r\n\r\n  const MIN_SPACING = 1e-14;\r\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\r\n  const unit = step || 1;\r\n  const maxSpaces = maxTicks - 1;\r\n  const {min: rmin, max: rmax} = dataRange;\r\n  const minDefined = !isNullOrUndef(min);\r\n  const maxDefined = !isNullOrUndef(max);\r\n  const countDefined = !isNullOrUndef(count);\r\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\r\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\r\n  let factor, niceMin, niceMax, numSpaces;\r\n\r\n  // Beyond MIN_SPACING floating point numbers being to lose precision\r\n  // such that we can't do the math necessary to generate ticks\r\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\r\n    return [{value: rmin}, {value: rmax}];\r\n  }\r\n\r\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\r\n  if (numSpaces > maxSpaces) {\r\n    // If the calculated num of spaces exceeds maxNumSpaces, recalculate it\r\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\r\n  }\r\n\r\n  if (!isNullOrUndef(precision)) {\r\n    // If the user specified a precision, round to that number of decimal places\r\n    factor = Math.pow(10, precision);\r\n    spacing = Math.ceil(spacing * factor) / factor;\r\n  }\r\n\r\n  if (bounds === 'ticks') {\r\n    niceMin = Math.floor(rmin / spacing) * spacing;\r\n    niceMax = Math.ceil(rmax / spacing) * spacing;\r\n  } else {\r\n    niceMin = rmin;\r\n    niceMax = rmax;\r\n  }\r\n\r\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\r\n    // Case 1: If min, max and stepSize are set and they make an evenly spaced scale use it.\r\n    // spacing = step;\r\n    // numSpaces = (max - min) / spacing;\r\n    // Note that we round here to handle the case where almostWhole translated an FP error\r\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\r\n    spacing = (max - min) / numSpaces;\r\n    niceMin = min;\r\n    niceMax = max;\r\n  } else if (countDefined) {\r\n    // Cases 2 & 3, we have a count specified. Handle optional user defined edges to the range.\r\n    // Sometimes these are no-ops, but it makes the code a lot clearer\r\n    // and when a user defined range is specified, we want the correct ticks\r\n    niceMin = minDefined ? min : niceMin;\r\n    niceMax = maxDefined ? max : niceMax;\r\n    numSpaces = count - 1;\r\n    spacing = (niceMax - niceMin) / numSpaces;\r\n  } else {\r\n    // Case 4\r\n    numSpaces = (niceMax - niceMin) / spacing;\r\n\r\n    // If very close to our rounded value, use it.\r\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\r\n      numSpaces = Math.round(numSpaces);\r\n    } else {\r\n      numSpaces = Math.ceil(numSpaces);\r\n    }\r\n  }\r\n\r\n  // The spacing will have changed in cases 1, 2, and 3 so the factor cannot be computed\r\n  // until this point\r\n  const decimalPlaces = Math.max(\r\n    _decimalPlaces(spacing),\r\n    _decimalPlaces(niceMin)\r\n  );\r\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\r\n  niceMin = Math.round(niceMin * factor) / factor;\r\n  niceMax = Math.round(niceMax * factor) / factor;\r\n\r\n  let j = 0;\r\n  if (minDefined) {\r\n    if (includeBounds && niceMin !== min) {\r\n      ticks.push({value: min});\r\n\r\n      if (niceMin < min) {\r\n        j++; // Skip niceMin\r\n      }\r\n      // If the next nice tick is close to min, skip it\r\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\r\n        j++;\r\n      }\r\n    } else if (niceMin < min) {\r\n      j++;\r\n    }\r\n  }\r\n\r\n  for (; j < numSpaces; ++j) {\r\n    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\r\n    if (maxDefined && tickValue > max) {\r\n      break;\r\n    }\r\n    ticks.push({value: tickValue});\r\n  }\r\n\r\n  if (maxDefined && includeBounds && niceMax !== max) {\r\n    // If the previous tick is too close to max, replace it with max, else add max\r\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\r\n      ticks[ticks.length - 1].value = max;\r\n    } else {\r\n      ticks.push({value: max});\r\n    }\r\n  } else if (!maxDefined || niceMax === max) {\r\n    ticks.push({value: niceMax});\r\n  }\r\n\r\n  return ticks;\r\n}\r\n\r\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\r\n  const rad = toRadians(minRotation);\r\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\r\n  const length = 0.75 * minSpacing * ('' + value).length;\r\n  return Math.min(minSpacing / ratio, length);\r\n}\r\n\r\nexport default class LinearScaleBase extends Scale {\r\n\r\n  constructor(cfg) {\r\n    super(cfg);\r\n\r\n    /** @type {number} */\r\n    this.start = undefined;\r\n    /** @type {number} */\r\n    this.end = undefined;\r\n    /** @type {number} */\r\n    this._startValue = undefined;\r\n    /** @type {number} */\r\n    this._endValue = undefined;\r\n    this._valueRange = 0;\r\n  }\r\n\r\n  parse(raw, index) { // eslint-disable-line no-unused-vars\r\n    if (isNullOrUndef(raw)) {\r\n      return null;\r\n    }\r\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\r\n      return null;\r\n    }\r\n\r\n    return +raw;\r\n  }\r\n\r\n  handleTickRangeOptions() {\r\n    const {beginAtZero} = this.options;\r\n    const {minDefined, maxDefined} = this.getUserBounds();\r\n    let {min, max} = this;\r\n\r\n    const setMin = v => (min = minDefined ? min : v);\r\n    const setMax = v => (max = maxDefined ? max : v);\r\n\r\n    if (beginAtZero) {\r\n      const minSign = sign(min);\r\n      const maxSign = sign(max);\r\n\r\n      if (minSign < 0 && maxSign < 0) {\r\n        setMax(0);\r\n      } else if (minSign > 0 && maxSign > 0) {\r\n        setMin(0);\r\n      }\r\n    }\r\n\r\n    if (min === max) {\r\n      let offset = max === 0 ? 1 : Math.abs(max * 0.05);\r\n\r\n      setMax(max + offset);\r\n\r\n      if (!beginAtZero) {\r\n        setMin(min - offset);\r\n      }\r\n    }\r\n    this.min = min;\r\n    this.max = max;\r\n  }\r\n\r\n  getTickLimit() {\r\n    const tickOpts = this.options.ticks;\r\n    // eslint-disable-next-line prefer-const\r\n    let {maxTicksLimit, stepSize} = tickOpts;\r\n    let maxTicks;\r\n\r\n    if (stepSize) {\r\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\r\n      if (maxTicks > 1000) {\r\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\r\n        maxTicks = 1000;\r\n      }\r\n    } else {\r\n      maxTicks = this.computeTickLimit();\r\n      maxTicksLimit = maxTicksLimit || 11;\r\n    }\r\n\r\n    if (maxTicksLimit) {\r\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\r\n    }\r\n\r\n    return maxTicks;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  computeTickLimit() {\r\n    return Number.POSITIVE_INFINITY;\r\n  }\r\n\r\n  buildTicks() {\r\n    const opts = this.options;\r\n    const tickOpts = opts.ticks;\r\n\r\n    // Figure out what the max number of ticks we can support it is based on the size of\r\n    // the axis area. For now, we say that the minimum tick spacing in pixels must be 40\r\n    // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\r\n    // the graph. Make sure we always have at least 2 ticks\r\n    let maxTicks = this.getTickLimit();\r\n    maxTicks = Math.max(2, maxTicks);\r\n\r\n    const numericGeneratorOptions = {\r\n      maxTicks,\r\n      bounds: opts.bounds,\r\n      min: opts.min,\r\n      max: opts.max,\r\n      precision: tickOpts.precision,\r\n      step: tickOpts.stepSize,\r\n      count: tickOpts.count,\r\n      maxDigits: this._maxDigits(),\r\n      horizontal: this.isHorizontal(),\r\n      minRotation: tickOpts.minRotation || 0,\r\n      includeBounds: tickOpts.includeBounds !== false\r\n    };\r\n    const dataRange = this._range || this;\r\n    const ticks = generateTicks(numericGeneratorOptions, dataRange);\r\n\r\n    // At this point, we need to update our max and min given the tick values,\r\n    // since we probably have expanded the range of the scale\r\n    if (opts.bounds === 'ticks') {\r\n      _setMinAndMaxByKey(ticks, this, 'value');\r\n    }\r\n\r\n    if (opts.reverse) {\r\n      ticks.reverse();\r\n\r\n      this.start = this.max;\r\n      this.end = this.min;\r\n    } else {\r\n      this.start = this.min;\r\n      this.end = this.max;\r\n    }\r\n\r\n    return ticks;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  configure() {\r\n    const ticks = this.ticks;\r\n    let start = this.min;\r\n    let end = this.max;\r\n\r\n    super.configure();\r\n\r\n    if (this.options.offset && ticks.length) {\r\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\r\n      start -= offset;\r\n      end += offset;\r\n    }\r\n    this._startValue = start;\r\n    this._endValue = end;\r\n    this._valueRange = end - start;\r\n  }\r\n\r\n  getLabelForValue(value) {\r\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\r\n  }\r\n}\r\n","import {isFinite} from '../helpers/helpers.core.js';\r\nimport LinearScaleBase from './scale.linearbase.js';\r\nimport Ticks from '../core/core.ticks.js';\r\nimport {toRadians} from '../helpers/index.js';\r\n\r\nexport default class LinearScale extends LinearScaleBase {\r\n\r\n  static id = 'linear';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    ticks: {\r\n      callback: Ticks.formatters.numeric\r\n    }\r\n  };\r\n\r\n\r\n  determineDataLimits() {\r\n    const {min, max} = this.getMinMax(true);\r\n\r\n    this.min = isFinite(min) ? min : 0;\r\n    this.max = isFinite(max) ? max : 1;\r\n\r\n    // Common base implementation to handle min, max, beginAtZero\r\n    this.handleTickRangeOptions();\r\n  }\r\n\r\n  /**\r\n\t * Returns the maximum number of ticks based on the scale dimension\r\n\t * @protected\r\n \t */\r\n  computeTickLimit() {\r\n    const horizontal = this.isHorizontal();\r\n    const length = horizontal ? this.width : this.height;\r\n    const minRotation = toRadians(this.options.ticks.minRotation);\r\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\r\n    const tickFont = this._resolveTickFontOptions(0);\r\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\r\n  }\r\n\r\n  // Utils\r\n  getPixelForValue(value) {\r\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\r\n  }\r\n\r\n  getValueForPixel(pixel) {\r\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\r\n  }\r\n}\r\n","import {finiteOrDefault, isFinite} from '../helpers/helpers.core.js';\r\nimport {formatNumber} from '../helpers/helpers.intl.js';\r\nimport {_setMinAndMaxByKey, log10} from '../helpers/helpers.math.js';\r\nimport Scale from '../core/core.scale.js';\r\nimport LinearScaleBase from './scale.linearbase.js';\r\nimport Ticks from '../core/core.ticks.js';\r\n\r\nconst log10Floor = v => Math.floor(log10(v));\r\nconst changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);\r\n\r\nfunction isMajor(tickVal) {\r\n  const remain = tickVal / (Math.pow(10, log10Floor(tickVal)));\r\n  return remain === 1;\r\n}\r\n\r\nfunction steps(min, max, rangeExp) {\r\n  const rangeStep = Math.pow(10, rangeExp);\r\n  const start = Math.floor(min / rangeStep);\r\n  const end = Math.ceil(max / rangeStep);\r\n  return end - start;\r\n}\r\n\r\nfunction startExp(min, max) {\r\n  const range = max - min;\r\n  let rangeExp = log10Floor(range);\r\n  while (steps(min, max, rangeExp) > 10) {\r\n    rangeExp++;\r\n  }\r\n  while (steps(min, max, rangeExp) < 10) {\r\n    rangeExp--;\r\n  }\r\n  return Math.min(rangeExp, log10Floor(min));\r\n}\r\n\r\n\r\n/**\r\n * Generate a set of logarithmic ticks\r\n * @param generationOptions the options used to generate the ticks\r\n * @param dataRange the range of the data\r\n * @returns {object[]} array of tick objects\r\n */\r\nfunction generateTicks(generationOptions, {min, max}) {\r\n  min = finiteOrDefault(generationOptions.min, min);\r\n  const ticks = [];\r\n  const minExp = log10Floor(min);\r\n  let exp = startExp(min, max);\r\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\r\n  const stepSize = Math.pow(10, exp);\r\n  const base = minExp > exp ? Math.pow(10, minExp) : 0;\r\n  const start = Math.round((min - base) * precision) / precision;\r\n  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\r\n  let significand = Math.floor((start - offset) / Math.pow(10, exp));\r\n  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\r\n  while (value < max) {\r\n    ticks.push({value, major: isMajor(value), significand});\r\n    if (significand >= 10) {\r\n      significand = significand < 15 ? 15 : 20;\r\n    } else {\r\n      significand++;\r\n    }\r\n    if (significand >= 20) {\r\n      exp++;\r\n      significand = 2;\r\n      precision = exp >= 0 ? 1 : precision;\r\n    }\r\n    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\r\n  }\r\n  const lastTick = finiteOrDefault(generationOptions.max, value);\r\n  ticks.push({value: lastTick, major: isMajor(lastTick), significand});\r\n\r\n  return ticks;\r\n}\r\n\r\nexport default class LogarithmicScale extends Scale {\r\n\r\n  static id = 'logarithmic';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    ticks: {\r\n      callback: Ticks.formatters.logarithmic,\r\n      major: {\r\n        enabled: true\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  constructor(cfg) {\r\n    super(cfg);\r\n\r\n    /** @type {number} */\r\n    this.start = undefined;\r\n    /** @type {number} */\r\n    this.end = undefined;\r\n    /** @type {number} */\r\n    this._startValue = undefined;\r\n    this._valueRange = 0;\r\n  }\r\n\r\n  parse(raw, index) {\r\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\r\n    if (value === 0) {\r\n      this._zero = true;\r\n      return undefined;\r\n    }\r\n    return isFinite(value) && value > 0 ? value : null;\r\n  }\r\n\r\n  determineDataLimits() {\r\n    const {min, max} = this.getMinMax(true);\r\n\r\n    this.min = isFinite(min) ? Math.max(0, min) : null;\r\n    this.max = isFinite(max) ? Math.max(0, max) : null;\r\n\r\n    if (this.options.beginAtZero) {\r\n      this._zero = true;\r\n    }\r\n\r\n    // if data has `0` in it or `beginAtZero` is true, min (non zero) value is at bottom\r\n    // of scale, and it does not equal suggestedMin, lower the min bound by one exp.\r\n    if (this._zero && this.min !== this._suggestedMin && !isFinite(this._userMin)) {\r\n      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\r\n    }\r\n\r\n    this.handleTickRangeOptions();\r\n  }\r\n\r\n  handleTickRangeOptions() {\r\n    const {minDefined, maxDefined} = this.getUserBounds();\r\n    let min = this.min;\r\n    let max = this.max;\r\n\r\n    const setMin = v => (min = minDefined ? min : v);\r\n    const setMax = v => (max = maxDefined ? max : v);\r\n\r\n    if (min === max) {\r\n      if (min <= 0) { // includes null\r\n        setMin(1);\r\n        setMax(10);\r\n      } else {\r\n        setMin(changeExponent(min, -1));\r\n        setMax(changeExponent(max, +1));\r\n      }\r\n    }\r\n    if (min <= 0) {\r\n      setMin(changeExponent(max, -1));\r\n    }\r\n    if (max <= 0) {\r\n\r\n      setMax(changeExponent(min, +1));\r\n    }\r\n\r\n    this.min = min;\r\n    this.max = max;\r\n  }\r\n\r\n  buildTicks() {\r\n    const opts = this.options;\r\n\r\n    const generationOptions = {\r\n      min: this._userMin,\r\n      max: this._userMax\r\n    };\r\n    const ticks = generateTicks(generationOptions, this);\r\n\r\n    // At this point, we need to update our max and min given the tick values,\r\n    // since we probably have expanded the range of the scale\r\n    if (opts.bounds === 'ticks') {\r\n      _setMinAndMaxByKey(ticks, this, 'value');\r\n    }\r\n\r\n    if (opts.reverse) {\r\n      ticks.reverse();\r\n\r\n      this.start = this.max;\r\n      this.end = this.min;\r\n    } else {\r\n      this.start = this.min;\r\n      this.end = this.max;\r\n    }\r\n\r\n    return ticks;\r\n  }\r\n\r\n  /**\r\n\t * @param {number} value\r\n\t * @return {string}\r\n\t */\r\n  getLabelForValue(value) {\r\n    return value === undefined\r\n      ? '0'\r\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  configure() {\r\n    const start = this.min;\r\n\r\n    super.configure();\r\n\r\n    this._startValue = log10(start);\r\n    this._valueRange = log10(this.max) - log10(start);\r\n  }\r\n\r\n  getPixelForValue(value) {\r\n    if (value === undefined || value === 0) {\r\n      value = this.min;\r\n    }\r\n    if (value === null || isNaN(value)) {\r\n      return NaN;\r\n    }\r\n    return this.getPixelForDecimal(value === this.min\r\n      ? 0\r\n      : (log10(value) - this._startValue) / this._valueRange);\r\n  }\r\n\r\n  getValueForPixel(pixel) {\r\n    const decimal = this.getDecimalForPixel(pixel);\r\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\r\n  }\r\n}\r\n","import defaults from '../core/core.defaults.js';\r\nimport {_longestText, addRoundedRectPath, renderText} from '../helpers/helpers.canvas.js';\r\nimport {HALF_PI, TAU, toDegrees, toRadians, _normalizeAngle, PI} from '../helpers/helpers.math.js';\r\nimport LinearScaleBase from './scale.linearbase.js';\r\nimport Ticks from '../core/core.ticks.js';\r\nimport {valueOrDefault, isArray, isFinite, callback as callCallback, isNullOrUndef} from '../helpers/helpers.core.js';\r\nimport {createContext, toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\r\n\r\nfunction getTickBackdropHeight(opts) {\r\n  const tickOpts = opts.ticks;\r\n\r\n  if (tickOpts.display && opts.display) {\r\n    const padding = toPadding(tickOpts.backdropPadding);\r\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\r\n  }\r\n  return 0;\r\n}\r\n\r\nfunction measureLabelSize(ctx, font, label) {\r\n  label = isArray(label) ? label : [label];\r\n  return {\r\n    w: _longestText(ctx, font.string, label),\r\n    h: label.length * font.lineHeight\r\n  };\r\n}\r\n\r\nfunction determineLimits(angle, pos, size, min, max) {\r\n  if (angle === min || angle === max) {\r\n    return {\r\n      start: pos - (size / 2),\r\n      end: pos + (size / 2)\r\n    };\r\n  } else if (angle < min || angle > max) {\r\n    return {\r\n      start: pos - size,\r\n      end: pos\r\n    };\r\n  }\r\n\r\n  return {\r\n    start: pos,\r\n    end: pos + size\r\n  };\r\n}\r\n\r\n/**\r\n * Helper function to fit a radial linear scale with point labels\r\n */\r\nfunction fitWithPointLabels(scale) {\r\n\r\n  // Right, this is really confusing and there is a lot of maths going on here\r\n  // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\r\n  //\r\n  // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\r\n  //\r\n  // Solution:\r\n  //\r\n  // We assume the radius of the polygon is half the size of the canvas at first\r\n  // at each index we check if the text overlaps.\r\n  //\r\n  // Where it does, we store that angle and that index.\r\n  //\r\n  // After finding the largest index and angle we calculate how much we need to remove\r\n  // from the shape radius to move the point inwards by that x.\r\n  //\r\n  // We average the left and right distances to get the maximum shape radius that can fit in the box\r\n  // along with labels.\r\n  //\r\n  // Once we have that, we can find the centre point for the chart, by taking the x text protrusion\r\n  // on each side, removing that from the size, halving it and adding the left x protrusion width.\r\n  //\r\n  // This will mean we have a shape fitted to the canvas, as large as it can be with the labels\r\n  // and position it in the most space efficient manner\r\n  //\r\n  // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\r\n\r\n  // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\r\n  // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\r\n  const orig = {\r\n    l: scale.left + scale._padding.left,\r\n    r: scale.right - scale._padding.right,\r\n    t: scale.top + scale._padding.top,\r\n    b: scale.bottom - scale._padding.bottom\r\n  };\r\n  const limits = Object.assign({}, orig);\r\n  const labelSizes = [];\r\n  const padding = [];\r\n  const valueCount = scale._pointLabels.length;\r\n  const pointLabelOpts = scale.options.pointLabels;\r\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\r\n\r\n  for (let i = 0; i < valueCount; i++) {\r\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\r\n    padding[i] = opts.padding;\r\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\r\n    const plFont = toFont(opts.font);\r\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\r\n    labelSizes[i] = textSize;\r\n\r\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\r\n    const angle = Math.round(toDegrees(angleRadians));\r\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\r\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\r\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\r\n  }\r\n\r\n  scale.setCenterPoint(\r\n    orig.l - limits.l,\r\n    limits.r - orig.r,\r\n    orig.t - limits.t,\r\n    limits.b - orig.b\r\n  );\r\n\r\n  // Now that text size is determined, compute the full positions\r\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\r\n}\r\n\r\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\r\n  const sin = Math.abs(Math.sin(angle));\r\n  const cos = Math.abs(Math.cos(angle));\r\n  let x = 0;\r\n  let y = 0;\r\n  if (hLimits.start < orig.l) {\r\n    x = (orig.l - hLimits.start) / sin;\r\n    limits.l = Math.min(limits.l, orig.l - x);\r\n  } else if (hLimits.end > orig.r) {\r\n    x = (hLimits.end - orig.r) / sin;\r\n    limits.r = Math.max(limits.r, orig.r + x);\r\n  }\r\n  if (vLimits.start < orig.t) {\r\n    y = (orig.t - vLimits.start) / cos;\r\n    limits.t = Math.min(limits.t, orig.t - y);\r\n  } else if (vLimits.end > orig.b) {\r\n    y = (vLimits.end - orig.b) / cos;\r\n    limits.b = Math.max(limits.b, orig.b + y);\r\n  }\r\n}\r\n\r\nfunction buildPointLabelItems(scale, labelSizes, padding) {\r\n  const items = [];\r\n  const valueCount = scale._pointLabels.length;\r\n  const opts = scale.options;\r\n  const extra = getTickBackdropHeight(opts) / 2;\r\n  const outerDistance = scale.drawingArea;\r\n  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;\r\n\r\n  for (let i = 0; i < valueCount; i++) {\r\n    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);\r\n    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\r\n    const size = labelSizes[i];\r\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\r\n    const textAlign = getTextAlignForAngle(angle);\r\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\r\n\r\n    items.push({\r\n      // Text position\r\n      x: pointLabelPosition.x,\r\n      y,\r\n\r\n      // Text rendering data\r\n      textAlign,\r\n\r\n      // Bounding box\r\n      left,\r\n      top: y,\r\n      right: left + size.w,\r\n      bottom: y + size.h\r\n    });\r\n  }\r\n  return items;\r\n}\r\n\r\nfunction getTextAlignForAngle(angle) {\r\n  if (angle === 0 || angle === 180) {\r\n    return 'center';\r\n  } else if (angle < 180) {\r\n    return 'left';\r\n  }\r\n\r\n  return 'right';\r\n}\r\n\r\nfunction leftForTextAlign(x, w, align) {\r\n  if (align === 'right') {\r\n    x -= w;\r\n  } else if (align === 'center') {\r\n    x -= (w / 2);\r\n  }\r\n  return x;\r\n}\r\n\r\nfunction yForAngle(y, h, angle) {\r\n  if (angle === 90 || angle === 270) {\r\n    y -= (h / 2);\r\n  } else if (angle > 270 || angle < 90) {\r\n    y -= h;\r\n  }\r\n  return y;\r\n}\r\n\r\nfunction drawPointLabels(scale, labelCount) {\r\n  const {ctx, options: {pointLabels}} = scale;\r\n\r\n  for (let i = labelCount - 1; i >= 0; i--) {\r\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\r\n    const plFont = toFont(optsAtIndex.font);\r\n    const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];\r\n    const {backdropColor} = optsAtIndex;\r\n\r\n    if (!isNullOrUndef(backdropColor)) {\r\n      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);\r\n      const padding = toPadding(optsAtIndex.backdropPadding);\r\n      ctx.fillStyle = backdropColor;\r\n\r\n      const backdropLeft = left - padding.left;\r\n      const backdropTop = top - padding.top;\r\n      const backdropWidth = right - left + padding.width;\r\n      const backdropHeight = bottom - top + padding.height;\r\n\r\n      if (Object.values(borderRadius).some(v => v !== 0)) {\r\n        ctx.beginPath();\r\n        addRoundedRectPath(ctx, {\r\n          x: backdropLeft,\r\n          y: backdropTop,\r\n          w: backdropWidth,\r\n          h: backdropHeight,\r\n          radius: borderRadius,\r\n        });\r\n        ctx.fill();\r\n      } else {\r\n        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\r\n      }\r\n    }\r\n\r\n    renderText(\r\n      ctx,\r\n      scale._pointLabels[i],\r\n      x,\r\n      y + (plFont.lineHeight / 2),\r\n      plFont,\r\n      {\r\n        color: optsAtIndex.color,\r\n        textAlign: textAlign,\r\n        textBaseline: 'middle'\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\r\n  const {ctx} = scale;\r\n  if (circular) {\r\n    // Draw circular arcs between the points\r\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\r\n  } else {\r\n    // Draw straight lines connecting each index\r\n    let pointPosition = scale.getPointPosition(0, radius);\r\n    ctx.moveTo(pointPosition.x, pointPosition.y);\r\n\r\n    for (let i = 1; i < labelCount; i++) {\r\n      pointPosition = scale.getPointPosition(i, radius);\r\n      ctx.lineTo(pointPosition.x, pointPosition.y);\r\n    }\r\n  }\r\n}\r\n\r\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\r\n  const ctx = scale.ctx;\r\n  const circular = gridLineOpts.circular;\r\n\r\n  const {color, lineWidth} = gridLineOpts;\r\n\r\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\r\n    return;\r\n  }\r\n\r\n  ctx.save();\r\n  ctx.strokeStyle = color;\r\n  ctx.lineWidth = lineWidth;\r\n  ctx.setLineDash(borderOpts.dash);\r\n  ctx.lineDashOffset = borderOpts.dashOffset;\r\n\r\n  ctx.beginPath();\r\n  pathRadiusLine(scale, radius, circular, labelCount);\r\n  ctx.closePath();\r\n  ctx.stroke();\r\n  ctx.restore();\r\n}\r\n\r\nfunction createPointLabelContext(parent, index, label) {\r\n  return createContext(parent, {\r\n    label,\r\n    index,\r\n    type: 'pointLabel'\r\n  });\r\n}\r\n\r\nexport default class RadialLinearScale extends LinearScaleBase {\r\n\r\n  static id = 'radialLinear';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    display: true,\r\n\r\n    // Boolean - Whether to animate scaling the chart from the centre\r\n    animate: true,\r\n    position: 'chartArea',\r\n\r\n    angleLines: {\r\n      display: true,\r\n      lineWidth: 1,\r\n      borderDash: [],\r\n      borderDashOffset: 0.0\r\n    },\r\n\r\n    grid: {\r\n      circular: false\r\n    },\r\n\r\n    startAngle: 0,\r\n\r\n    // label settings\r\n    ticks: {\r\n      // Boolean - Show a backdrop to the scale label\r\n      showLabelBackdrop: true,\r\n\r\n      callback: Ticks.formatters.numeric\r\n    },\r\n\r\n    pointLabels: {\r\n      backdropColor: undefined,\r\n\r\n      // Number - The backdrop padding above & below the label in pixels\r\n      backdropPadding: 2,\r\n\r\n      // Boolean - if true, show point labels\r\n      display: true,\r\n\r\n      // Number - Point label font size in pixels\r\n      font: {\r\n        size: 10\r\n      },\r\n\r\n      // Function - Used to convert point labels\r\n      callback(label) {\r\n        return label;\r\n      },\r\n\r\n      // Number - Additionl padding between scale and pointLabel\r\n      padding: 5,\r\n\r\n      // Boolean - if true, center point labels to slices in polar chart\r\n      centerPointLabels: false\r\n    }\r\n  };\r\n\r\n  static defaultRoutes = {\r\n    'angleLines.color': 'borderColor',\r\n    'pointLabels.color': 'color',\r\n    'ticks.color': 'color'\r\n  };\r\n\r\n  static descriptors = {\r\n    angleLines: {\r\n      _fallback: 'grid'\r\n    }\r\n  };\r\n\r\n  constructor(cfg) {\r\n    super(cfg);\r\n\r\n    /** @type {number} */\r\n    this.xCenter = undefined;\r\n    /** @type {number} */\r\n    this.yCenter = undefined;\r\n    /** @type {number} */\r\n    this.drawingArea = undefined;\r\n    /** @type {string[]} */\r\n    this._pointLabels = [];\r\n    this._pointLabelItems = [];\r\n  }\r\n\r\n  setDimensions() {\r\n    // Set the unconstrained dimension before label rotation\r\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\r\n    const w = this.width = this.maxWidth - padding.width;\r\n    const h = this.height = this.maxHeight - padding.height;\r\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\r\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\r\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\r\n  }\r\n\r\n  determineDataLimits() {\r\n    const {min, max} = this.getMinMax(false);\r\n\r\n    this.min = isFinite(min) && !isNaN(min) ? min : 0;\r\n    this.max = isFinite(max) && !isNaN(max) ? max : 0;\r\n\r\n    // Common base implementation to handle min, max, beginAtZero\r\n    this.handleTickRangeOptions();\r\n  }\r\n\r\n  /**\r\n\t * Returns the maximum number of ticks based on the scale dimension\r\n\t * @protected\r\n\t */\r\n  computeTickLimit() {\r\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\r\n  }\r\n\r\n  generateTickLabels(ticks) {\r\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\r\n\r\n    // Point labels\r\n    this._pointLabels = this.getLabels()\r\n      .map((value, index) => {\r\n        const label = callCallback(this.options.pointLabels.callback, [value, index], this);\r\n        return label || label === 0 ? label : '';\r\n      })\r\n      .filter((v, i) => this.chart.getDataVisibility(i));\r\n  }\r\n\r\n  fit() {\r\n    const opts = this.options;\r\n\r\n    if (opts.display && opts.pointLabels.display) {\r\n      fitWithPointLabels(this);\r\n    } else {\r\n      this.setCenterPoint(0, 0, 0, 0);\r\n    }\r\n  }\r\n\r\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\r\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\r\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\r\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\r\n  }\r\n\r\n  getIndexAngle(index) {\r\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\r\n    const startAngle = this.options.startAngle || 0;\r\n\r\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\r\n  }\r\n\r\n  getDistanceFromCenterForValue(value) {\r\n    if (isNullOrUndef(value)) {\r\n      return NaN;\r\n    }\r\n\r\n    // Take into account half font size + the yPadding of the top value\r\n    const scalingFactor = this.drawingArea / (this.max - this.min);\r\n    if (this.options.reverse) {\r\n      return (this.max - value) * scalingFactor;\r\n    }\r\n    return (value - this.min) * scalingFactor;\r\n  }\r\n\r\n  getValueForDistanceFromCenter(distance) {\r\n    if (isNullOrUndef(distance)) {\r\n      return NaN;\r\n    }\r\n\r\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\r\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\r\n  }\r\n\r\n  getPointLabelContext(index) {\r\n    const pointLabels = this._pointLabels || [];\r\n\r\n    if (index >= 0 && index < pointLabels.length) {\r\n      const pointLabel = pointLabels[index];\r\n      return createPointLabelContext(this.getContext(), index, pointLabel);\r\n    }\r\n  }\r\n\r\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\r\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\r\n    return {\r\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\r\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\r\n      angle\r\n    };\r\n  }\r\n\r\n  getPointPositionForValue(index, value) {\r\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\r\n  }\r\n\r\n  getBasePosition(index) {\r\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\r\n  }\r\n\r\n  getPointLabelPosition(index) {\r\n    const {left, top, right, bottom} = this._pointLabelItems[index];\r\n    return {\r\n      left,\r\n      top,\r\n      right,\r\n      bottom,\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawBackground() {\r\n    const {backgroundColor, grid: {circular}} = this.options;\r\n    if (backgroundColor) {\r\n      const ctx = this.ctx;\r\n      ctx.save();\r\n      ctx.beginPath();\r\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\r\n      ctx.closePath();\r\n      ctx.fillStyle = backgroundColor;\r\n      ctx.fill();\r\n      ctx.restore();\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawGrid() {\r\n    const ctx = this.ctx;\r\n    const opts = this.options;\r\n    const {angleLines, grid, border} = opts;\r\n    const labelCount = this._pointLabels.length;\r\n\r\n    let i, offset, position;\r\n\r\n    if (opts.pointLabels.display) {\r\n      drawPointLabels(this, labelCount);\r\n    }\r\n\r\n    if (grid.display) {\r\n      this.ticks.forEach((tick, index) => {\r\n        if (index !== 0) {\r\n          offset = this.getDistanceFromCenterForValue(tick.value);\r\n          const context = this.getContext(index);\r\n          const optsAtIndex = grid.setContext(context);\r\n          const optsAtIndexBorder = border.setContext(context);\r\n\r\n          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (angleLines.display) {\r\n      ctx.save();\r\n\r\n      for (i = labelCount - 1; i >= 0; i--) {\r\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\r\n        const {color, lineWidth} = optsAtIndex;\r\n\r\n        if (!lineWidth || !color) {\r\n          continue;\r\n        }\r\n\r\n        ctx.lineWidth = lineWidth;\r\n        ctx.strokeStyle = color;\r\n\r\n        ctx.setLineDash(optsAtIndex.borderDash);\r\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\r\n\r\n        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\r\n        position = this.getPointPosition(i, offset);\r\n        ctx.beginPath();\r\n        ctx.moveTo(this.xCenter, this.yCenter);\r\n        ctx.lineTo(position.x, position.y);\r\n        ctx.stroke();\r\n      }\r\n\r\n      ctx.restore();\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawBorder() {}\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawLabels() {\r\n    const ctx = this.ctx;\r\n    const opts = this.options;\r\n    const tickOpts = opts.ticks;\r\n\r\n    if (!tickOpts.display) {\r\n      return;\r\n    }\r\n\r\n    const startAngle = this.getIndexAngle(0);\r\n    let offset, width;\r\n\r\n    ctx.save();\r\n    ctx.translate(this.xCenter, this.yCenter);\r\n    ctx.rotate(startAngle);\r\n    ctx.textAlign = 'center';\r\n    ctx.textBaseline = 'middle';\r\n\r\n    this.ticks.forEach((tick, index) => {\r\n      if (index === 0 && !opts.reverse) {\r\n        return;\r\n      }\r\n\r\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\r\n      const tickFont = toFont(optsAtIndex.font);\r\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\r\n\r\n      if (optsAtIndex.showLabelBackdrop) {\r\n        ctx.font = tickFont.string;\r\n        width = ctx.measureText(tick.label).width;\r\n        ctx.fillStyle = optsAtIndex.backdropColor;\r\n\r\n        const padding = toPadding(optsAtIndex.backdropPadding);\r\n        ctx.fillRect(\r\n          -width / 2 - padding.left,\r\n          -offset - tickFont.size / 2 - padding.top,\r\n          width + padding.width,\r\n          tickFont.size + padding.height\r\n        );\r\n      }\r\n\r\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\r\n        color: optsAtIndex.color,\r\n      });\r\n    });\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawTitle() {}\r\n}\r\n","import adapters from '../core/core.adapters.js';\r\nimport {callback as call, isFinite, isNullOrUndef, mergeIf, valueOrDefault} from '../helpers/helpers.core.js';\r\nimport {toRadians, isNumber, _limitValue} from '../helpers/helpers.math.js';\r\nimport Scale from '../core/core.scale.js';\r\nimport {_arrayUnique, _filterBetween, _lookup} from '../helpers/helpers.collection.js';\r\n\r\n/**\r\n * @typedef { import('../core/core.adapters.js').TimeUnit } Unit\r\n * @typedef {{common: boolean, size: number, steps?: number}} Interval\r\n * @typedef { import('../core/core.adapters.js').DateAdapter } DateAdapter\r\n */\r\n\r\n/**\r\n * @type {Object<Unit, Interval>}\r\n */\r\nconst INTERVALS = {\r\n  millisecond: {common: true, size: 1, steps: 1000},\r\n  second: {common: true, size: 1000, steps: 60},\r\n  minute: {common: true, size: 60000, steps: 60},\r\n  hour: {common: true, size: 3600000, steps: 24},\r\n  day: {common: true, size: 86400000, steps: 30},\r\n  week: {common: false, size: 604800000, steps: 4},\r\n  month: {common: true, size: 2.628e9, steps: 12},\r\n  quarter: {common: false, size: 7.884e9, steps: 4},\r\n  year: {common: true, size: 3.154e10}\r\n};\r\n\r\n/**\r\n * @type {Unit[]}\r\n */\r\nconst UNITS = /** @type Unit[] */ /* #__PURE__ */ (Object.keys(INTERVALS));\r\n\r\n/**\r\n * @param {number} a\r\n * @param {number} b\r\n */\r\nfunction sorter(a, b) {\r\n  return a - b;\r\n}\r\n\r\n/**\r\n * @param {TimeScale} scale\r\n * @param {*} input\r\n * @return {number}\r\n */\r\nfunction parse(scale, input) {\r\n  if (isNullOrUndef(input)) {\r\n    return null;\r\n  }\r\n\r\n  const adapter = scale._adapter;\r\n  const {parser, round, isoWeekday} = scale._parseOpts;\r\n  let value = input;\r\n\r\n  if (typeof parser === 'function') {\r\n    value = parser(value);\r\n  }\r\n\r\n  // Only parse if its not a timestamp already\r\n  if (!isFinite(value)) {\r\n    value = typeof parser === 'string'\r\n      ? adapter.parse(value, /** @type {Unit} */ (parser))\r\n      : adapter.parse(value);\r\n  }\r\n\r\n  if (value === null) {\r\n    return null;\r\n  }\r\n\r\n  if (round) {\r\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\r\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\r\n      : adapter.startOf(value, round);\r\n  }\r\n\r\n  return +value;\r\n}\r\n\r\n/**\r\n * Figures out what unit results in an appropriate number of auto-generated ticks\r\n * @param {Unit} minUnit\r\n * @param {number} min\r\n * @param {number} max\r\n * @param {number} capacity\r\n * @return {object}\r\n */\r\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\r\n  const ilen = UNITS.length;\r\n\r\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\r\n    const interval = INTERVALS[UNITS[i]];\r\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\r\n\r\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\r\n      return UNITS[i];\r\n    }\r\n  }\r\n\r\n  return UNITS[ilen - 1];\r\n}\r\n\r\n/**\r\n * Figures out what unit to format a set of ticks with\r\n * @param {TimeScale} scale\r\n * @param {number} numTicks\r\n * @param {Unit} minUnit\r\n * @param {number} min\r\n * @param {number} max\r\n * @return {Unit}\r\n */\r\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\r\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\r\n    const unit = UNITS[i];\r\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\r\n      return unit;\r\n    }\r\n  }\r\n\r\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\r\n}\r\n\r\n/**\r\n * @param {Unit} unit\r\n * @return {object}\r\n */\r\nfunction determineMajorUnit(unit) {\r\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\r\n    if (INTERVALS[UNITS[i]].common) {\r\n      return UNITS[i];\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {object} ticks\r\n * @param {number} time\r\n * @param {number[]} [timestamps] - if defined, snap to these timestamps\r\n */\r\nfunction addTick(ticks, time, timestamps) {\r\n  if (!timestamps) {\r\n    ticks[time] = true;\r\n  } else if (timestamps.length) {\r\n    const {lo, hi} = _lookup(timestamps, time);\r\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\r\n    ticks[timestamp] = true;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {TimeScale} scale\r\n * @param {object[]} ticks\r\n * @param {object} map\r\n * @param {Unit} majorUnit\r\n * @return {object[]}\r\n */\r\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\r\n  const adapter = scale._adapter;\r\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\r\n  const last = ticks[ticks.length - 1].value;\r\n  let major, index;\r\n\r\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\r\n    index = map[major];\r\n    if (index >= 0) {\r\n      ticks[index].major = true;\r\n    }\r\n  }\r\n  return ticks;\r\n}\r\n\r\n/**\r\n * @param {TimeScale} scale\r\n * @param {number[]} values\r\n * @param {Unit|undefined} [majorUnit]\r\n * @return {object[]}\r\n */\r\nfunction ticksFromTimestamps(scale, values, majorUnit) {\r\n  const ticks = [];\r\n  /** @type {Object<number,object>} */\r\n  const map = {};\r\n  const ilen = values.length;\r\n  let i, value;\r\n\r\n  for (i = 0; i < ilen; ++i) {\r\n    value = values[i];\r\n    map[value] = i;\r\n\r\n    ticks.push({\r\n      value,\r\n      major: false\r\n    });\r\n  }\r\n\r\n  // We set the major ticks separately from the above loop because calling startOf for every tick\r\n  // is expensive when there is a large number of ticks\r\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\r\n}\r\n\r\nexport default class TimeScale extends Scale {\r\n\r\n  static id = 'time';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = {\r\n    /**\r\n     * Scale boundary strategy (bypassed by min/max time options)\r\n     * - `data`: make sure data are fully visible, ticks outside are removed\r\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\r\n     * @see https://github.com/chartjs/Chart.js/pull/4556\r\n     * @since 2.7.0\r\n     */\r\n    bounds: 'data',\r\n\r\n    adapters: {},\r\n    time: {\r\n      parser: false, // false == a pattern string from or a custom callback that converts its argument to a timestamp\r\n      unit: false, // false == automatic or override with week, month, year, etc.\r\n      round: false, // none, or override with week, month, year, etc.\r\n      isoWeekday: false, // override week start day\r\n      minUnit: 'millisecond',\r\n      displayFormats: {}\r\n    },\r\n    ticks: {\r\n      /**\r\n       * Ticks generation input values:\r\n       * - 'auto': generates \"optimal\" ticks based on scale size and time options.\r\n       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\r\n       * - 'labels': generates ticks from user given `data.labels` values ONLY.\r\n       * @see https://github.com/chartjs/Chart.js/pull/4507\r\n       * @since 2.7.0\r\n       */\r\n      source: 'auto',\r\n\r\n      callback: false,\r\n\r\n      major: {\r\n        enabled: false\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n\t * @param {object} props\r\n\t */\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    /** @type {{data: number[], labels: number[], all: number[]}} */\r\n    this._cache = {\r\n      data: [],\r\n      labels: [],\r\n      all: []\r\n    };\r\n\r\n    /** @type {Unit} */\r\n    this._unit = 'day';\r\n    /** @type {Unit=} */\r\n    this._majorUnit = undefined;\r\n    this._offsets = {};\r\n    this._normalized = false;\r\n    this._parseOpts = undefined;\r\n  }\r\n\r\n  init(scaleOpts, opts = {}) {\r\n    const time = scaleOpts.time || (scaleOpts.time = {});\r\n    /** @type {DateAdapter} */\r\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\r\n\r\n    adapter.init(opts);\r\n\r\n    // Backward compatibility: before introducing adapter, `displayFormats` was\r\n    // supposed to contain *all* unit/string pairs but this can't be resolved\r\n    // when loading the scale (adapters are loaded afterward), so let's populate\r\n    // missing formats on update\r\n    mergeIf(time.displayFormats, adapter.formats());\r\n\r\n    this._parseOpts = {\r\n      parser: time.parser,\r\n      round: time.round,\r\n      isoWeekday: time.isoWeekday\r\n    };\r\n\r\n    super.init(scaleOpts);\r\n\r\n    this._normalized = opts.normalized;\r\n  }\r\n\r\n  /**\r\n\t * @param {*} raw\r\n\t * @param {number?} [index]\r\n\t * @return {number}\r\n\t */\r\n  parse(raw, index) { // eslint-disable-line no-unused-vars\r\n    if (raw === undefined) {\r\n      return null;\r\n    }\r\n    return parse(this, raw);\r\n  }\r\n\r\n  beforeLayout() {\r\n    super.beforeLayout();\r\n    this._cache = {\r\n      data: [],\r\n      labels: [],\r\n      all: []\r\n    };\r\n  }\r\n\r\n  determineDataLimits() {\r\n    const options = this.options;\r\n    const adapter = this._adapter;\r\n    const unit = options.time.unit || 'day';\r\n    // eslint-disable-next-line prefer-const\r\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\r\n\r\n    /**\r\n\t\t * @param {object} bounds\r\n\t\t */\r\n    function _applyBounds(bounds) {\r\n      if (!minDefined && !isNaN(bounds.min)) {\r\n        min = Math.min(min, bounds.min);\r\n      }\r\n      if (!maxDefined && !isNaN(bounds.max)) {\r\n        max = Math.max(max, bounds.max);\r\n      }\r\n    }\r\n\r\n    // If we have user provided `min` and `max` labels / data bounds can be ignored\r\n    if (!minDefined || !maxDefined) {\r\n      // Labels are always considered, when user did not force bounds\r\n      _applyBounds(this._getLabelBounds());\r\n\r\n      // If `bounds` is `'ticks'` and `ticks.source` is `'labels'`,\r\n      // data bounds are ignored (and don't need to be determined)\r\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\r\n        _applyBounds(this.getMinMax(false));\r\n      }\r\n    }\r\n\r\n    min = isFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\r\n    max = isFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\r\n\r\n    // Make sure that max is strictly higher than min (required by the timeseries lookup table)\r\n    this.min = Math.min(min, max - 1);\r\n    this.max = Math.max(min + 1, max);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getLabelBounds() {\r\n    const arr = this.getLabelTimestamps();\r\n    let min = Number.POSITIVE_INFINITY;\r\n    let max = Number.NEGATIVE_INFINITY;\r\n\r\n    if (arr.length) {\r\n      min = arr[0];\r\n      max = arr[arr.length - 1];\r\n    }\r\n    return {min, max};\r\n  }\r\n\r\n  /**\r\n\t * @return {object[]}\r\n\t */\r\n  buildTicks() {\r\n    const options = this.options;\r\n    const timeOpts = options.time;\r\n    const tickOpts = options.ticks;\r\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\r\n\r\n    if (options.bounds === 'ticks' && timestamps.length) {\r\n      this.min = this._userMin || timestamps[0];\r\n      this.max = this._userMax || timestamps[timestamps.length - 1];\r\n    }\r\n\r\n    const min = this.min;\r\n    const max = this.max;\r\n\r\n    const ticks = _filterBetween(timestamps, min, max);\r\n\r\n    // PRIVATE\r\n    // determineUnitForFormatting relies on the number of ticks so we don't use it when\r\n    // autoSkip is enabled because we don't yet know what the final number of ticks will be\r\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\r\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\r\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\r\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\r\n      : determineMajorUnit(this._unit);\r\n    this.initOffsets(timestamps);\r\n\r\n    if (options.reverse) {\r\n      ticks.reverse();\r\n    }\r\n\r\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\r\n  }\r\n\r\n  afterAutoSkip() {\r\n    // Offsets for bar charts need to be handled with the auto skipped\r\n    // ticks. Once ticks have been skipped, we re-compute the offsets.\r\n    if (this.options.offsetAfterAutoskip) {\r\n      this.initOffsets(this.ticks.map(tick => +tick.value));\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Returns the start and end offsets from edges in the form of {start, end}\r\n\t * where each value is a relative width to the scale and ranges between 0 and 1.\r\n\t * They add extra margins on the both sides by scaling down the original scale.\r\n\t * Offsets are added when the `offset` option is true.\r\n\t * @param {number[]} timestamps\r\n\t * @protected\r\n\t */\r\n  initOffsets(timestamps = []) {\r\n    let start = 0;\r\n    let end = 0;\r\n    let first, last;\r\n\r\n    if (this.options.offset && timestamps.length) {\r\n      first = this.getDecimalForValue(timestamps[0]);\r\n      if (timestamps.length === 1) {\r\n        start = 1 - first;\r\n      } else {\r\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\r\n      }\r\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\r\n      if (timestamps.length === 1) {\r\n        end = last;\r\n      } else {\r\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\r\n      }\r\n    }\r\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\r\n    start = _limitValue(start, 0, limit);\r\n    end = _limitValue(end, 0, limit);\r\n\r\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\r\n  }\r\n\r\n  /**\r\n\t * Generates a maximum of `capacity` timestamps between min and max, rounded to the\r\n\t * `minor` unit using the given scale time `options`.\r\n\t * Important: this method can return ticks outside the min and max range, it's the\r\n\t * responsibility of the calling code to clamp values if needed.\r\n\t * @private\r\n\t */\r\n  _generate() {\r\n    const adapter = this._adapter;\r\n    const min = this.min;\r\n    const max = this.max;\r\n    const options = this.options;\r\n    const timeOpts = options.time;\r\n    // @ts-ignore\r\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\r\n    const stepSize = valueOrDefault(options.ticks.stepSize, 1);\r\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\r\n    const hasWeekday = isNumber(weekday) || weekday === true;\r\n    const ticks = {};\r\n    let first = min;\r\n    let time, count;\r\n\r\n    // For 'week' unit, handle the first day of week option\r\n    if (hasWeekday) {\r\n      first = +adapter.startOf(first, 'isoWeek', weekday);\r\n    }\r\n\r\n    // Align first ticks on unit\r\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\r\n\r\n    // Prevent browser from freezing in case user options request millions of milliseconds\r\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\r\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\r\n    }\r\n\r\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\r\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\r\n      addTick(ticks, time, timestamps);\r\n    }\r\n\r\n    if (time === max || options.bounds === 'ticks' || count === 1) {\r\n      addTick(ticks, time, timestamps);\r\n    }\r\n\r\n    // @ts-ignore\r\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\r\n  }\r\n\r\n  /**\r\n\t * @param {number} value\r\n\t * @return {string}\r\n\t */\r\n  getLabelForValue(value) {\r\n    const adapter = this._adapter;\r\n    const timeOpts = this.options.time;\r\n\r\n    if (timeOpts.tooltipFormat) {\r\n      return adapter.format(value, timeOpts.tooltipFormat);\r\n    }\r\n    return adapter.format(value, timeOpts.displayFormats.datetime);\r\n  }\r\n\r\n  /**\r\n\t * @param {number} value\r\n\t * @param {string|undefined} format\r\n\t * @return {string}\r\n\t */\r\n  format(value, format) {\r\n    const options = this.options;\r\n    const formats = options.time.displayFormats;\r\n    const unit = this._unit;\r\n    const fmt = format || formats[unit];\r\n    return this._adapter.format(value, fmt);\r\n  }\r\n\r\n  /**\r\n\t * Function to format an individual tick mark\r\n\t * @param {number} time\r\n\t * @param {number} index\r\n\t * @param {object[]} ticks\r\n\t * @param {string|undefined} [format]\r\n\t * @return {string}\r\n\t * @private\r\n\t */\r\n  _tickFormatFunction(time, index, ticks, format) {\r\n    const options = this.options;\r\n    const formatter = options.ticks.callback;\r\n\r\n    if (formatter) {\r\n      return call(formatter, [time, index, ticks], this);\r\n    }\r\n\r\n    const formats = options.time.displayFormats;\r\n    const unit = this._unit;\r\n    const majorUnit = this._majorUnit;\r\n    const minorFormat = unit && formats[unit];\r\n    const majorFormat = majorUnit && formats[majorUnit];\r\n    const tick = ticks[index];\r\n    const major = majorUnit && majorFormat && tick && tick.major;\r\n\r\n    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\r\n  }\r\n\r\n  /**\r\n\t * @param {object[]} ticks\r\n\t */\r\n  generateTickLabels(ticks) {\r\n    let i, ilen, tick;\r\n\r\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n      tick = ticks[i];\r\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\r\n\t * @return {number}\r\n\t */\r\n  getDecimalForValue(value) {\r\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\r\n  }\r\n\r\n  /**\r\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\r\n\t * @return {number}\r\n\t */\r\n  getPixelForValue(value) {\r\n    const offsets = this._offsets;\r\n    const pos = this.getDecimalForValue(value);\r\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\r\n  }\r\n\r\n  /**\r\n\t * @param {number} pixel\r\n\t * @return {number}\r\n\t */\r\n  getValueForPixel(pixel) {\r\n    const offsets = this._offsets;\r\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\r\n    return this.min + pos * (this.max - this.min);\r\n  }\r\n\r\n  /**\r\n\t * @param {string} label\r\n\t * @return {{w:number, h:number}}\r\n\t * @private\r\n\t */\r\n  _getLabelSize(label) {\r\n    const ticksOpts = this.options.ticks;\r\n    const tickLabelWidth = this.ctx.measureText(label).width;\r\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\r\n    const cosRotation = Math.cos(angle);\r\n    const sinRotation = Math.sin(angle);\r\n    const tickFontSize = this._resolveTickFontOptions(0).size;\r\n\r\n    return {\r\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\r\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\r\n    };\r\n  }\r\n\r\n  /**\r\n\t * @param {number} exampleTime\r\n\t * @return {number}\r\n\t * @private\r\n\t */\r\n  _getLabelCapacity(exampleTime) {\r\n    const timeOpts = this.options.time;\r\n    const displayFormats = timeOpts.displayFormats;\r\n\r\n    // pick the longest format (milliseconds) for guestimation\r\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\r\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\r\n    const size = this._getLabelSize(exampleLabel);\r\n    // subtract 1 - if offset then there's one less label than tick\r\n    // if not offset then one half label padding is added to each end leaving room for one less label\r\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\r\n    return capacity > 0 ? capacity : 1;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getDataTimestamps() {\r\n    let timestamps = this._cache.data || [];\r\n    let i, ilen;\r\n\r\n    if (timestamps.length) {\r\n      return timestamps;\r\n    }\r\n\r\n    const metas = this.getMatchingVisibleMetas();\r\n\r\n    if (this._normalized && metas.length) {\r\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\r\n    }\r\n\r\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\r\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\r\n    }\r\n\r\n    return (this._cache.data = this.normalize(timestamps));\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getLabelTimestamps() {\r\n    const timestamps = this._cache.labels || [];\r\n    let i, ilen;\r\n\r\n    if (timestamps.length) {\r\n      return timestamps;\r\n    }\r\n\r\n    const labels = this.getLabels();\r\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\r\n      timestamps.push(parse(this, labels[i]));\r\n    }\r\n\r\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\r\n  }\r\n\r\n  /**\r\n\t * @param {number[]} values\r\n\t * @protected\r\n\t */\r\n  normalize(values) {\r\n    // It seems to be somewhat faster to do sorting first\r\n    return _arrayUnique(values.sort(sorter));\r\n  }\r\n}\r\n","import TimeScale from './scale.time.js';\r\nimport {_lookupByKey} from '../helpers/helpers.collection.js';\r\n\r\n/**\r\n * Linearly interpolates the given source `val` using the table. If value is out of bounds, values\r\n * at edges are used for the interpolation.\r\n * @param {object} table\r\n * @param {number} val\r\n * @param {boolean} [reverse] lookup time based on position instead of vice versa\r\n * @return {object}\r\n */\r\nfunction interpolate(table, val, reverse) {\r\n  let lo = 0;\r\n  let hi = table.length - 1;\r\n  let prevSource, nextSource, prevTarget, nextTarget;\r\n  if (reverse) {\r\n    if (val >= table[lo].pos && val <= table[hi].pos) {\r\n      ({lo, hi} = _lookupByKey(table, 'pos', val));\r\n    }\r\n    ({pos: prevSource, time: prevTarget} = table[lo]);\r\n    ({pos: nextSource, time: nextTarget} = table[hi]);\r\n  } else {\r\n    if (val >= table[lo].time && val <= table[hi].time) {\r\n      ({lo, hi} = _lookupByKey(table, 'time', val));\r\n    }\r\n    ({time: prevSource, pos: prevTarget} = table[lo]);\r\n    ({time: nextSource, pos: nextTarget} = table[hi]);\r\n  }\r\n\r\n  const span = nextSource - prevSource;\r\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\r\n}\r\n\r\nclass TimeSeriesScale extends TimeScale {\r\n\r\n  static id = 'timeseries';\r\n\r\n  /**\r\n   * @type {any}\r\n   */\r\n  static defaults = TimeScale.defaults;\r\n\r\n  /**\r\n\t * @param {object} props\r\n\t */\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    /** @type {object[]} */\r\n    this._table = [];\r\n    /** @type {number} */\r\n    this._minPos = undefined;\r\n    /** @type {number} */\r\n    this._tableRange = undefined;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  initOffsets() {\r\n    const timestamps = this._getTimestampsForTable();\r\n    const table = this._table = this.buildLookupTable(timestamps);\r\n    this._minPos = interpolate(table, this.min);\r\n    this._tableRange = interpolate(table, this.max) - this._minPos;\r\n    super.initOffsets(timestamps);\r\n  }\r\n\r\n  /**\r\n\t * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\r\n\t * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\r\n\t * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\r\n\t * extremity (left + width or top + height). Note that it would be more optimized to directly\r\n\t * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\r\n\t * to create the lookup table. The table ALWAYS contains at least two items: min and max.\r\n\t * @param {number[]} timestamps\r\n\t * @return {object[]}\r\n\t * @protected\r\n\t */\r\n  buildLookupTable(timestamps) {\r\n    const {min, max} = this;\r\n    const items = [];\r\n    const table = [];\r\n    let i, ilen, prev, curr, next;\r\n\r\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n      curr = timestamps[i];\r\n      if (curr >= min && curr <= max) {\r\n        items.push(curr);\r\n      }\r\n    }\r\n\r\n    if (items.length < 2) {\r\n      // In case there is less that 2 timestamps between min and max, the scale is defined by min and max\r\n      return [\r\n        {time: min, pos: 0},\r\n        {time: max, pos: 1}\r\n      ];\r\n    }\r\n\r\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n      next = items[i + 1];\r\n      prev = items[i - 1];\r\n      curr = items[i];\r\n\r\n      // only add points that breaks the scale linearity\r\n      if (Math.round((next + prev) / 2) !== curr) {\r\n        table.push({time: curr, pos: i / (ilen - 1)});\r\n      }\r\n    }\r\n    return table;\r\n  }\r\n\r\n  /**\r\n\t * Returns all timestamps\r\n\t * @return {number[]}\r\n\t * @private\r\n\t */\r\n  _getTimestampsForTable() {\r\n    let timestamps = this._cache.all || [];\r\n\r\n    if (timestamps.length) {\r\n      return timestamps;\r\n    }\r\n\r\n    const data = this.getDataTimestamps();\r\n    const label = this.getLabelTimestamps();\r\n    if (data.length && label.length) {\r\n      // If combining labels and data (data might not contain all labels),\r\n      // we need to recheck uniqueness and sort\r\n      timestamps = this.normalize(data.concat(label));\r\n    } else {\r\n      timestamps = data.length ? data : label;\r\n    }\r\n    timestamps = this._cache.all = timestamps;\r\n\r\n    return timestamps;\r\n  }\r\n\r\n  /**\r\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\r\n\t * @return {number}\r\n\t */\r\n  getDecimalForValue(value) {\r\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\r\n  }\r\n\r\n  /**\r\n\t * @param {number} pixel\r\n\t * @return {number}\r\n\t */\r\n  getValueForPixel(pixel) {\r\n    const offsets = this._offsets;\r\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\r\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\r\n  }\r\n}\r\n\r\nexport default TimeSeriesScale;\r\n","import {DoughnutController, PolarAreaController} from '../index.js';\r\nimport type {Chart, ChartDataset} from '../types.js';\r\n\r\nexport interface ColorsPluginOptions {\r\n  enabled?: boolean;\r\n  forceOverride?: boolean;\r\n}\r\n\r\ninterface ColorsDescriptor {\r\n  backgroundColor?: unknown;\r\n  borderColor?: unknown;\r\n}\r\n\r\nconst BORDER_COLORS = [\r\n  'rgb(54, 162, 235)', // blue\r\n  'rgb(255, 99, 132)', // red\r\n  'rgb(255, 159, 64)', // orange\r\n  'rgb(255, 205, 86)', // yellow\r\n  'rgb(75, 192, 192)', // green\r\n  'rgb(153, 102, 255)', // purple\r\n  'rgb(201, 203, 207)' // grey\r\n];\r\n\r\n// Border colors with 50% transparency\r\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map(color => color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\r\n\r\nfunction getBorderColor(i: number) {\r\n  return BORDER_COLORS[i % BORDER_COLORS.length];\r\n}\r\n\r\nfunction getBackgroundColor(i: number) {\r\n  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\r\n}\r\n\r\nfunction colorizeDefaultDataset(dataset: ChartDataset, i: number) {\r\n  dataset.borderColor = getBorderColor(i);\r\n  dataset.backgroundColor = getBackgroundColor(i);\r\n\r\n  return ++i;\r\n}\r\n\r\nfunction colorizeDoughnutDataset(dataset: ChartDataset, i: number) {\r\n  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));\r\n\r\n  return i;\r\n}\r\n\r\nfunction colorizePolarAreaDataset(dataset: ChartDataset, i: number) {\r\n  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));\r\n\r\n  return i;\r\n}\r\n\r\nfunction getColorizer(chart: Chart) {\r\n  let i = 0;\r\n\r\n  return (dataset: ChartDataset, datasetIndex: number) => {\r\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\r\n\r\n    if (controller instanceof DoughnutController) {\r\n      i = colorizeDoughnutDataset(dataset, i);\r\n    } else if (controller instanceof PolarAreaController) {\r\n      i = colorizePolarAreaDataset(dataset, i);\r\n    } else if (controller) {\r\n      i = colorizeDefaultDataset(dataset, i);\r\n    }\r\n  };\r\n}\r\n\r\nfunction containsColorsDefinitions(\r\n  descriptors: ColorsDescriptor[] | Record<string, ColorsDescriptor>\r\n) {\r\n  let k: number | string;\r\n\r\n  for (k in descriptors) {\r\n    if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction containsColorsDefinition(\r\n  descriptor: ColorsDescriptor\r\n) {\r\n  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\r\n}\r\n\r\nexport default {\r\n  id: 'colors',\r\n\r\n  defaults: {\r\n    enabled: true,\r\n    forceOverride: false\r\n  } as ColorsPluginOptions,\r\n\r\n  beforeLayout(chart: Chart, _args, options: ColorsPluginOptions) {\r\n    if (!options.enabled) {\r\n      return;\r\n    }\r\n\r\n    const {\r\n      data: {datasets},\r\n      options: chartOptions\r\n    } = chart.config;\r\n    const {elements} = chartOptions;\r\n\r\n    if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || (elements && containsColorsDefinitions(elements)))) {\r\n      return;\r\n    }\r\n\r\n    const colorizer = getColorizer(chart);\r\n\r\n    datasets.forEach(colorizer);\r\n  }\r\n};\r\n","import {_limitValue, _lookupByKey, isNullOrUndef, resolve} from '../helpers/index.js';\r\n\r\nfunction lttbDecimation(data, start, count, availableWidth, options) {\r\n  /**\r\n   * Implementation of the Largest Triangle Three Buckets algorithm.\r\n   *\r\n   * This implementation is based on the original implementation by Sveinn Steinarsson\r\n   * in https://github.com/sveinn-steinarsson/flot-downsample/blob/master/jquery.flot.downsample.js\r\n   *\r\n   * The original implementation is MIT licensed.\r\n   */\r\n  const samples = options.samples || availableWidth;\r\n  // There are less points than the threshold, returning the whole array\r\n  if (samples >= count) {\r\n    return data.slice(start, start + count);\r\n  }\r\n\r\n  const decimated = [];\r\n\r\n  const bucketWidth = (count - 2) / (samples - 2);\r\n  let sampledIndex = 0;\r\n  const endIndex = start + count - 1;\r\n  // Starting from offset\r\n  let a = start;\r\n  let i, maxAreaPoint, maxArea, area, nextA;\r\n\r\n  decimated[sampledIndex++] = data[a];\r\n\r\n  for (i = 0; i < samples - 2; i++) {\r\n    let avgX = 0;\r\n    let avgY = 0;\r\n    let j;\r\n\r\n    // Adding offset\r\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\r\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\r\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\r\n\r\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\r\n      avgX += data[j].x;\r\n      avgY += data[j].y;\r\n    }\r\n\r\n    avgX /= avgRangeLength;\r\n    avgY /= avgRangeLength;\r\n\r\n    // Adding offset\r\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\r\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\r\n    const {x: pointAx, y: pointAy} = data[a];\r\n\r\n    // Note that this is changed from the original algorithm which initializes these\r\n    // values to 1. The reason for this change is that if the area is small, nextA\r\n    // would never be set and thus a crash would occur in the next loop as `a` would become\r\n    // `undefined`. Since the area is always positive, but could be 0 in the case of a flat trace,\r\n    // initializing with a negative number is the correct solution.\r\n    maxArea = area = -1;\r\n\r\n    for (j = rangeOffs; j < rangeTo; j++) {\r\n      area = 0.5 * Math.abs(\r\n        (pointAx - avgX) * (data[j].y - pointAy) -\r\n        (pointAx - data[j].x) * (avgY - pointAy)\r\n      );\r\n\r\n      if (area > maxArea) {\r\n        maxArea = area;\r\n        maxAreaPoint = data[j];\r\n        nextA = j;\r\n      }\r\n    }\r\n\r\n    decimated[sampledIndex++] = maxAreaPoint;\r\n    a = nextA;\r\n  }\r\n\r\n  // Include the last point\r\n  decimated[sampledIndex++] = data[endIndex];\r\n\r\n  return decimated;\r\n}\r\n\r\nfunction minMaxDecimation(data, start, count, availableWidth) {\r\n  let avgX = 0;\r\n  let countX = 0;\r\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\r\n  const decimated = [];\r\n  const endIndex = start + count - 1;\r\n\r\n  const xMin = data[start].x;\r\n  const xMax = data[endIndex].x;\r\n  const dx = xMax - xMin;\r\n\r\n  for (i = start; i < start + count; ++i) {\r\n    point = data[i];\r\n    x = (point.x - xMin) / dx * availableWidth;\r\n    y = point.y;\r\n    const truncX = x | 0;\r\n\r\n    if (truncX === prevX) {\r\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\r\n      if (y < minY) {\r\n        minY = y;\r\n        minIndex = i;\r\n      } else if (y > maxY) {\r\n        maxY = y;\r\n        maxIndex = i;\r\n      }\r\n      // For first point in group, countX is `0`, so average will be `x` / 1.\r\n      // Use point.x here because we're computing the average data `x` value\r\n      avgX = (countX * avgX + point.x) / ++countX;\r\n    } else {\r\n      // Push up to 4 points, 3 for the last interval and the first point for this interval\r\n      const lastIndex = i - 1;\r\n\r\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\r\n        // The interval is defined by 4 points: start, min, max, end.\r\n        // The starting point is already considered at this point, so we need to determine which\r\n        // of the other points to add. We need to sort these points to ensure the decimated data\r\n        // is still sorted and then ensure there are no duplicates.\r\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\r\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\r\n\r\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\r\n          decimated.push({\r\n            ...data[intermediateIndex1],\r\n            x: avgX,\r\n          });\r\n        }\r\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\r\n          decimated.push({\r\n            ...data[intermediateIndex2],\r\n            x: avgX\r\n          });\r\n        }\r\n      }\r\n\r\n      // lastIndex === startIndex will occur when a range has only 1 point which could\r\n      // happen with very uneven data\r\n      if (i > 0 && lastIndex !== startIndex) {\r\n        // Last point in the previous interval\r\n        decimated.push(data[lastIndex]);\r\n      }\r\n\r\n      // Start of the new interval\r\n      decimated.push(point);\r\n      prevX = truncX;\r\n      countX = 0;\r\n      minY = maxY = y;\r\n      minIndex = maxIndex = startIndex = i;\r\n    }\r\n  }\r\n\r\n  return decimated;\r\n}\r\n\r\nfunction cleanDecimatedDataset(dataset) {\r\n  if (dataset._decimated) {\r\n    const data = dataset._data;\r\n    delete dataset._decimated;\r\n    delete dataset._data;\r\n    Object.defineProperty(dataset, 'data', {\r\n      configurable: true,\r\n      enumerable: true,\r\n      writable: true,\r\n      value: data,\r\n    });\r\n  }\r\n}\r\n\r\nfunction cleanDecimatedData(chart) {\r\n  chart.data.datasets.forEach((dataset) => {\r\n    cleanDecimatedDataset(dataset);\r\n  });\r\n}\r\n\r\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\r\n  const pointCount = points.length;\r\n\r\n  let start = 0;\r\n  let count;\r\n\r\n  const {iScale} = meta;\r\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\r\n\r\n  if (minDefined) {\r\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\r\n  }\r\n  if (maxDefined) {\r\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\r\n  } else {\r\n    count = pointCount - start;\r\n  }\r\n\r\n  return {start, count};\r\n}\r\n\r\nexport default {\r\n  id: 'decimation',\r\n\r\n  defaults: {\r\n    algorithm: 'min-max',\r\n    enabled: false,\r\n  },\r\n\r\n  beforeElementsUpdate: (chart, args, options) => {\r\n    if (!options.enabled) {\r\n      // The decimation plugin may have been previously enabled. Need to remove old `dataset._data` handlers\r\n      cleanDecimatedData(chart);\r\n      return;\r\n    }\r\n\r\n    // Assume the entire chart is available to show a few more points than needed\r\n    const availableWidth = chart.width;\r\n\r\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\r\n      const {_data, indexAxis} = dataset;\r\n      const meta = chart.getDatasetMeta(datasetIndex);\r\n      const data = _data || dataset.data;\r\n\r\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\r\n        // Decimation is only supported for lines that have an X indexAxis\r\n        return;\r\n      }\r\n\r\n      if (!meta.controller.supportsDecimation) {\r\n        // Only line datasets are supported\r\n        return;\r\n      }\r\n\r\n      const xAxis = chart.scales[meta.xAxisID];\r\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\r\n        // Only linear interpolation is supported\r\n        return;\r\n      }\r\n\r\n      if (chart.options.parsing) {\r\n        // Plugin only supports data that does not need parsing\r\n        return;\r\n      }\r\n\r\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\r\n      const threshold = options.threshold || 4 * availableWidth;\r\n      if (count <= threshold) {\r\n        // No decimation is required until we are above this threshold\r\n        cleanDecimatedDataset(dataset);\r\n        return;\r\n      }\r\n\r\n      if (isNullOrUndef(_data)) {\r\n        // First time we are seeing this dataset\r\n        // We override the 'data' property with a setter that stores the\r\n        // raw data in _data, but reads the decimated data from _decimated\r\n        dataset._data = data;\r\n        delete dataset.data;\r\n        Object.defineProperty(dataset, 'data', {\r\n          configurable: true,\r\n          enumerable: true,\r\n          get: function() {\r\n            return this._decimated;\r\n          },\r\n          set: function(d) {\r\n            this._data = d;\r\n          }\r\n        });\r\n      }\r\n\r\n      // Point the chart to the decimated data\r\n      let decimated;\r\n      switch (options.algorithm) {\r\n      case 'lttb':\r\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\r\n        break;\r\n      case 'min-max':\r\n        decimated = minMaxDecimation(data, start, count, availableWidth);\r\n        break;\r\n      default:\r\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\r\n      }\r\n\r\n      dataset._decimated = decimated;\r\n    });\r\n  },\r\n\r\n  destroy(chart) {\r\n    cleanDecimatedData(chart);\r\n  }\r\n};\r\n","import {_boundSegment, _boundSegments, _normalizeAngle} from '../../helpers/index.js';\r\n\r\nexport function _segments(line, target, property) {\r\n  const segments = line.segments;\r\n  const points = line.points;\r\n  const tpoints = target.points;\r\n  const parts = [];\r\n\r\n  for (const segment of segments) {\r\n    let {start, end} = segment;\r\n    end = _findSegmentEnd(start, end, points);\r\n\r\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\r\n\r\n    if (!target.segments) {\r\n      // Special case for boundary not supporting `segments` (simpleArc)\r\n      // Bounds are provided as `target` for partial circle, or undefined for full circle\r\n      parts.push({\r\n        source: segment,\r\n        target: bounds,\r\n        start: points[start],\r\n        end: points[end]\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // Get all segments from `target` that intersect the bounds of current segment of `line`\r\n    const targetSegments = _boundSegments(target, bounds);\r\n\r\n    for (const tgt of targetSegments) {\r\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\r\n      const fillSources = _boundSegment(segment, points, subBounds);\r\n\r\n      for (const fillSource of fillSources) {\r\n        parts.push({\r\n          source: fillSource,\r\n          target: tgt,\r\n          start: {\r\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\r\n          },\r\n          end: {\r\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n  return parts;\r\n}\r\n\r\nexport function _getBounds(property, first, last, loop) {\r\n  if (loop) {\r\n    return;\r\n  }\r\n  let start = first[property];\r\n  let end = last[property];\r\n\r\n  if (property === 'angle') {\r\n    start = _normalizeAngle(start);\r\n    end = _normalizeAngle(end);\r\n  }\r\n  return {property, start, end};\r\n}\r\n\r\nexport function _pointsFromSegments(boundary, line) {\r\n  const {x = null, y = null} = boundary || {};\r\n  const linePoints = line.points;\r\n  const points = [];\r\n  line.segments.forEach(({start, end}) => {\r\n    end = _findSegmentEnd(start, end, linePoints);\r\n    const first = linePoints[start];\r\n    const last = linePoints[end];\r\n    if (y !== null) {\r\n      points.push({x: first.x, y});\r\n      points.push({x: last.x, y});\r\n    } else if (x !== null) {\r\n      points.push({x, y: first.y});\r\n      points.push({x, y: last.y});\r\n    }\r\n  });\r\n  return points;\r\n}\r\n\r\nexport function _findSegmentEnd(start, end, points) {\r\n  for (;end > start; end--) {\r\n    const point = points[end];\r\n    if (!isNaN(point.x) && !isNaN(point.y)) {\r\n      break;\r\n    }\r\n  }\r\n  return end;\r\n}\r\n\r\nfunction _getEdge(a, b, prop, fn) {\r\n  if (a && b) {\r\n    return fn(a[prop], b[prop]);\r\n  }\r\n  return a ? a[prop] : b ? b[prop] : 0;\r\n}\r\n","/**\r\n * @typedef { import('../../core/core.controller.js').default } Chart\r\n * @typedef { import('../../core/core.scale.js').default } Scale\r\n * @typedef { import('../../elements/element.point.js').default } PointElement\r\n */\r\n\r\nimport {LineElement} from '../../elements/index.js';\r\nimport {isArray} from '../../helpers/index.js';\r\nimport {_pointsFromSegments} from './filler.segment.js';\r\n\r\n/**\r\n * @param {PointElement[] | { x: number; y: number; }} boundary\r\n * @param {LineElement} line\r\n * @return {LineElement?}\r\n */\r\nexport function _createBoundaryLine(boundary, line) {\r\n  let points = [];\r\n  let _loop = false;\r\n\r\n  if (isArray(boundary)) {\r\n    _loop = true;\r\n    // @ts-ignore\r\n    points = boundary;\r\n  } else {\r\n    points = _pointsFromSegments(boundary, line);\r\n  }\r\n\r\n  return points.length ? new LineElement({\r\n    points,\r\n    options: {tension: 0},\r\n    _loop,\r\n    _fullLoop: _loop\r\n  }) : null;\r\n}\r\n\r\nexport function _shouldApplyFill(source) {\r\n  return source && source.fill !== false;\r\n}\r\n","import {isObject, isFinite, valueOrDefault} from '../../helpers/helpers.core.js';\r\n\r\n/**\r\n * @typedef { import('../../core/core.scale.js').default } Scale\r\n * @typedef { import('../../elements/element.line.js').default } LineElement\r\n * @typedef { import('../../types/index.js').FillTarget } FillTarget\r\n * @typedef { import('../../types/index.js').ComplexFillTarget } ComplexFillTarget\r\n */\r\n\r\nexport function _resolveTarget(sources, index, propagate) {\r\n  const source = sources[index];\r\n  let fill = source.fill;\r\n  const visited = [index];\r\n  let target;\r\n\r\n  if (!propagate) {\r\n    return fill;\r\n  }\r\n\r\n  while (fill !== false && visited.indexOf(fill) === -1) {\r\n    if (!isFinite(fill)) {\r\n      return fill;\r\n    }\r\n\r\n    target = sources[fill];\r\n    if (!target) {\r\n      return false;\r\n    }\r\n\r\n    if (target.visible) {\r\n      return fill;\r\n    }\r\n\r\n    visited.push(fill);\r\n    fill = target.fill;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * @param {LineElement} line\r\n * @param {number} index\r\n * @param {number} count\r\n */\r\nexport function _decodeFill(line, index, count) {\r\n  /** @type {string | {value: number}} */\r\n  const fill = parseFillOption(line);\r\n\r\n  if (isObject(fill)) {\r\n    return isNaN(fill.value) ? false : fill;\r\n  }\r\n\r\n  let target = parseFloat(fill);\r\n\r\n  if (isFinite(target) && Math.floor(target) === target) {\r\n    return decodeTargetIndex(fill[0], index, target, count);\r\n  }\r\n\r\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\r\n}\r\n\r\nfunction decodeTargetIndex(firstCh, index, target, count) {\r\n  if (firstCh === '-' || firstCh === '+') {\r\n    target = index + target;\r\n  }\r\n\r\n  if (target === index || target < 0 || target >= count) {\r\n    return false;\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\n/**\r\n * @param {FillTarget | ComplexFillTarget} fill\r\n * @param {Scale} scale\r\n * @returns {number | null}\r\n */\r\nexport function _getTargetPixel(fill, scale) {\r\n  let pixel = null;\r\n  if (fill === 'start') {\r\n    pixel = scale.bottom;\r\n  } else if (fill === 'end') {\r\n    pixel = scale.top;\r\n  } else if (isObject(fill)) {\r\n    // @ts-ignore\r\n    pixel = scale.getPixelForValue(fill.value);\r\n  } else if (scale.getBasePixel) {\r\n    pixel = scale.getBasePixel();\r\n  }\r\n  return pixel;\r\n}\r\n\r\n/**\r\n * @param {FillTarget | ComplexFillTarget} fill\r\n * @param {Scale} scale\r\n * @param {number} startValue\r\n * @returns {number | undefined}\r\n */\r\nexport function _getTargetValue(fill, scale, startValue) {\r\n  let value;\r\n\r\n  if (fill === 'start') {\r\n    value = startValue;\r\n  } else if (fill === 'end') {\r\n    value = scale.options.reverse ? scale.min : scale.max;\r\n  } else if (isObject(fill)) {\r\n    // @ts-ignore\r\n    value = fill.value;\r\n  } else {\r\n    value = scale.getBaseValue();\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * @param {LineElement} line\r\n */\r\nfunction parseFillOption(line) {\r\n  const options = line.options;\r\n  const fillOption = options.fill;\r\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\r\n\r\n  if (fill === undefined) {\r\n    fill = !!options.backgroundColor;\r\n  }\r\n\r\n  if (fill === false || fill === null) {\r\n    return false;\r\n  }\r\n\r\n  if (fill === true) {\r\n    return 'origin';\r\n  }\r\n  return fill;\r\n}\r\n","/**\r\n * @typedef { import('../../core/core.controller.js').default } Chart\r\n * @typedef { import('../../core/core.scale.js').default } Scale\r\n * @typedef { import('../../elements/element.point.js').default } PointElement\r\n */\r\n\r\nimport {LineElement} from '../../elements/index.js';\r\nimport {_isBetween} from '../../helpers/index.js';\r\nimport {_createBoundaryLine} from './filler.helper.js';\r\n\r\n/**\r\n * @param {{ chart: Chart; scale: Scale; index: number; line: LineElement; }} source\r\n * @return {LineElement}\r\n */\r\nexport function _buildStackLine(source) {\r\n  const {scale, index, line} = source;\r\n  const points = [];\r\n  const segments = line.segments;\r\n  const sourcePoints = line.points;\r\n  const linesBelow = getLinesBelow(scale, index);\r\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\r\n\r\n  for (let i = 0; i < segments.length; i++) {\r\n    const segment = segments[i];\r\n    for (let j = segment.start; j <= segment.end; j++) {\r\n      addPointsBelow(points, sourcePoints[j], linesBelow);\r\n    }\r\n  }\r\n  return new LineElement({points, options: {}});\r\n}\r\n\r\n/**\r\n * @param {Scale} scale\r\n * @param {number} index\r\n * @return {LineElement[]}\r\n */\r\nfunction getLinesBelow(scale, index) {\r\n  const below = [];\r\n  const metas = scale.getMatchingVisibleMetas('line');\r\n\r\n  for (let i = 0; i < metas.length; i++) {\r\n    const meta = metas[i];\r\n    if (meta.index === index) {\r\n      break;\r\n    }\r\n    if (!meta.hidden) {\r\n      below.unshift(meta.dataset);\r\n    }\r\n  }\r\n  return below;\r\n}\r\n\r\n/**\r\n * @param {PointElement[]} points\r\n * @param {PointElement} sourcePoint\r\n * @param {LineElement[]} linesBelow\r\n */\r\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\r\n  const postponed = [];\r\n  for (let j = 0; j < linesBelow.length; j++) {\r\n    const line = linesBelow[j];\r\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\r\n\r\n    if (!point || (first && last)) {\r\n      continue;\r\n    }\r\n    if (first) {\r\n      // First point of an segment -> need to add another point before this,\r\n      // from next line below.\r\n      postponed.unshift(point);\r\n    } else {\r\n      points.push(point);\r\n      if (!last) {\r\n        // In the middle of an segment, no need to add more points.\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  points.push(...postponed);\r\n}\r\n\r\n/**\r\n * @param {LineElement} line\r\n * @param {PointElement} sourcePoint\r\n * @param {string} property\r\n * @returns {{point?: PointElement, first?: boolean, last?: boolean}}\r\n */\r\nfunction findPoint(line, sourcePoint, property) {\r\n  const point = line.interpolate(sourcePoint, property);\r\n  if (!point) {\r\n    return {};\r\n  }\r\n\r\n  const pointValue = point[property];\r\n  const segments = line.segments;\r\n  const linePoints = line.points;\r\n  let first = false;\r\n  let last = false;\r\n  for (let i = 0; i < segments.length; i++) {\r\n    const segment = segments[i];\r\n    const firstValue = linePoints[segment.start][property];\r\n    const lastValue = linePoints[segment.end][property];\r\n    if (_isBetween(pointValue, firstValue, lastValue)) {\r\n      first = pointValue === firstValue;\r\n      last = pointValue === lastValue;\r\n      break;\r\n    }\r\n  }\r\n  return {first, last, point};\r\n}\r\n","import {TAU} from '../../helpers/index.js';\r\n\r\n// TODO: use elements.ArcElement instead\r\nexport class simpleArc {\r\n  constructor(opts) {\r\n    this.x = opts.x;\r\n    this.y = opts.y;\r\n    this.radius = opts.radius;\r\n  }\r\n\r\n  pathSegment(ctx, bounds, opts) {\r\n    const {x, y, radius} = this;\r\n    bounds = bounds || {start: 0, end: TAU};\r\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\r\n    return !opts.bounds;\r\n  }\r\n\r\n  interpolate(point) {\r\n    const {x, y, radius} = this;\r\n    const angle = point.angle;\r\n    return {\r\n      x: x + Math.cos(angle) * radius,\r\n      y: y + Math.sin(angle) * radius,\r\n      angle\r\n    };\r\n  }\r\n}\r\n","import {isFinite} from '../../helpers/index.js';\r\nimport {_createBoundaryLine} from './filler.helper.js';\r\nimport {_getTargetPixel, _getTargetValue} from './filler.options.js';\r\nimport {_buildStackLine} from './filler.target.stack.js';\r\nimport {simpleArc} from './simpleArc.js';\r\n\r\n/**\r\n * @typedef { import('../../core/core.controller.js').default } Chart\r\n * @typedef { import('../../core/core.scale.js').default } Scale\r\n * @typedef { import('../../elements/element.point.js').default } PointElement\r\n */\r\n\r\nexport function _getTarget(source) {\r\n  const {chart, fill, line} = source;\r\n\r\n  if (isFinite(fill)) {\r\n    return getLineByIndex(chart, fill);\r\n  }\r\n\r\n  if (fill === 'stack') {\r\n    return _buildStackLine(source);\r\n  }\r\n\r\n  if (fill === 'shape') {\r\n    return true;\r\n  }\r\n\r\n  const boundary = computeBoundary(source);\r\n\r\n  if (boundary instanceof simpleArc) {\r\n    return boundary;\r\n  }\r\n\r\n  return _createBoundaryLine(boundary, line);\r\n}\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {number} index\r\n */\r\nfunction getLineByIndex(chart, index) {\r\n  const meta = chart.getDatasetMeta(index);\r\n  const visible = meta && chart.isDatasetVisible(index);\r\n  return visible ? meta.dataset : null;\r\n}\r\n\r\nfunction computeBoundary(source) {\r\n  const scale = source.scale || {};\r\n\r\n  if (scale.getPointPositionForValue) {\r\n    return computeCircularBoundary(source);\r\n  }\r\n  return computeLinearBoundary(source);\r\n}\r\n\r\n\r\nfunction computeLinearBoundary(source) {\r\n  const {scale = {}, fill} = source;\r\n  const pixel = _getTargetPixel(fill, scale);\r\n\r\n  if (isFinite(pixel)) {\r\n    const horizontal = scale.isHorizontal();\r\n\r\n    return {\r\n      x: horizontal ? pixel : null,\r\n      y: horizontal ? null : pixel\r\n    };\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction computeCircularBoundary(source) {\r\n  const {scale, fill} = source;\r\n  const options = scale.options;\r\n  const length = scale.getLabels().length;\r\n  const start = options.reverse ? scale.max : scale.min;\r\n  const value = _getTargetValue(fill, scale, start);\r\n  const target = [];\r\n\r\n  if (options.grid.circular) {\r\n    const center = scale.getPointPositionForValue(0, start);\r\n    return new simpleArc({\r\n      x: center.x,\r\n      y: center.y,\r\n      radius: scale.getDistanceFromCenterForValue(value)\r\n    });\r\n  }\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    target.push(scale.getPointPositionForValue(i, value));\r\n  }\r\n  return target;\r\n}\r\n\r\n","import {clipArea, unclipArea} from '../../helpers/index.js';\r\nimport {_findSegmentEnd, _getBounds, _segments} from './filler.segment.js';\r\nimport {_getTarget} from './filler.target.js';\r\n\r\nexport function _drawfill(ctx, source, area) {\r\n  const target = _getTarget(source);\r\n  const {line, scale, axis} = source;\r\n  const lineOpts = line.options;\r\n  const fillOption = lineOpts.fill;\r\n  const color = lineOpts.backgroundColor;\r\n  const {above = color, below = color} = fillOption || {};\r\n  if (target && line.points.length) {\r\n    clipArea(ctx, area);\r\n    doFill(ctx, {line, target, above, below, area, scale, axis});\r\n    unclipArea(ctx);\r\n  }\r\n}\r\n\r\nfunction doFill(ctx, cfg) {\r\n  const {line, target, above, below, area, scale} = cfg;\r\n  const property = line._loop ? 'angle' : cfg.axis;\r\n\r\n  ctx.save();\r\n\r\n  if (property === 'x' && below !== above) {\r\n    clipVertical(ctx, target, area.top);\r\n    fill(ctx, {line, target, color: above, scale, property});\r\n    ctx.restore();\r\n    ctx.save();\r\n    clipVertical(ctx, target, area.bottom);\r\n  }\r\n  fill(ctx, {line, target, color: below, scale, property});\r\n\r\n  ctx.restore();\r\n}\r\n\r\nfunction clipVertical(ctx, target, clipY) {\r\n  const {segments, points} = target;\r\n  let first = true;\r\n  let lineLoop = false;\r\n\r\n  ctx.beginPath();\r\n  for (const segment of segments) {\r\n    const {start, end} = segment;\r\n    const firstPoint = points[start];\r\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\r\n    if (first) {\r\n      ctx.moveTo(firstPoint.x, firstPoint.y);\r\n      first = false;\r\n    } else {\r\n      ctx.lineTo(firstPoint.x, clipY);\r\n      ctx.lineTo(firstPoint.x, firstPoint.y);\r\n    }\r\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\r\n    if (lineLoop) {\r\n      ctx.closePath();\r\n    } else {\r\n      ctx.lineTo(lastPoint.x, clipY);\r\n    }\r\n  }\r\n\r\n  ctx.lineTo(target.first().x, clipY);\r\n  ctx.closePath();\r\n  ctx.clip();\r\n}\r\n\r\nfunction fill(ctx, cfg) {\r\n  const {line, target, property, color, scale} = cfg;\r\n  const segments = _segments(line, target, property);\r\n\r\n  for (const {source: src, target: tgt, start, end} of segments) {\r\n    const {style: {backgroundColor = color} = {}} = src;\r\n    const notShape = target !== true;\r\n\r\n    ctx.save();\r\n    ctx.fillStyle = backgroundColor;\r\n\r\n    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\r\n\r\n    ctx.beginPath();\r\n\r\n    const lineLoop = !!line.pathSegment(ctx, src);\r\n\r\n    let loop;\r\n    if (notShape) {\r\n      if (lineLoop) {\r\n        ctx.closePath();\r\n      } else {\r\n        interpolatedLineTo(ctx, target, end, property);\r\n      }\r\n\r\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\r\n      loop = lineLoop && targetLoop;\r\n      if (!loop) {\r\n        interpolatedLineTo(ctx, target, start, property);\r\n      }\r\n    }\r\n\r\n    ctx.closePath();\r\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\r\n\r\n    ctx.restore();\r\n  }\r\n}\r\n\r\nfunction clipBounds(ctx, scale, bounds) {\r\n  const {top, bottom} = scale.chart.chartArea;\r\n  const {property, start, end} = bounds || {};\r\n  if (property === 'x') {\r\n    ctx.beginPath();\r\n    ctx.rect(start, top, end - start, bottom - top);\r\n    ctx.clip();\r\n  }\r\n}\r\n\r\nfunction interpolatedLineTo(ctx, target, point, property) {\r\n  const interpolatedPoint = target.interpolate(point, property);\r\n  if (interpolatedPoint) {\r\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\r\n  }\r\n}\r\n\r\n","/**\r\n * Plugin based on discussion from the following Chart.js issues:\r\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\r\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\r\n */\r\n\r\nimport LineElement from '../../elements/element.line.js';\r\nimport {_drawfill} from './filler.drawing.js';\r\nimport {_shouldApplyFill} from './filler.helper.js';\r\nimport {_decodeFill, _resolveTarget} from './filler.options.js';\r\n\r\nexport default {\r\n  id: 'filler',\r\n\r\n  afterDatasetsUpdate(chart, _args, options) {\r\n    const count = (chart.data.datasets || []).length;\r\n    const sources = [];\r\n    let meta, i, line, source;\r\n\r\n    for (i = 0; i < count; ++i) {\r\n      meta = chart.getDatasetMeta(i);\r\n      line = meta.dataset;\r\n      source = null;\r\n\r\n      if (line && line.options && line instanceof LineElement) {\r\n        source = {\r\n          visible: chart.isDatasetVisible(i),\r\n          index: i,\r\n          fill: _decodeFill(line, i, count),\r\n          chart,\r\n          axis: meta.controller.options.indexAxis,\r\n          scale: meta.vScale,\r\n          line,\r\n        };\r\n      }\r\n\r\n      meta.$filler = source;\r\n      sources.push(source);\r\n    }\r\n\r\n    for (i = 0; i < count; ++i) {\r\n      source = sources[i];\r\n      if (!source || source.fill === false) {\r\n        continue;\r\n      }\r\n\r\n      source.fill = _resolveTarget(sources, i, options.propagate);\r\n    }\r\n  },\r\n\r\n  beforeDraw(chart, _args, options) {\r\n    const draw = options.drawTime === 'beforeDraw';\r\n    const metasets = chart.getSortedVisibleDatasetMetas();\r\n    const area = chart.chartArea;\r\n    for (let i = metasets.length - 1; i >= 0; --i) {\r\n      const source = metasets[i].$filler;\r\n      if (!source) {\r\n        continue;\r\n      }\r\n\r\n      source.line.updateControlPoints(area, source.axis);\r\n      if (draw && source.fill) {\r\n        _drawfill(chart.ctx, source, area);\r\n      }\r\n    }\r\n  },\r\n\r\n  beforeDatasetsDraw(chart, _args, options) {\r\n    if (options.drawTime !== 'beforeDatasetsDraw') {\r\n      return;\r\n    }\r\n\r\n    const metasets = chart.getSortedVisibleDatasetMetas();\r\n    for (let i = metasets.length - 1; i >= 0; --i) {\r\n      const source = metasets[i].$filler;\r\n\r\n      if (_shouldApplyFill(source)) {\r\n        _drawfill(chart.ctx, source, chart.chartArea);\r\n      }\r\n    }\r\n  },\r\n\r\n  beforeDatasetDraw(chart, args, options) {\r\n    const source = args.meta.$filler;\r\n\r\n    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\r\n      return;\r\n    }\r\n\r\n    _drawfill(chart.ctx, source, chart.chartArea);\r\n  },\r\n\r\n  defaults: {\r\n    propagate: true,\r\n    drawTime: 'beforeDatasetDraw'\r\n  }\r\n};\r\n","import defaults from '../core/core.defaults.js';\r\nimport Element from '../core/core.element.js';\r\nimport layouts from '../core/core.layouts.js';\r\nimport {addRoundedRectPath, drawPointLegend, renderText} from '../helpers/helpers.canvas.js';\r\nimport {\r\n  _isBetween,\r\n  callback as call,\r\n  clipArea,\r\n  getRtlAdapter,\r\n  overrideTextDirection,\r\n  restoreTextDirection,\r\n  toFont,\r\n  toPadding,\r\n  unclipArea,\r\n  valueOrDefault,\r\n} from '../helpers/index.js';\r\nimport {_alignStartEnd, _textX, _toLeftRightCenter} from '../helpers/helpers.extras.js';\r\nimport {toTRBLCorners} from '../helpers/helpers.options.js';\r\n\r\n/**\r\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\r\n */\r\n\r\nconst getBoxSize = (labelOpts, fontSize) => {\r\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\r\n\r\n  if (labelOpts.usePointStyle) {\r\n    boxHeight = Math.min(boxHeight, fontSize);\r\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\r\n  }\r\n\r\n  return {\r\n    boxWidth,\r\n    boxHeight,\r\n    itemHeight: Math.max(fontSize, boxHeight)\r\n  };\r\n};\r\n\r\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\r\n\r\nexport class Legend extends Element {\r\n\r\n  /**\r\n\t * @param {{ ctx: any; options: any; chart: any; }} config\r\n\t */\r\n  constructor(config) {\r\n    super();\r\n\r\n    this._added = false;\r\n\r\n    // Contains hit boxes for each dataset (in dataset order)\r\n    this.legendHitBoxes = [];\r\n\r\n    /**\r\n \t\t * @private\r\n \t\t */\r\n    this._hoveredItem = null;\r\n\r\n    // Are we in doughnut mode which has a different data type\r\n    this.doughnutMode = false;\r\n\r\n    this.chart = config.chart;\r\n    this.options = config.options;\r\n    this.ctx = config.ctx;\r\n    this.legendItems = undefined;\r\n    this.columnSizes = undefined;\r\n    this.lineWidths = undefined;\r\n    this.maxHeight = undefined;\r\n    this.maxWidth = undefined;\r\n    this.top = undefined;\r\n    this.bottom = undefined;\r\n    this.left = undefined;\r\n    this.right = undefined;\r\n    this.height = undefined;\r\n    this.width = undefined;\r\n    this._margins = undefined;\r\n    this.position = undefined;\r\n    this.weight = undefined;\r\n    this.fullSize = undefined;\r\n  }\r\n\r\n  update(maxWidth, maxHeight, margins) {\r\n    this.maxWidth = maxWidth;\r\n    this.maxHeight = maxHeight;\r\n    this._margins = margins;\r\n\r\n    this.setDimensions();\r\n    this.buildLabels();\r\n    this.fit();\r\n  }\r\n\r\n  setDimensions() {\r\n    if (this.isHorizontal()) {\r\n      this.width = this.maxWidth;\r\n      this.left = this._margins.left;\r\n      this.right = this.width;\r\n    } else {\r\n      this.height = this.maxHeight;\r\n      this.top = this._margins.top;\r\n      this.bottom = this.height;\r\n    }\r\n  }\r\n\r\n  buildLabels() {\r\n    const labelOpts = this.options.labels || {};\r\n    let legendItems = call(labelOpts.generateLabels, [this.chart], this) || [];\r\n\r\n    if (labelOpts.filter) {\r\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\r\n    }\r\n\r\n    if (labelOpts.sort) {\r\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\r\n    }\r\n\r\n    if (this.options.reverse) {\r\n      legendItems.reverse();\r\n    }\r\n\r\n    this.legendItems = legendItems;\r\n  }\r\n\r\n  fit() {\r\n    const {options, ctx} = this;\r\n\r\n    // The legend may not be displayed for a variety of reasons including\r\n    // the fact that the defaults got set to `false`.\r\n    // When the legend is not displayed, there are no guarantees that the options\r\n    // are correctly formatted so we need to bail out as early as possible.\r\n    if (!options.display) {\r\n      this.width = this.height = 0;\r\n      return;\r\n    }\r\n\r\n    const labelOpts = options.labels;\r\n    const labelFont = toFont(labelOpts.font);\r\n    const fontSize = labelFont.size;\r\n    const titleHeight = this._computeTitleHeight();\r\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\r\n\r\n    let width, height;\r\n\r\n    ctx.font = labelFont.string;\r\n\r\n    if (this.isHorizontal()) {\r\n      width = this.maxWidth; // fill all the width\r\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\r\n    } else {\r\n      height = this.maxHeight; // fill all the height\r\n      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\r\n    }\r\n\r\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\r\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\r\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\r\n    const hitboxes = this.legendHitBoxes = [];\r\n    // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\r\n    const lineWidths = this.lineWidths = [0];\r\n    const lineHeight = itemHeight + padding;\r\n    let totalHeight = titleHeight;\r\n\r\n    ctx.textAlign = 'left';\r\n    ctx.textBaseline = 'middle';\r\n\r\n    let row = -1;\r\n    let top = -lineHeight;\r\n    this.legendItems.forEach((legendItem, i) => {\r\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n\r\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\r\n        totalHeight += lineHeight;\r\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\r\n        top += lineHeight;\r\n        row++;\r\n      }\r\n\r\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\r\n\r\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\r\n    });\r\n\r\n    return totalHeight;\r\n  }\r\n\r\n  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\r\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\r\n    const hitboxes = this.legendHitBoxes = [];\r\n    const columnSizes = this.columnSizes = [];\r\n    const heightLimit = maxHeight - titleHeight;\r\n\r\n    let totalWidth = padding;\r\n    let currentColWidth = 0;\r\n    let currentColHeight = 0;\r\n\r\n    let left = 0;\r\n    let col = 0;\r\n\r\n    this.legendItems.forEach((legendItem, i) => {\r\n      const {itemWidth, itemHeight} = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\r\n\r\n      // If too tall, go to new column\r\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\r\n        totalWidth += currentColWidth + padding;\r\n        columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\r\n        left += currentColWidth + padding;\r\n        col++;\r\n        currentColWidth = currentColHeight = 0;\r\n      }\r\n\r\n      // Store the hitbox width and height here. Final position will be updated in `draw`\r\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\r\n\r\n      // Get max width\r\n      currentColWidth = Math.max(currentColWidth, itemWidth);\r\n      currentColHeight += itemHeight + padding;\r\n    });\r\n\r\n    totalWidth += currentColWidth;\r\n    columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\r\n\r\n    return totalWidth;\r\n  }\r\n\r\n  adjustHitBoxes() {\r\n    if (!this.options.display) {\r\n      return;\r\n    }\r\n    const titleHeight = this._computeTitleHeight();\r\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\r\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\r\n    if (this.isHorizontal()) {\r\n      let row = 0;\r\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\r\n      for (const hitbox of hitboxes) {\r\n        if (row !== hitbox.row) {\r\n          row = hitbox.row;\r\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\r\n        }\r\n        hitbox.top += this.top + titleHeight + padding;\r\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\r\n        left += hitbox.width + padding;\r\n      }\r\n    } else {\r\n      let col = 0;\r\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\r\n      for (const hitbox of hitboxes) {\r\n        if (hitbox.col !== col) {\r\n          col = hitbox.col;\r\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\r\n        }\r\n        hitbox.top = top;\r\n        hitbox.left += this.left + padding;\r\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\r\n        top += hitbox.height + padding;\r\n      }\r\n    }\r\n  }\r\n\r\n  isHorizontal() {\r\n    return this.options.position === 'top' || this.options.position === 'bottom';\r\n  }\r\n\r\n  draw() {\r\n    if (this.options.display) {\r\n      const ctx = this.ctx;\r\n      clipArea(ctx, this);\r\n\r\n      this._draw();\r\n\r\n      unclipArea(ctx);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _draw() {\r\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\r\n    const {align, labels: labelOpts} = opts;\r\n    const defaultColor = defaults.color;\r\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\r\n    const labelFont = toFont(labelOpts.font);\r\n    const {padding} = labelOpts;\r\n    const fontSize = labelFont.size;\r\n    const halfFontSize = fontSize / 2;\r\n    let cursor;\r\n\r\n    this.drawTitle();\r\n\r\n    // Canvas setup\r\n    ctx.textAlign = rtlHelper.textAlign('left');\r\n    ctx.textBaseline = 'middle';\r\n    ctx.lineWidth = 0.5;\r\n    ctx.font = labelFont.string;\r\n\r\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\r\n\r\n    // current position\r\n    const drawLegendBox = function(x, y, legendItem) {\r\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\r\n        return;\r\n      }\r\n\r\n      // Set the ctx for the box\r\n      ctx.save();\r\n\r\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\r\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\r\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\r\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\r\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\r\n      ctx.lineWidth = lineWidth;\r\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\r\n\r\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\r\n\r\n      if (labelOpts.usePointStyle) {\r\n        // Recalculate x and y for drawPoint() because its expecting\r\n        // x and y to be center of figure (instead of top left)\r\n        const drawOptions = {\r\n          radius: boxHeight * Math.SQRT2 / 2,\r\n          pointStyle: legendItem.pointStyle,\r\n          rotation: legendItem.rotation,\r\n          borderWidth: lineWidth\r\n        };\r\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\r\n        const centerY = y + halfFontSize;\r\n\r\n        // Draw pointStyle as legend symbol\r\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\r\n      } else {\r\n        // Draw box as legend symbol\r\n        // Adjust position when boxHeight < fontSize (want it centered)\r\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\r\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\r\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\r\n\r\n        ctx.beginPath();\r\n\r\n        if (Object.values(borderRadius).some(v => v !== 0)) {\r\n          addRoundedRectPath(ctx, {\r\n            x: xBoxLeft,\r\n            y: yBoxTop,\r\n            w: boxWidth,\r\n            h: boxHeight,\r\n            radius: borderRadius,\r\n          });\r\n        } else {\r\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\r\n        }\r\n\r\n        ctx.fill();\r\n        if (lineWidth !== 0) {\r\n          ctx.stroke();\r\n        }\r\n      }\r\n\r\n      ctx.restore();\r\n    };\r\n\r\n    const fillText = function(x, y, legendItem) {\r\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\r\n        strikethrough: legendItem.hidden,\r\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\r\n      });\r\n    };\r\n\r\n    // Horizontal\r\n    const isHorizontal = this.isHorizontal();\r\n    const titleHeight = this._computeTitleHeight();\r\n    if (isHorizontal) {\r\n      cursor = {\r\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\r\n        y: this.top + padding + titleHeight,\r\n        line: 0\r\n      };\r\n    } else {\r\n      cursor = {\r\n        x: this.left + padding,\r\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\r\n        line: 0\r\n      };\r\n    }\r\n\r\n    overrideTextDirection(this.ctx, opts.textDirection);\r\n\r\n    const lineHeight = itemHeight + padding;\r\n    this.legendItems.forEach((legendItem, i) => {\r\n      ctx.strokeStyle = legendItem.fontColor; // for strikethrough effect\r\n      ctx.fillStyle = legendItem.fontColor; // render in correct colour\r\n\r\n      const textWidth = ctx.measureText(legendItem.text).width;\r\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\r\n      const width = boxWidth + halfFontSize + textWidth;\r\n      let x = cursor.x;\r\n      let y = cursor.y;\r\n\r\n      rtlHelper.setWidth(this.width);\r\n\r\n      if (isHorizontal) {\r\n        if (i > 0 && x + width + padding > this.right) {\r\n          y = cursor.y += lineHeight;\r\n          cursor.line++;\r\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\r\n        }\r\n      } else if (i > 0 && y + lineHeight > this.bottom) {\r\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\r\n        cursor.line++;\r\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\r\n      }\r\n\r\n      const realX = rtlHelper.x(x);\r\n\r\n      drawLegendBox(realX, y, legendItem);\r\n\r\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\r\n\r\n      // Fill the actual label\r\n      fillText(rtlHelper.x(x), y, legendItem);\r\n\r\n      if (isHorizontal) {\r\n        cursor.x += width + padding;\r\n      } else if (typeof legendItem.text !== 'string') {\r\n        const fontLineHeight = labelFont.lineHeight;\r\n        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight);\r\n      } else {\r\n        cursor.y += lineHeight;\r\n      }\r\n    });\r\n\r\n    restoreTextDirection(this.ctx, opts.textDirection);\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  drawTitle() {\r\n    const opts = this.options;\r\n    const titleOpts = opts.title;\r\n    const titleFont = toFont(titleOpts.font);\r\n    const titlePadding = toPadding(titleOpts.padding);\r\n\r\n    if (!titleOpts.display) {\r\n      return;\r\n    }\r\n\r\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\r\n    const ctx = this.ctx;\r\n    const position = titleOpts.position;\r\n    const halfFontSize = titleFont.size / 2;\r\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\r\n    let y;\r\n\r\n    // These defaults are used when the legend is vertical.\r\n    // When horizontal, they are computed below.\r\n    let left = this.left;\r\n    let maxWidth = this.width;\r\n\r\n    if (this.isHorizontal()) {\r\n      // Move left / right so that the title is above the legend lines\r\n      maxWidth = Math.max(...this.lineWidths);\r\n      y = this.top + topPaddingPlusHalfFontSize;\r\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\r\n    } else {\r\n      // Move down so that the title is above the legend stack in every alignment\r\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\r\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\r\n    }\r\n\r\n    // Now that we know the left edge of the inner legend box, compute the correct\r\n    // X coordinate from the title alignment\r\n    const x = _alignStartEnd(position, left, left + maxWidth);\r\n\r\n    // Canvas setup\r\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\r\n    ctx.textBaseline = 'middle';\r\n    ctx.strokeStyle = titleOpts.color;\r\n    ctx.fillStyle = titleOpts.color;\r\n    ctx.font = titleFont.string;\r\n\r\n    renderText(ctx, titleOpts.text, x, y, titleFont);\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _computeTitleHeight() {\r\n    const titleOpts = this.options.title;\r\n    const titleFont = toFont(titleOpts.font);\r\n    const titlePadding = toPadding(titleOpts.padding);\r\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _getLegendItemAt(x, y) {\r\n    let i, hitBox, lh;\r\n\r\n    if (_isBetween(x, this.left, this.right)\r\n      && _isBetween(y, this.top, this.bottom)) {\r\n      // See if we are touching one of the dataset boxes\r\n      lh = this.legendHitBoxes;\r\n      for (i = 0; i < lh.length; ++i) {\r\n        hitBox = lh[i];\r\n\r\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\r\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\r\n          // Touching an element\r\n          return this.legendItems[i];\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n\t * Handle an event\r\n\t * @param {ChartEvent} e - The event to handle\r\n\t */\r\n  handleEvent(e) {\r\n    const opts = this.options;\r\n    if (!isListened(e.type, opts)) {\r\n      return;\r\n    }\r\n\r\n    // Chart event already has relative position in it\r\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\r\n\r\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\r\n      const previous = this._hoveredItem;\r\n      const sameItem = itemsEqual(previous, hoveredItem);\r\n      if (previous && !sameItem) {\r\n        call(opts.onLeave, [e, previous, this], this);\r\n      }\r\n\r\n      this._hoveredItem = hoveredItem;\r\n\r\n      if (hoveredItem && !sameItem) {\r\n        call(opts.onHover, [e, hoveredItem, this], this);\r\n      }\r\n    } else if (hoveredItem) {\r\n      call(opts.onClick, [e, hoveredItem, this], this);\r\n    }\r\n  }\r\n}\r\n\r\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\r\n  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\r\n  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\r\n  return {itemWidth, itemHeight};\r\n}\r\n\r\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\r\n  let legendItemText = legendItem.text;\r\n  if (legendItemText && typeof legendItemText !== 'string') {\r\n    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);\r\n  }\r\n  return boxWidth + (labelFont.size / 2) + ctx.measureText(legendItemText).width;\r\n}\r\n\r\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\r\n  let itemHeight = _itemHeight;\r\n  if (typeof legendItem.text !== 'string') {\r\n    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\r\n  }\r\n  return itemHeight;\r\n}\r\n\r\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\r\n  const labelHeight = legendItem.text ? legendItem.text.length + 0.5 : 0;\r\n  return fontLineHeight * labelHeight;\r\n}\r\n\r\nfunction isListened(type, opts) {\r\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\r\n    return true;\r\n  }\r\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport default {\r\n  id: 'legend',\r\n\r\n  /**\r\n\t * For tests\r\n\t * @private\r\n\t */\r\n  _element: Legend,\r\n\r\n  start(chart, _args, options) {\r\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\r\n    layouts.configure(chart, legend, options);\r\n    layouts.addBox(chart, legend);\r\n  },\r\n\r\n  stop(chart) {\r\n    layouts.removeBox(chart, chart.legend);\r\n    delete chart.legend;\r\n  },\r\n\r\n  // During the beforeUpdate step, the layout configuration needs to run\r\n  // This ensures that if the legend position changes (via an option update)\r\n  // the layout system respects the change. See https://github.com/chartjs/Chart.js/issues/7527\r\n  beforeUpdate(chart, _args, options) {\r\n    const legend = chart.legend;\r\n    layouts.configure(chart, legend, options);\r\n    legend.options = options;\r\n  },\r\n\r\n  // The labels need to be built after datasets are updated to ensure that colors\r\n  // and other styling are correct. See https://github.com/chartjs/Chart.js/issues/6968\r\n  afterUpdate(chart) {\r\n    const legend = chart.legend;\r\n    legend.buildLabels();\r\n    legend.adjustHitBoxes();\r\n  },\r\n\r\n\r\n  afterEvent(chart, args) {\r\n    if (!args.replay) {\r\n      chart.legend.handleEvent(args.event);\r\n    }\r\n  },\r\n\r\n  defaults: {\r\n    display: true,\r\n    position: 'top',\r\n    align: 'center',\r\n    fullSize: true,\r\n    reverse: false,\r\n    weight: 1000,\r\n\r\n    // a callback that will handle\r\n    onClick(e, legendItem, legend) {\r\n      const index = legendItem.datasetIndex;\r\n      const ci = legend.chart;\r\n      if (ci.isDatasetVisible(index)) {\r\n        ci.hide(index);\r\n        legendItem.hidden = true;\r\n      } else {\r\n        ci.show(index);\r\n        legendItem.hidden = false;\r\n      }\r\n    },\r\n\r\n    onHover: null,\r\n    onLeave: null,\r\n\r\n    labels: {\r\n      color: (ctx) => ctx.chart.options.color,\r\n      boxWidth: 40,\r\n      padding: 10,\r\n      // Generates labels shown in the legend\r\n      // Valid properties to return:\r\n      // text : text to display\r\n      // fillStyle : fill of coloured box\r\n      // strokeStyle: stroke of coloured box\r\n      // hidden : if this legend item refers to a hidden item\r\n      // lineCap : cap style for line\r\n      // lineDash\r\n      // lineDashOffset :\r\n      // lineJoin :\r\n      // lineWidth :\r\n      generateLabels(chart) {\r\n        const datasets = chart.data.datasets;\r\n        const {labels: {usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius}} = chart.legend.options;\r\n\r\n        return chart._getSortedDatasetMetas().map((meta) => {\r\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\r\n          const borderWidth = toPadding(style.borderWidth);\r\n\r\n          return {\r\n            text: datasets[meta.index].label,\r\n            fillStyle: style.backgroundColor,\r\n            fontColor: color,\r\n            hidden: !meta.visible,\r\n            lineCap: style.borderCapStyle,\r\n            lineDash: style.borderDash,\r\n            lineDashOffset: style.borderDashOffset,\r\n            lineJoin: style.borderJoinStyle,\r\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\r\n            strokeStyle: style.borderColor,\r\n            pointStyle: pointStyle || style.pointStyle,\r\n            rotation: style.rotation,\r\n            textAlign: textAlign || style.textAlign,\r\n            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\r\n\r\n            // Below is extra data used for toggling the datasets\r\n            datasetIndex: meta.index\r\n          };\r\n        }, this);\r\n      }\r\n    },\r\n\r\n    title: {\r\n      color: (ctx) => ctx.chart.options.color,\r\n      display: false,\r\n      position: 'center',\r\n      text: '',\r\n    }\r\n  },\r\n\r\n  descriptors: {\r\n    _scriptable: (name) => !name.startsWith('on'),\r\n    labels: {\r\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\r\n    }\r\n  },\r\n};\r\n","import Element from '../core/core.element.js';\r\nimport layouts from '../core/core.layouts.js';\r\nimport {PI, isArray, toPadding, toFont} from '../helpers/index.js';\r\nimport {_toLeftRightCenter, _alignStartEnd} from '../helpers/helpers.extras.js';\r\nimport {renderText} from '../helpers/helpers.canvas.js';\r\n\r\nexport class Title extends Element {\r\n  /**\r\n\t * @param {{ ctx: any; options: any; chart: any; }} config\r\n\t */\r\n  constructor(config) {\r\n    super();\r\n\r\n    this.chart = config.chart;\r\n    this.options = config.options;\r\n    this.ctx = config.ctx;\r\n    this._padding = undefined;\r\n    this.top = undefined;\r\n    this.bottom = undefined;\r\n    this.left = undefined;\r\n    this.right = undefined;\r\n    this.width = undefined;\r\n    this.height = undefined;\r\n    this.position = undefined;\r\n    this.weight = undefined;\r\n    this.fullSize = undefined;\r\n  }\r\n\r\n  update(maxWidth, maxHeight) {\r\n    const opts = this.options;\r\n\r\n    this.left = 0;\r\n    this.top = 0;\r\n\r\n    if (!opts.display) {\r\n      this.width = this.height = this.right = this.bottom = 0;\r\n      return;\r\n    }\r\n\r\n    this.width = this.right = maxWidth;\r\n    this.height = this.bottom = maxHeight;\r\n\r\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\r\n    this._padding = toPadding(opts.padding);\r\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\r\n\r\n    if (this.isHorizontal()) {\r\n      this.height = textSize;\r\n    } else {\r\n      this.width = textSize;\r\n    }\r\n  }\r\n\r\n  isHorizontal() {\r\n    const pos = this.options.position;\r\n    return pos === 'top' || pos === 'bottom';\r\n  }\r\n\r\n  _drawArgs(offset) {\r\n    const {top, left, bottom, right, options} = this;\r\n    const align = options.align;\r\n    let rotation = 0;\r\n    let maxWidth, titleX, titleY;\r\n\r\n    if (this.isHorizontal()) {\r\n      titleX = _alignStartEnd(align, left, right);\r\n      titleY = top + offset;\r\n      maxWidth = right - left;\r\n    } else {\r\n      if (options.position === 'left') {\r\n        titleX = left + offset;\r\n        titleY = _alignStartEnd(align, bottom, top);\r\n        rotation = PI * -0.5;\r\n      } else {\r\n        titleX = right - offset;\r\n        titleY = _alignStartEnd(align, top, bottom);\r\n        rotation = PI * 0.5;\r\n      }\r\n      maxWidth = bottom - top;\r\n    }\r\n    return {titleX, titleY, maxWidth, rotation};\r\n  }\r\n\r\n  draw() {\r\n    const ctx = this.ctx;\r\n    const opts = this.options;\r\n\r\n    if (!opts.display) {\r\n      return;\r\n    }\r\n\r\n    const fontOpts = toFont(opts.font);\r\n    const lineHeight = fontOpts.lineHeight;\r\n    const offset = lineHeight / 2 + this._padding.top;\r\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\r\n\r\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\r\n      color: opts.color,\r\n      maxWidth,\r\n      rotation,\r\n      textAlign: _toLeftRightCenter(opts.align),\r\n      textBaseline: 'middle',\r\n      translation: [titleX, titleY],\r\n    });\r\n  }\r\n}\r\n\r\nfunction createTitle(chart, titleOpts) {\r\n  const title = new Title({\r\n    ctx: chart.ctx,\r\n    options: titleOpts,\r\n    chart\r\n  });\r\n\r\n  layouts.configure(chart, title, titleOpts);\r\n  layouts.addBox(chart, title);\r\n  chart.titleBlock = title;\r\n}\r\n\r\nexport default {\r\n  id: 'title',\r\n\r\n  /**\r\n\t * For tests\r\n\t * @private\r\n\t */\r\n  _element: Title,\r\n\r\n  start(chart, _args, options) {\r\n    createTitle(chart, options);\r\n  },\r\n\r\n  stop(chart) {\r\n    const titleBlock = chart.titleBlock;\r\n    layouts.removeBox(chart, titleBlock);\r\n    delete chart.titleBlock;\r\n  },\r\n\r\n  beforeUpdate(chart, _args, options) {\r\n    const title = chart.titleBlock;\r\n    layouts.configure(chart, title, options);\r\n    title.options = options;\r\n  },\r\n\r\n  defaults: {\r\n    align: 'center',\r\n    display: false,\r\n    font: {\r\n      weight: 'bold',\r\n    },\r\n    fullSize: true,\r\n    padding: 10,\r\n    position: 'top',\r\n    text: '',\r\n    weight: 2000         // by default greater than legend (1000) to be above\r\n  },\r\n\r\n  defaultRoutes: {\r\n    color: 'color'\r\n  },\r\n\r\n  descriptors: {\r\n    _scriptable: true,\r\n    _indexable: false,\r\n  },\r\n};\r\n","import {Title} from './plugin.title.js';\r\nimport layouts from '../core/core.layouts.js';\r\n\r\nconst map = new WeakMap();\r\n\r\nexport default {\r\n  id: 'subtitle',\r\n\r\n  start(chart, _args, options) {\r\n    const title = new Title({\r\n      ctx: chart.ctx,\r\n      options,\r\n      chart\r\n    });\r\n\r\n    layouts.configure(chart, title, options);\r\n    layouts.addBox(chart, title);\r\n    map.set(chart, title);\r\n  },\r\n\r\n  stop(chart) {\r\n    layouts.removeBox(chart, map.get(chart));\r\n    map.delete(chart);\r\n  },\r\n\r\n  beforeUpdate(chart, _args, options) {\r\n    const title = map.get(chart);\r\n    layouts.configure(chart, title, options);\r\n    title.options = options;\r\n  },\r\n\r\n  defaults: {\r\n    align: 'center',\r\n    display: false,\r\n    font: {\r\n      weight: 'normal',\r\n    },\r\n    fullSize: true,\r\n    padding: 0,\r\n    position: 'top',\r\n    text: '',\r\n    weight: 1500         // by default greater than legend (1000) and smaller than title (2000)\r\n  },\r\n\r\n  defaultRoutes: {\r\n    color: 'color'\r\n  },\r\n\r\n  descriptors: {\r\n    _scriptable: true,\r\n    _indexable: false,\r\n  },\r\n};\r\n","import Animations from '../core/core.animations.js';\r\nimport Element from '../core/core.element.js';\r\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\r\nimport {each, noop, isNullOrUndef, isArray, _elementsEqual, isObject} from '../helpers/helpers.core.js';\r\nimport {toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\r\nimport {getRtlAdapter, overrideTextDirection, restoreTextDirection} from '../helpers/helpers.rtl.js';\r\nimport {distanceBetweenPoints, _limitValue} from '../helpers/helpers.math.js';\r\nimport {createContext, drawPoint} from '../helpers/index.js';\r\n\r\n/**\r\n * @typedef { import('../platform/platform.base.js').Chart } Chart\r\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\r\n * @typedef { import('../types/index.js').ActiveElement } ActiveElement\r\n * @typedef { import('../core/core.interaction.js').InteractionItem } InteractionItem\r\n */\r\n\r\nconst positioners = {\r\n  /**\r\n\t * Average mode places the tooltip at the average position of the elements shown\r\n\t */\r\n  average(items) {\r\n    if (!items.length) {\r\n      return false;\r\n    }\r\n\r\n    let i, len;\r\n    let x = 0;\r\n    let y = 0;\r\n    let count = 0;\r\n\r\n    for (i = 0, len = items.length; i < len; ++i) {\r\n      const el = items[i].element;\r\n      if (el && el.hasValue()) {\r\n        const pos = el.tooltipPosition();\r\n        x += pos.x;\r\n        y += pos.y;\r\n        ++count;\r\n      }\r\n    }\r\n\r\n    return {\r\n      x: x / count,\r\n      y: y / count\r\n    };\r\n  },\r\n\r\n  /**\r\n\t * Gets the tooltip position nearest of the item nearest to the event position\r\n\t */\r\n  nearest(items, eventPosition) {\r\n    if (!items.length) {\r\n      return false;\r\n    }\r\n\r\n    let x = eventPosition.x;\r\n    let y = eventPosition.y;\r\n    let minDistance = Number.POSITIVE_INFINITY;\r\n    let i, len, nearestElement;\r\n\r\n    for (i = 0, len = items.length; i < len; ++i) {\r\n      const el = items[i].element;\r\n      if (el && el.hasValue()) {\r\n        const center = el.getCenterPoint();\r\n        const d = distanceBetweenPoints(eventPosition, center);\r\n\r\n        if (d < minDistance) {\r\n          minDistance = d;\r\n          nearestElement = el;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (nearestElement) {\r\n      const tp = nearestElement.tooltipPosition();\r\n      x = tp.x;\r\n      y = tp.y;\r\n    }\r\n\r\n    return {\r\n      x,\r\n      y\r\n    };\r\n  }\r\n};\r\n\r\n// Helper to push or concat based on if the 2nd parameter is an array or not\r\nfunction pushOrConcat(base, toPush) {\r\n  if (toPush) {\r\n    if (isArray(toPush)) {\r\n      // base = base.concat(toPush);\r\n      Array.prototype.push.apply(base, toPush);\r\n    } else {\r\n      base.push(toPush);\r\n    }\r\n  }\r\n\r\n  return base;\r\n}\r\n\r\n/**\r\n * Returns array of strings split by newline\r\n * @param {*} str - The value to split by newline.\r\n * @returns {string|string[]} value if newline present - Returned from String split() method\r\n * @function\r\n */\r\nfunction splitNewlines(str) {\r\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\r\n    return str.split('\\n');\r\n  }\r\n  return str;\r\n}\r\n\r\n\r\n/**\r\n * Private helper to create a tooltip item model\r\n * @param {Chart} chart\r\n * @param {ActiveElement} item - {element, index, datasetIndex} to create the tooltip item for\r\n * @return new tooltip item\r\n */\r\nfunction createTooltipItem(chart, item) {\r\n  const {element, datasetIndex, index} = item;\r\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\r\n  const {label, value} = controller.getLabelAndValue(index);\r\n\r\n  return {\r\n    chart,\r\n    label,\r\n    parsed: controller.getParsed(index),\r\n    raw: chart.data.datasets[datasetIndex].data[index],\r\n    formattedValue: value,\r\n    dataset: controller.getDataset(),\r\n    dataIndex: index,\r\n    datasetIndex,\r\n    element\r\n  };\r\n}\r\n\r\n/**\r\n * Get the size of the tooltip\r\n */\r\nfunction getTooltipSize(tooltip, options) {\r\n  const ctx = tooltip.chart.ctx;\r\n  const {body, footer, title} = tooltip;\r\n  const {boxWidth, boxHeight} = options;\r\n  const bodyFont = toFont(options.bodyFont);\r\n  const titleFont = toFont(options.titleFont);\r\n  const footerFont = toFont(options.footerFont);\r\n  const titleLineCount = title.length;\r\n  const footerLineCount = footer.length;\r\n  const bodyLineItemCount = body.length;\r\n\r\n  const padding = toPadding(options.padding);\r\n  let height = padding.height;\r\n  let width = 0;\r\n\r\n  // Count of all lines in the body\r\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\r\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\r\n\r\n  if (titleLineCount) {\r\n    height += titleLineCount * titleFont.lineHeight\r\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\r\n\t\t\t+ options.titleMarginBottom;\r\n  }\r\n  if (combinedBodyLength) {\r\n    // Body lines may include some extra height depending on boxHeight\r\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\r\n    height += bodyLineItemCount * bodyLineHeight\r\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\r\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\r\n  }\r\n  if (footerLineCount) {\r\n    height += options.footerMarginTop\r\n\t\t\t+ footerLineCount * footerFont.lineHeight\r\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\r\n  }\r\n\r\n  // Title width\r\n  let widthPadding = 0;\r\n  const maxLineWidth = function(line) {\r\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\r\n  };\r\n\r\n  ctx.save();\r\n\r\n  ctx.font = titleFont.string;\r\n  each(tooltip.title, maxLineWidth);\r\n\r\n  // Body width\r\n  ctx.font = bodyFont.string;\r\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\r\n\r\n  // Body lines may include some extra width due to the color box\r\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\r\n  each(body, (bodyItem) => {\r\n    each(bodyItem.before, maxLineWidth);\r\n    each(bodyItem.lines, maxLineWidth);\r\n    each(bodyItem.after, maxLineWidth);\r\n  });\r\n\r\n  // Reset back to 0\r\n  widthPadding = 0;\r\n\r\n  // Footer width\r\n  ctx.font = footerFont.string;\r\n  each(tooltip.footer, maxLineWidth);\r\n\r\n  ctx.restore();\r\n\r\n  // Add padding\r\n  width += padding.width;\r\n\r\n  return {width, height};\r\n}\r\n\r\nfunction determineYAlign(chart, size) {\r\n  const {y, height} = size;\r\n\r\n  if (y < height / 2) {\r\n    return 'top';\r\n  } else if (y > (chart.height - height / 2)) {\r\n    return 'bottom';\r\n  }\r\n  return 'center';\r\n}\r\n\r\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\r\n  const {x, width} = size;\r\n  const caret = options.caretSize + options.caretPadding;\r\n  if (xAlign === 'left' && x + width + caret > chart.width) {\r\n    return true;\r\n  }\r\n\r\n  if (xAlign === 'right' && x - width - caret < 0) {\r\n    return true;\r\n  }\r\n}\r\n\r\nfunction determineXAlign(chart, options, size, yAlign) {\r\n  const {x, width} = size;\r\n  const {width: chartWidth, chartArea: {left, right}} = chart;\r\n  let xAlign = 'center';\r\n\r\n  if (yAlign === 'center') {\r\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\r\n  } else if (x <= width / 2) {\r\n    xAlign = 'left';\r\n  } else if (x >= chartWidth - width / 2) {\r\n    xAlign = 'right';\r\n  }\r\n\r\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\r\n    xAlign = 'center';\r\n  }\r\n\r\n  return xAlign;\r\n}\r\n\r\n/**\r\n * Helper to get the alignment of a tooltip given the size\r\n */\r\nfunction determineAlignment(chart, options, size) {\r\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\r\n\r\n  return {\r\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\r\n    yAlign\r\n  };\r\n}\r\n\r\nfunction alignX(size, xAlign) {\r\n  let {x, width} = size;\r\n  if (xAlign === 'right') {\r\n    x -= width;\r\n  } else if (xAlign === 'center') {\r\n    x -= (width / 2);\r\n  }\r\n  return x;\r\n}\r\n\r\nfunction alignY(size, yAlign, paddingAndSize) {\r\n  // eslint-disable-next-line prefer-const\r\n  let {y, height} = size;\r\n  if (yAlign === 'top') {\r\n    y += paddingAndSize;\r\n  } else if (yAlign === 'bottom') {\r\n    y -= height + paddingAndSize;\r\n  } else {\r\n    y -= (height / 2);\r\n  }\r\n  return y;\r\n}\r\n\r\n/**\r\n * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\r\n */\r\nfunction getBackgroundPoint(options, size, alignment, chart) {\r\n  const {caretSize, caretPadding, cornerRadius} = options;\r\n  const {xAlign, yAlign} = alignment;\r\n  const paddingAndSize = caretSize + caretPadding;\r\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\r\n\r\n  let x = alignX(size, xAlign);\r\n  const y = alignY(size, yAlign, paddingAndSize);\r\n\r\n  if (yAlign === 'center') {\r\n    if (xAlign === 'left') {\r\n      x += paddingAndSize;\r\n    } else if (xAlign === 'right') {\r\n      x -= paddingAndSize;\r\n    }\r\n  } else if (xAlign === 'left') {\r\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\r\n  } else if (xAlign === 'right') {\r\n    x += Math.max(topRight, bottomRight) + caretSize;\r\n  }\r\n\r\n  return {\r\n    x: _limitValue(x, 0, chart.width - size.width),\r\n    y: _limitValue(y, 0, chart.height - size.height)\r\n  };\r\n}\r\n\r\nfunction getAlignedX(tooltip, align, options) {\r\n  const padding = toPadding(options.padding);\r\n\r\n  return align === 'center'\r\n    ? tooltip.x + tooltip.width / 2\r\n    : align === 'right'\r\n      ? tooltip.x + tooltip.width - padding.right\r\n      : tooltip.x + padding.left;\r\n}\r\n\r\n/**\r\n * Helper to build before and after body lines\r\n */\r\nfunction getBeforeAfterBodyLines(callback) {\r\n  return pushOrConcat([], splitNewlines(callback));\r\n}\r\n\r\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\r\n  return createContext(parent, {\r\n    tooltip,\r\n    tooltipItems,\r\n    type: 'tooltip'\r\n  });\r\n}\r\n\r\nfunction overrideCallbacks(callbacks, context) {\r\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\r\n  return override ? callbacks.override(override) : callbacks;\r\n}\r\n\r\nconst defaultCallbacks = {\r\n  // Args are: (tooltipItems, data)\r\n  beforeTitle: noop,\r\n  title(tooltipItems) {\r\n    if (tooltipItems.length > 0) {\r\n      const item = tooltipItems[0];\r\n      const labels = item.chart.data.labels;\r\n      const labelCount = labels ? labels.length : 0;\r\n\r\n      if (this && this.options && this.options.mode === 'dataset') {\r\n        return item.dataset.label || '';\r\n      } else if (item.label) {\r\n        return item.label;\r\n      } else if (labelCount > 0 && item.dataIndex < labelCount) {\r\n        return labels[item.dataIndex];\r\n      }\r\n    }\r\n\r\n    return '';\r\n  },\r\n  afterTitle: noop,\r\n\r\n  // Args are: (tooltipItems, data)\r\n  beforeBody: noop,\r\n\r\n  // Args are: (tooltipItem, data)\r\n  beforeLabel: noop,\r\n  label(tooltipItem) {\r\n    if (this && this.options && this.options.mode === 'dataset') {\r\n      return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\r\n    }\r\n\r\n    let label = tooltipItem.dataset.label || '';\r\n\r\n    if (label) {\r\n      label += ': ';\r\n    }\r\n    const value = tooltipItem.formattedValue;\r\n    if (!isNullOrUndef(value)) {\r\n      label += value;\r\n    }\r\n    return label;\r\n  },\r\n  labelColor(tooltipItem) {\r\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\r\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\r\n    return {\r\n      borderColor: options.borderColor,\r\n      backgroundColor: options.backgroundColor,\r\n      borderWidth: options.borderWidth,\r\n      borderDash: options.borderDash,\r\n      borderDashOffset: options.borderDashOffset,\r\n      borderRadius: 0,\r\n    };\r\n  },\r\n  labelTextColor() {\r\n    return this.options.bodyColor;\r\n  },\r\n  labelPointStyle(tooltipItem) {\r\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\r\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\r\n    return {\r\n      pointStyle: options.pointStyle,\r\n      rotation: options.rotation,\r\n    };\r\n  },\r\n  afterLabel: noop,\r\n\r\n  // Args are: (tooltipItems, data)\r\n  afterBody: noop,\r\n\r\n  // Args are: (tooltipItems, data)\r\n  beforeFooter: noop,\r\n  footer: noop,\r\n  afterFooter: noop\r\n};\r\n\r\n/**\r\n * Invoke callback from object with context and arguments.\r\n * If callback returns `undefined`, then will be invoked default callback.\r\n * @param {Record<keyof typeof defaultCallbacks, Function>} callbacks\r\n * @param {keyof typeof defaultCallbacks} name\r\n * @param {*} ctx\r\n * @param {*} arg\r\n * @returns {any}\r\n */\r\nfunction invokeCallbackWithFallback(callbacks, name, ctx, arg) {\r\n  const result = callbacks[name].call(ctx, arg);\r\n\r\n  if (typeof result === 'undefined') {\r\n    return defaultCallbacks[name].call(ctx, arg);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport class Tooltip extends Element {\r\n\r\n  /**\r\n   * @namespace Chart.Tooltip.positioners\r\n   */\r\n  static positioners = positioners;\r\n\r\n  constructor(config) {\r\n    super();\r\n\r\n    this.opacity = 0;\r\n    this._active = [];\r\n    this._eventPosition = undefined;\r\n    this._size = undefined;\r\n    this._cachedAnimations = undefined;\r\n    this._tooltipItems = [];\r\n    this.$animations = undefined;\r\n    this.$context = undefined;\r\n    this.chart = config.chart;\r\n    this.options = config.options;\r\n    this.dataPoints = undefined;\r\n    this.title = undefined;\r\n    this.beforeBody = undefined;\r\n    this.body = undefined;\r\n    this.afterBody = undefined;\r\n    this.footer = undefined;\r\n    this.xAlign = undefined;\r\n    this.yAlign = undefined;\r\n    this.x = undefined;\r\n    this.y = undefined;\r\n    this.height = undefined;\r\n    this.width = undefined;\r\n    this.caretX = undefined;\r\n    this.caretY = undefined;\r\n    // TODO: V4, make this private, rename to `_labelStyles`, and combine with `labelPointStyles`\r\n    // and `labelTextColors` to create a single variable\r\n    this.labelColors = undefined;\r\n    this.labelPointStyles = undefined;\r\n    this.labelTextColors = undefined;\r\n  }\r\n\r\n  initialize(options) {\r\n    this.options = options;\r\n    this._cachedAnimations = undefined;\r\n    this.$context = undefined;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _resolveAnimations() {\r\n    const cached = this._cachedAnimations;\r\n\r\n    if (cached) {\r\n      return cached;\r\n    }\r\n\r\n    const chart = this.chart;\r\n    const options = this.options.setContext(this.getContext());\r\n    const opts = options.enabled && chart.options.animation && options.animations;\r\n    const animations = new Animations(this.chart, opts);\r\n    if (opts._cacheable) {\r\n      this._cachedAnimations = Object.freeze(animations);\r\n    }\r\n\r\n    return animations;\r\n  }\r\n\r\n  /**\r\n\t * @protected\r\n\t */\r\n  getContext() {\r\n    return this.$context ||\r\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\r\n  }\r\n\r\n  getTitle(context, options) {\r\n    const {callbacks} = options;\r\n\r\n    const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\r\n    const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\r\n    const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\r\n\r\n    let lines = [];\r\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\r\n    lines = pushOrConcat(lines, splitNewlines(title));\r\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\r\n\r\n    return lines;\r\n  }\r\n\r\n  getBeforeBody(tooltipItems, options) {\r\n    return getBeforeAfterBodyLines(\r\n      invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems)\r\n    );\r\n  }\r\n\r\n  getBody(tooltipItems, options) {\r\n    const {callbacks} = options;\r\n    const bodyItems = [];\r\n\r\n    each(tooltipItems, (context) => {\r\n      const bodyItem = {\r\n        before: [],\r\n        lines: [],\r\n        after: []\r\n      };\r\n      const scoped = overrideCallbacks(callbacks, context);\r\n      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\r\n      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\r\n      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\r\n\r\n      bodyItems.push(bodyItem);\r\n    });\r\n\r\n    return bodyItems;\r\n  }\r\n\r\n  getAfterBody(tooltipItems, options) {\r\n    return getBeforeAfterBodyLines(\r\n      invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems)\r\n    );\r\n  }\r\n\r\n  // Get the footer and beforeFooter and afterFooter lines\r\n  getFooter(tooltipItems, options) {\r\n    const {callbacks} = options;\r\n\r\n    const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\r\n    const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\r\n    const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\r\n\r\n    let lines = [];\r\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\r\n    lines = pushOrConcat(lines, splitNewlines(footer));\r\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\r\n\r\n    return lines;\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _createItems(options) {\r\n    const active = this._active;\r\n    const data = this.chart.data;\r\n    const labelColors = [];\r\n    const labelPointStyles = [];\r\n    const labelTextColors = [];\r\n    let tooltipItems = [];\r\n    let i, len;\r\n\r\n    for (i = 0, len = active.length; i < len; ++i) {\r\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\r\n    }\r\n\r\n    // If the user provided a filter function, use it to modify the tooltip items\r\n    if (options.filter) {\r\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\r\n    }\r\n\r\n    // If the user provided a sorting function, use it to modify the tooltip items\r\n    if (options.itemSort) {\r\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\r\n    }\r\n\r\n    // Determine colors for boxes\r\n    each(tooltipItems, (context) => {\r\n      const scoped = overrideCallbacks(options.callbacks, context);\r\n      labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\r\n      labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\r\n      labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\r\n    });\r\n\r\n    this.labelColors = labelColors;\r\n    this.labelPointStyles = labelPointStyles;\r\n    this.labelTextColors = labelTextColors;\r\n    this.dataPoints = tooltipItems;\r\n    return tooltipItems;\r\n  }\r\n\r\n  update(changed, replay) {\r\n    const options = this.options.setContext(this.getContext());\r\n    const active = this._active;\r\n    let properties;\r\n    let tooltipItems = [];\r\n\r\n    if (!active.length) {\r\n      if (this.opacity !== 0) {\r\n        properties = {\r\n          opacity: 0\r\n        };\r\n      }\r\n    } else {\r\n      const position = positioners[options.position].call(this, active, this._eventPosition);\r\n      tooltipItems = this._createItems(options);\r\n\r\n      this.title = this.getTitle(tooltipItems, options);\r\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\r\n      this.body = this.getBody(tooltipItems, options);\r\n      this.afterBody = this.getAfterBody(tooltipItems, options);\r\n      this.footer = this.getFooter(tooltipItems, options);\r\n\r\n      const size = this._size = getTooltipSize(this, options);\r\n      const positionAndSize = Object.assign({}, position, size);\r\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\r\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\r\n\r\n      this.xAlign = alignment.xAlign;\r\n      this.yAlign = alignment.yAlign;\r\n\r\n      properties = {\r\n        opacity: 1,\r\n        x: backgroundPoint.x,\r\n        y: backgroundPoint.y,\r\n        width: size.width,\r\n        height: size.height,\r\n        caretX: position.x,\r\n        caretY: position.y\r\n      };\r\n    }\r\n\r\n    this._tooltipItems = tooltipItems;\r\n    this.$context = undefined;\r\n\r\n    if (properties) {\r\n      this._resolveAnimations().update(this, properties);\r\n    }\r\n\r\n    if (changed && options.external) {\r\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\r\n    }\r\n  }\r\n\r\n  drawCaret(tooltipPoint, ctx, size, options) {\r\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\r\n\r\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\r\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\r\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\r\n  }\r\n\r\n  getCaretPosition(tooltipPoint, size, options) {\r\n    const {xAlign, yAlign} = this;\r\n    const {caretSize, cornerRadius} = options;\r\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\r\n    const {x: ptX, y: ptY} = tooltipPoint;\r\n    const {width, height} = size;\r\n    let x1, x2, x3, y1, y2, y3;\r\n\r\n    if (yAlign === 'center') {\r\n      y2 = ptY + (height / 2);\r\n\r\n      if (xAlign === 'left') {\r\n        x1 = ptX;\r\n        x2 = x1 - caretSize;\r\n\r\n        // Left draws bottom -> top, this y1 is on the bottom\r\n        y1 = y2 + caretSize;\r\n        y3 = y2 - caretSize;\r\n      } else {\r\n        x1 = ptX + width;\r\n        x2 = x1 + caretSize;\r\n\r\n        // Right draws top -> bottom, thus y1 is on the top\r\n        y1 = y2 - caretSize;\r\n        y3 = y2 + caretSize;\r\n      }\r\n\r\n      x3 = x1;\r\n    } else {\r\n      if (xAlign === 'left') {\r\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\r\n      } else if (xAlign === 'right') {\r\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\r\n      } else {\r\n        x2 = this.caretX;\r\n      }\r\n\r\n      if (yAlign === 'top') {\r\n        y1 = ptY;\r\n        y2 = y1 - caretSize;\r\n\r\n        // Top draws left -> right, thus x1 is on the left\r\n        x1 = x2 - caretSize;\r\n        x3 = x2 + caretSize;\r\n      } else {\r\n        y1 = ptY + height;\r\n        y2 = y1 + caretSize;\r\n\r\n        // Bottom draws right -> left, thus x1 is on the right\r\n        x1 = x2 + caretSize;\r\n        x3 = x2 - caretSize;\r\n      }\r\n      y3 = y1;\r\n    }\r\n    return {x1, x2, x3, y1, y2, y3};\r\n  }\r\n\r\n  drawTitle(pt, ctx, options) {\r\n    const title = this.title;\r\n    const length = title.length;\r\n    let titleFont, titleSpacing, i;\r\n\r\n    if (length) {\r\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\r\n\r\n      pt.x = getAlignedX(this, options.titleAlign, options);\r\n\r\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\r\n      ctx.textBaseline = 'middle';\r\n\r\n      titleFont = toFont(options.titleFont);\r\n      titleSpacing = options.titleSpacing;\r\n\r\n      ctx.fillStyle = options.titleColor;\r\n      ctx.font = titleFont.string;\r\n\r\n      for (i = 0; i < length; ++i) {\r\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\r\n        pt.y += titleFont.lineHeight + titleSpacing; // Line Height and spacing\r\n\r\n        if (i + 1 === length) {\r\n          pt.y += options.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * @private\r\n\t */\r\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\r\n    const labelColor = this.labelColors[i];\r\n    const labelPointStyle = this.labelPointStyles[i];\r\n    const {boxHeight, boxWidth} = options;\r\n    const bodyFont = toFont(options.bodyFont);\r\n    const colorX = getAlignedX(this, 'left', options);\r\n    const rtlColorX = rtlHelper.x(colorX);\r\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\r\n    const colorY = pt.y + yOffSet;\r\n\r\n    if (options.usePointStyle) {\r\n      const drawOptions = {\r\n        radius: Math.min(boxWidth, boxHeight) / 2, // fit the circle in the box\r\n        pointStyle: labelPointStyle.pointStyle,\r\n        rotation: labelPointStyle.rotation,\r\n        borderWidth: 1\r\n      };\r\n      // Recalculate x and y for drawPoint() because its expecting\r\n      // x and y to be center of figure (instead of top left)\r\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\r\n      const centerY = colorY + boxHeight / 2;\r\n\r\n      // Fill the point with white so that colours merge nicely if the opacity is < 1\r\n      ctx.strokeStyle = options.multiKeyBackground;\r\n      ctx.fillStyle = options.multiKeyBackground;\r\n      drawPoint(ctx, drawOptions, centerX, centerY);\r\n\r\n      // Draw the point\r\n      ctx.strokeStyle = labelColor.borderColor;\r\n      ctx.fillStyle = labelColor.backgroundColor;\r\n      drawPoint(ctx, drawOptions, centerX, centerY);\r\n    } else {\r\n      // Border\r\n      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : (labelColor.borderWidth || 1); // TODO, v4 remove fallback\r\n      ctx.strokeStyle = labelColor.borderColor;\r\n      ctx.setLineDash(labelColor.borderDash || []);\r\n      ctx.lineDashOffset = labelColor.borderDashOffset || 0;\r\n\r\n      // Fill a white rect so that colours merge nicely if the opacity is < 1\r\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\r\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\r\n      const borderRadius = toTRBLCorners(labelColor.borderRadius);\r\n\r\n      if (Object.values(borderRadius).some(v => v !== 0)) {\r\n        ctx.beginPath();\r\n        ctx.fillStyle = options.multiKeyBackground;\r\n        addRoundedRectPath(ctx, {\r\n          x: outerX,\r\n          y: colorY,\r\n          w: boxWidth,\r\n          h: boxHeight,\r\n          radius: borderRadius,\r\n        });\r\n        ctx.fill();\r\n        ctx.stroke();\r\n\r\n        // Inner square\r\n        ctx.fillStyle = labelColor.backgroundColor;\r\n        ctx.beginPath();\r\n        addRoundedRectPath(ctx, {\r\n          x: innerX,\r\n          y: colorY + 1,\r\n          w: boxWidth - 2,\r\n          h: boxHeight - 2,\r\n          radius: borderRadius,\r\n        });\r\n        ctx.fill();\r\n      } else {\r\n        // Normal rect\r\n        ctx.fillStyle = options.multiKeyBackground;\r\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\r\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\r\n        // Inner square\r\n        ctx.fillStyle = labelColor.backgroundColor;\r\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\r\n      }\r\n    }\r\n\r\n    // restore fillStyle\r\n    ctx.fillStyle = this.labelTextColors[i];\r\n  }\r\n\r\n  drawBody(pt, ctx, options) {\r\n    const {body} = this;\r\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\r\n    const bodyFont = toFont(options.bodyFont);\r\n    let bodyLineHeight = bodyFont.lineHeight;\r\n    let xLinePadding = 0;\r\n\r\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\r\n\r\n    const fillLineOfText = function(line) {\r\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\r\n      pt.y += bodyLineHeight + bodySpacing;\r\n    };\r\n\r\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\r\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\r\n\r\n    ctx.textAlign = bodyAlign;\r\n    ctx.textBaseline = 'middle';\r\n    ctx.font = bodyFont.string;\r\n\r\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\r\n\r\n    // Before body lines\r\n    ctx.fillStyle = options.bodyColor;\r\n    each(this.beforeBody, fillLineOfText);\r\n\r\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\r\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\r\n      : 0;\r\n\r\n    // Draw body lines now\r\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\r\n      bodyItem = body[i];\r\n      textColor = this.labelTextColors[i];\r\n\r\n      ctx.fillStyle = textColor;\r\n      each(bodyItem.before, fillLineOfText);\r\n\r\n      lines = bodyItem.lines;\r\n      // Draw Legend-like boxes if needed\r\n      if (displayColors && lines.length) {\r\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\r\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\r\n      }\r\n\r\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\r\n        fillLineOfText(lines[j]);\r\n        // Reset for any lines that don't include colorbox\r\n        bodyLineHeight = bodyFont.lineHeight;\r\n      }\r\n\r\n      each(bodyItem.after, fillLineOfText);\r\n    }\r\n\r\n    // Reset back to 0 for after body\r\n    xLinePadding = 0;\r\n    bodyLineHeight = bodyFont.lineHeight;\r\n\r\n    // After body lines\r\n    each(this.afterBody, fillLineOfText);\r\n    pt.y -= bodySpacing; // Remove last body spacing\r\n  }\r\n\r\n  drawFooter(pt, ctx, options) {\r\n    const footer = this.footer;\r\n    const length = footer.length;\r\n    let footerFont, i;\r\n\r\n    if (length) {\r\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\r\n\r\n      pt.x = getAlignedX(this, options.footerAlign, options);\r\n      pt.y += options.footerMarginTop;\r\n\r\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\r\n      ctx.textBaseline = 'middle';\r\n\r\n      footerFont = toFont(options.footerFont);\r\n\r\n      ctx.fillStyle = options.footerColor;\r\n      ctx.font = footerFont.string;\r\n\r\n      for (i = 0; i < length; ++i) {\r\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\r\n        pt.y += footerFont.lineHeight + options.footerSpacing;\r\n      }\r\n    }\r\n  }\r\n\r\n  drawBackground(pt, ctx, tooltipSize, options) {\r\n    const {xAlign, yAlign} = this;\r\n    const {x, y} = pt;\r\n    const {width, height} = tooltipSize;\r\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\r\n\r\n    ctx.fillStyle = options.backgroundColor;\r\n    ctx.strokeStyle = options.borderColor;\r\n    ctx.lineWidth = options.borderWidth;\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(x + topLeft, y);\r\n    if (yAlign === 'top') {\r\n      this.drawCaret(pt, ctx, tooltipSize, options);\r\n    }\r\n    ctx.lineTo(x + width - topRight, y);\r\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\r\n    if (yAlign === 'center' && xAlign === 'right') {\r\n      this.drawCaret(pt, ctx, tooltipSize, options);\r\n    }\r\n    ctx.lineTo(x + width, y + height - bottomRight);\r\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\r\n    if (yAlign === 'bottom') {\r\n      this.drawCaret(pt, ctx, tooltipSize, options);\r\n    }\r\n    ctx.lineTo(x + bottomLeft, y + height);\r\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\r\n    if (yAlign === 'center' && xAlign === 'left') {\r\n      this.drawCaret(pt, ctx, tooltipSize, options);\r\n    }\r\n    ctx.lineTo(x, y + topLeft);\r\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\r\n    ctx.closePath();\r\n\r\n    ctx.fill();\r\n\r\n    if (options.borderWidth > 0) {\r\n      ctx.stroke();\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Update x/y animation targets when _active elements are animating too\r\n\t * @private\r\n\t */\r\n  _updateAnimationTarget(options) {\r\n    const chart = this.chart;\r\n    const anims = this.$animations;\r\n    const animX = anims && anims.x;\r\n    const animY = anims && anims.y;\r\n    if (animX || animY) {\r\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\r\n      if (!position) {\r\n        return;\r\n      }\r\n      const size = this._size = getTooltipSize(this, options);\r\n      const positionAndSize = Object.assign({}, position, this._size);\r\n      const alignment = determineAlignment(chart, options, positionAndSize);\r\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\r\n      if (animX._to !== point.x || animY._to !== point.y) {\r\n        this.xAlign = alignment.xAlign;\r\n        this.yAlign = alignment.yAlign;\r\n        this.width = size.width;\r\n        this.height = size.height;\r\n        this.caretX = position.x;\r\n        this.caretY = position.y;\r\n        this._resolveAnimations().update(this, point);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Determine if the tooltip will draw anything\r\n   * @returns {boolean} True if the tooltip will render\r\n   */\r\n  _willRender() {\r\n    return !!this.opacity;\r\n  }\r\n\r\n  draw(ctx) {\r\n    const options = this.options.setContext(this.getContext());\r\n    let opacity = this.opacity;\r\n\r\n    if (!opacity) {\r\n      return;\r\n    }\r\n\r\n    this._updateAnimationTarget(options);\r\n\r\n    const tooltipSize = {\r\n      width: this.width,\r\n      height: this.height\r\n    };\r\n    const pt = {\r\n      x: this.x,\r\n      y: this.y\r\n    };\r\n\r\n    // IE11/Edge does not like very small opacities, so snap to 0\r\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\r\n\r\n    const padding = toPadding(options.padding);\r\n\r\n    // Truthy/falsey value for empty tooltip\r\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\r\n\r\n    if (options.enabled && hasTooltipContent) {\r\n      ctx.save();\r\n      ctx.globalAlpha = opacity;\r\n\r\n      // Draw Background\r\n      this.drawBackground(pt, ctx, tooltipSize, options);\r\n\r\n      overrideTextDirection(ctx, options.textDirection);\r\n\r\n      pt.y += padding.top;\r\n\r\n      // Titles\r\n      this.drawTitle(pt, ctx, options);\r\n\r\n      // Body\r\n      this.drawBody(pt, ctx, options);\r\n\r\n      // Footer\r\n      this.drawFooter(pt, ctx, options);\r\n\r\n      restoreTextDirection(ctx, options.textDirection);\r\n\r\n      ctx.restore();\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Get active elements in the tooltip\r\n\t * @returns {Array} Array of elements that are active in the tooltip\r\n\t */\r\n  getActiveElements() {\r\n    return this._active || [];\r\n  }\r\n\r\n  /**\r\n\t * Set active elements in the tooltip\r\n\t * @param {array} activeElements Array of active datasetIndex/index pairs.\r\n\t * @param {object} eventPosition Synthetic event position used in positioning\r\n\t */\r\n  setActiveElements(activeElements, eventPosition) {\r\n    const lastActive = this._active;\r\n    const active = activeElements.map(({datasetIndex, index}) => {\r\n      const meta = this.chart.getDatasetMeta(datasetIndex);\r\n\r\n      if (!meta) {\r\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\r\n      }\r\n\r\n      return {\r\n        datasetIndex,\r\n        element: meta.data[index],\r\n        index,\r\n      };\r\n    });\r\n    const changed = !_elementsEqual(lastActive, active);\r\n    const positionChanged = this._positionChanged(active, eventPosition);\r\n\r\n    if (changed || positionChanged) {\r\n      this._active = active;\r\n      this._eventPosition = eventPosition;\r\n      this._ignoreReplayEvents = true;\r\n      this.update(true);\r\n    }\r\n  }\r\n\r\n  /**\r\n\t * Handle an event\r\n\t * @param {ChartEvent} e - The event to handle\r\n\t * @param {boolean} [replay] - This is a replayed event (from update)\r\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\r\n\t * @returns {boolean} true if the tooltip changed\r\n\t */\r\n  handleEvent(e, replay, inChartArea = true) {\r\n    if (replay && this._ignoreReplayEvents) {\r\n      return false;\r\n    }\r\n    this._ignoreReplayEvents = false;\r\n\r\n    const options = this.options;\r\n    const lastActive = this._active || [];\r\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\r\n\r\n    // When there are multiple items shown, but the tooltip position is nearest mode\r\n    // an update may need to be made because our position may have changed even though\r\n    // the items are the same as before.\r\n    const positionChanged = this._positionChanged(active, e);\r\n\r\n    // Remember Last Actives\r\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\r\n\r\n    // Only handle target event on tooltip change\r\n    if (changed) {\r\n      this._active = active;\r\n\r\n      if (options.enabled || options.external) {\r\n        this._eventPosition = {\r\n          x: e.x,\r\n          y: e.y\r\n        };\r\n\r\n        this.update(true, replay);\r\n      }\r\n    }\r\n\r\n    return changed;\r\n  }\r\n\r\n  /**\r\n\t * Helper for determining the active elements for event\r\n\t * @param {ChartEvent} e - The event to handle\r\n\t * @param {InteractionItem[]} lastActive - Previously active elements\r\n\t * @param {boolean} [replay] - This is a replayed event (from update)\r\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\r\n\t * @returns {InteractionItem[]} - Active elements\r\n\t * @private\r\n\t */\r\n  _getActiveElements(e, lastActive, replay, inChartArea) {\r\n    const options = this.options;\r\n\r\n    if (e.type === 'mouseout') {\r\n      return [];\r\n    }\r\n\r\n    if (!inChartArea) {\r\n      // Let user control the active elements outside chartArea. Eg. using Legend.\r\n      return lastActive;\r\n    }\r\n\r\n    // Find Active Elements for tooltips\r\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\r\n\r\n    if (options.reverse) {\r\n      active.reverse();\r\n    }\r\n\r\n    return active;\r\n  }\r\n\r\n  /**\r\n\t * Determine if the active elements + event combination changes the\r\n\t * tooltip position\r\n\t * @param {array} active - Active elements\r\n\t * @param {ChartEvent} e - Event that triggered the position change\r\n\t * @returns {boolean} True if the position has changed\r\n\t */\r\n  _positionChanged(active, e) {\r\n    const {caretX, caretY, options} = this;\r\n    const position = positioners[options.position].call(this, active, e);\r\n    return position !== false && (caretX !== position.x || caretY !== position.y);\r\n  }\r\n}\r\n\r\nexport default {\r\n  id: 'tooltip',\r\n  _element: Tooltip,\r\n  positioners,\r\n\r\n  afterInit(chart, _args, options) {\r\n    if (options) {\r\n      chart.tooltip = new Tooltip({chart, options});\r\n    }\r\n  },\r\n\r\n  beforeUpdate(chart, _args, options) {\r\n    if (chart.tooltip) {\r\n      chart.tooltip.initialize(options);\r\n    }\r\n  },\r\n\r\n  reset(chart, _args, options) {\r\n    if (chart.tooltip) {\r\n      chart.tooltip.initialize(options);\r\n    }\r\n  },\r\n\r\n  afterDraw(chart) {\r\n    const tooltip = chart.tooltip;\r\n\r\n    if (tooltip && tooltip._willRender()) {\r\n      const args = {\r\n        tooltip\r\n      };\r\n\r\n      if (chart.notifyPlugins('beforeTooltipDraw', {...args, cancelable: true}) === false) {\r\n        return;\r\n      }\r\n\r\n      tooltip.draw(chart.ctx);\r\n\r\n      chart.notifyPlugins('afterTooltipDraw', args);\r\n    }\r\n  },\r\n\r\n  afterEvent(chart, args) {\r\n    if (chart.tooltip) {\r\n      // If the event is replayed from `update`, we should evaluate with the final positions.\r\n      const useFinalPosition = args.replay;\r\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\r\n        // notify chart about the change, so it will render\r\n        args.changed = true;\r\n      }\r\n    }\r\n  },\r\n\r\n  defaults: {\r\n    enabled: true,\r\n    external: null,\r\n    position: 'average',\r\n    backgroundColor: 'rgba(0,0,0,0.8)',\r\n    titleColor: '#fff',\r\n    titleFont: {\r\n      weight: 'bold',\r\n    },\r\n    titleSpacing: 2,\r\n    titleMarginBottom: 6,\r\n    titleAlign: 'left',\r\n    bodyColor: '#fff',\r\n    bodySpacing: 2,\r\n    bodyFont: {\r\n    },\r\n    bodyAlign: 'left',\r\n    footerColor: '#fff',\r\n    footerSpacing: 2,\r\n    footerMarginTop: 6,\r\n    footerFont: {\r\n      weight: 'bold',\r\n    },\r\n    footerAlign: 'left',\r\n    padding: 6,\r\n    caretPadding: 2,\r\n    caretSize: 5,\r\n    cornerRadius: 6,\r\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\r\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\r\n    multiKeyBackground: '#fff',\r\n    displayColors: true,\r\n    boxPadding: 0,\r\n    borderColor: 'rgba(0,0,0,0)',\r\n    borderWidth: 0,\r\n    animation: {\r\n      duration: 400,\r\n      easing: 'easeOutQuart',\r\n    },\r\n    animations: {\r\n      numbers: {\r\n        type: 'number',\r\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\r\n      },\r\n      opacity: {\r\n        easing: 'linear',\r\n        duration: 200\r\n      }\r\n    },\r\n    callbacks: defaultCallbacks\r\n  },\r\n\r\n  defaultRoutes: {\r\n    bodyFont: 'font',\r\n    footerFont: 'font',\r\n    titleFont: 'font'\r\n  },\r\n\r\n  descriptors: {\r\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\r\n    _indexable: false,\r\n    callbacks: {\r\n      _scriptable: false,\r\n      _indexable: false,\r\n    },\r\n    animation: {\r\n      _fallback: false\r\n    },\r\n    animations: {\r\n      _fallback: 'animation'\r\n    }\r\n  },\r\n\r\n  // Resolve additionally from `interaction` options and defaults.\r\n  additionalOptionScopes: ['interaction']\r\n};\r\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n// @ts-nocheck\r\n\r\n/**\r\n * @namespace Chart\r\n */\r\nimport Chart from './core/core.controller.js';\r\n\r\nimport * as helpers from './helpers/index.js';\r\nimport _adapters from './core/core.adapters.js';\r\nimport Animation from './core/core.animation.js';\r\nimport animator from './core/core.animator.js';\r\nimport Animations from './core/core.animations.js';\r\nimport * as controllers from './controllers/index.js';\r\nimport DatasetController from './core/core.datasetController.js';\r\nimport Element from './core/core.element.js';\r\nimport * as elements from './elements/index.js';\r\nimport Interaction from './core/core.interaction.js';\r\nimport layouts from './core/core.layouts.js';\r\nimport * as platforms from './platform/index.js';\r\nimport * as plugins from './plugins/index.js';\r\nimport registry from './core/core.registry.js';\r\nimport Scale from './core/core.scale.js';\r\nimport * as scales from './scales/index.js';\r\nimport Ticks from './core/core.ticks.js';\r\n\r\n// Register built-ins\r\nChart.register(controllers, scales, elements, plugins);\r\n\r\nChart.helpers = {...helpers};\r\nChart._adapters = _adapters;\r\nChart.Animation = Animation;\r\nChart.Animations = Animations;\r\nChart.animator = animator;\r\nChart.controllers = registry.controllers.items;\r\nChart.DatasetController = DatasetController;\r\nChart.Element = Element;\r\nChart.elements = elements;\r\nChart.Interaction = Interaction;\r\nChart.layouts = layouts;\r\nChart.platforms = platforms;\r\nChart.Scale = Scale;\r\nChart.Ticks = Ticks;\r\n\r\n// Compatibility with ESM extensions\r\nObject.assign(Chart, controllers, scales, elements, plugins, platforms);\r\nChart.Chart = Chart;\r\n\r\nif (typeof window !== 'undefined') {\r\n  window.Chart = Chart;\r\n}\r\n\r\nexport default Chart;\r\n\r\n"],"names":["id","uid","isNullOrUndef","value","Array","isArray","isNumberFinite","defaultValue","type","slice","isObject","Object","prototype","toString","call","i","len","Number","isFinite","fn","finiteOrDefault","valueOrDefault","v1","dimension","endsWith","parseFloat","callback","args","thisArg","apply","each","loopable","reverse","source","length","keys","k","target","isValidKey","_elementsEqual","a0","a1","tval","sval","merge","options","v0","datasetIndex","index","clone","merger","ilen","current","sources","create","klen","mergeIf","indexOf","key","_merger","v","o","y","parts","split","tmp","part","_mergerIf","resolveObjectKey","obj","_capitalize","str","hasOwnProperty","keyResolvers","x","e","INFINITY","POSITIVE_INFINITY","RAD_PER_DEG","PI","HALF_PI","QUARTER_PI","TWO_THIRDS_PI","log10","sign","abs","epsilon","Math","almostEquals","roundedRange","round","range","niceFraction","niceRange","pow","floor","result","sqrt","_factorize","b","a","push","almostWhole","sort","isNaN","array","degrees","property","toDegrees","radians","min","max","toRadians","p","angle","distance","radialDistanceFromCenter","distanceBetweenPoints","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","_normalizeAngle","TAU","angleToStart","endToAngle","angleToEnd","_angleDiff","_limitValue","_lookup","table","cmp","mid","hi","lo","end","last","values","start","_rlookupByKey","defineProperty","enumerable","listener","arrayEvents","_chartjs","base","listeners","stub","method","splice","this","forEach","object","res","set","unlistenArrayEvents","items","size","requestAnimFrame","window","requestAnimationFrame","argsToUse","ticking","debounce","timeout","delay","align","clearTimeout","setTimeout","meta","_alignStartEnd","_textX","left","right","rtl","count","_getStartAndCountOfVisiblePoints","points","animationsDisabled","pointCount","iScale","_parsed","axis","minDefined","maxDefined","getUserBounds","xScale","xmin","xmax","_lookupByKey","getPixelForValue","ymax","newRanges","assign","changed","Animator","constructor","_request","anims","numSteps","callbacks","chart","initial","_notify","date","duration","currentStep","_running","_charts","item","_active","remaining","draw","_total","tick","charts","get","running","complete","progress","event","Date","cur","_getAnims","has","now","reduce","acc","_duration","_refresh","lim","l","h","p2b","n2b","b2n","n2p","map$1","A","B","C","D","E","F","c","d","f","hex","h1","h2","eq","hexString","r","g","isShort","alpha","undefined","HUE_RE","hsl2rgbn","s","n","hsv2rgbn","hwb2rgbn","w","rgb","rgb2hsl","hueValue","calln","map","hsl2rgb","hue","hueParse","m","exec","p1","p2","hwb2rgb","hsv2rgb","Z","Y","X","W","V","U","T","S","R","Q","P","O","N","M","L","K","G","H","I","J","names$1","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","names","nameParse","unpacked","tkeys","j","ok","nk","replace","parseInt","unpack","transparent","toLowerCase","RGB_RE","to","from","modHSL","ratio","proto","fromObject","input","functionParse","charAt","rgbParse","Color","ret","_rgb","_valid","valid","rgbString","hslString","mix","color","weight","c1","c2","w2","w1","interpolate","t","rgb1","rgb2","clearer","greyscale","val","opaquer","negate","lighten","darken","saturate","desaturate","rotate","deg","isPatternOrGradient","getHoverColor","numbers","colors","intlCache","Map","formatNumber","num","locale","cacheKey","JSON","stringify","formatter","Intl","NumberFormat","getNumberFormat","format","formatters","notation","delta","numeric","tickValue","numDecimal","maximumFractionDigits","maxTick","ticks","calculateDelta","logDelta","minimumFractionDigits","remain","logarithmic","significand","overrides","descriptors","node","root","scope","getScope","Defaults","_descriptors","_appliers","events","backgroundColor","borderColor","datasets","devicePixelRatio","context","platform","getDevicePixelRatio","elements","font","family","style","lineHeight","hover","intersect","includeInvisible","ctx","hoverBorderColor","maintainAspectRatio","onHover","onClick","mode","scales","showLine","drawActiveElementsOnTop","describe","responsive","scale","defineProperties","route","name","targetScope","targetName","scopeObject","_scriptable","privateName","applyAnimationsDefaults","applyLayoutsDefaults","applyScaleDefaults","targetScopeObject","defaults","easing","loop","_fallback","_indexable","properties","active","animation","resize","show","animations","visible","hide","autoPadding","padding","top","bottom","display","offset","beginAtZero","drawOnChartArea","tickColor","grid","dash","dashOffset","width","tickWidth","_ctx","lineWidth","text","title","minRotation","mirror","labelOffset","maxRotation","Ticks","minor","major","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","startsWith","parent","document","valueInPixels","domNode","getComputedStyle","element","ownerDocument","getStyle","getPropertyValue","styleValue","parentNode","parentProperty","defaultView","pos","el","styles","touches","suffix","offsetX","offsetY","box","useOffsetPos","height","rect","maxWidth","maxHeight","canvas","currentDevicePixelRatio","clientHeight","paddings","getPositionedStyle","borders","container","clientY","shadowRoot","borderBox","boxSizing","xOffset","yOffset","containerBorder","containerStyle","containerPadding","maintainHeight","aspectRatio","parseMaxStyle","containerSize","_getParentNode","margins","bbHeight","getContainerSize","bbWidth","round1","forceStyle","pixelRatio","retinaScale","forceRatio","passiveSupported","deviceHeight","deviceWidth","toFontString","_measureText","textWidth","data","string","gc","longest","measureText","cache","_longestText","arrayOfThings","garbageCollect","jlen","nestedThing","thing","gcLen","restore","halfWidth","drawPointLegend","radius","rotation","translate","cornerRadius","xOffsetW","yOffsetW","pointStyle","rad","ellipse","closePath","drawImage","arc","cos","sin","moveTo","lineTo","borderWidth","stroke","margin","area","point","clipArea","save","unclipArea","fill","beginPath","bezierCurveTo","opts","previous","flip","textAlign","midpoint","textBaseline","strikethrough","yDecoration","cp1x","cp2x","cp1y","cp2y","decorateText","line","underline","metrics","strokeColor","actualBoundingBoxLeft","strokeStyle","actualBoundingBoxAscent","strokeWidth","fillStyle","decorationWidth","fillText","drawBackdrop","oldColor","fillRect","topLeft","bottomLeft","lines","translation","backdrop","scopes","fallback","getTarget","override","Symbol","_cacheable","_scopes","_rootScopes","rootScopes","_createResolver","prefixes","Proxy","deleteProperty","prop","Reflect","getPrototypeOf","_cached","parsed","_resolveWithPrefixes","getOwnPropertyDescriptor","_stack","Set","descriptorDefaults","ownKeys","getKeysFromAllScopes","storage","_storage","_resolveWithContext","_keys","configurable","_attachContext","proxy","subProxy","_proxy","_context","setContext","_allKeys","isIndexable","isFunction","_subProxy","isScriptable","receiver","Error","join","createSubResolver","resolveFallback","needsSubResolver","add","allScopes","defined","filter","arr","resolver","addScopesFromKey","_resolveArray","allKeys","resolve","_resolveScriptable","delete","scriptable","indexable","readKey","subGetTarget","parentScopes","parentFallback","resolveKeysFromAllScopes","addScopes","EPSILON","getPoint","skip","getValueAxis","indexAxis","splineCurve","firstPoint","middlePoint","afterPoint","next","d01","d12","s01","s12","fa","fb","pointAfter","valueAxis","pointsLen","pointCurrent","pointBefore","deltaK","monotoneAdjust","monotoneCompute","slopeDelta","mK","tauK","alphaK","betaK","squaredMagnitude","inAreaPrev","iPixel","vPixel","_isPointInArea","inArea","inAreaNext","prev","capBezierPoints","controlPoints","capControlPoint","atEdge","elasticIn","elasticOut","effects","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeOutBounce","easeInOutBounce","_steppedInterpolation","_bezierInterpolation","_pointInLine","cp2","cp1","LINE_HEIGHT","FONT_STYLE","toLineHeight","match","matches","_readValueToProps","props","objProps","read","warn","toTRBLCorners","toPadding","inputs","cacheable","info","console","grace","keepZero","change","createContext","getRtlAdapter","rectX","setWidth","xPlus","leftForLtr","itemWidth","getRightToLeftAdapter","_itemWidth","overrideTextDirection","direction","original","getPropertyPriority","setProperty","prevTextDirection","restoreTextDirection","between","_angleBetween","compare","_isBetween","normalize","bounds","shouldStop","endIsBefore","startBound","endBound","propertyFn","segment","getSegment","prevValue","inside","subStart","shouldStart","_boundSegment","normalizeSegment","segments","sub","_computeSegments","segmentOptions","spanGaps","dir","splitByStyles","stop","findStartAndEnd","completeLoop","doSplitByStyles","solidSegments","_fullLoop","chartContext","_chart","getContext","addStyle","prevStyle","readStyle","st","borderCapStyle","borderDashOffset","p0DataIndex","p1DataIndex","pixelSize","fontStyle","fontFamily","binarySearch","metaset","controller","lookupMethod","_sorted","_reversePixels","_sharedOptions","getRange","metasets","handler","deltaX","getSortedVisibleDatasetMetas","position","isPointInArea","useFinalPosition","evaluateInteractionItems","chartArea","inRange","minDistance","useX","pt1","pt2","deltaY","useY","intersectsItem","center","getCenterPoint","distanceMetric","getRelativePosition","getNearestCartesianItems","getNearestRadialItems","getAxisItems","Interaction","STATIC_POSITIONS","filterByPosition","filterDynamicPositionByAxis","layouts","stacks","wrap","includes","stack","stackWeight","vBoxMaxWidth","fullSize","hBoxMaxHeight","params","layout","factor","availableHeight","sortByWeight","boxPadding","maxPadding","updateDims","horizontal","updateMaxPadding","getPadding","newWidth","newHeight","widthChanged","heightChanged","other","handleMaxPadding","marginForPositions","positions","fitBoxes","boxes","refit","same","getMargins","refitBoxes","placeBoxes","userPadding","setBoxDims","placed","height1","width1","addBox","_layers","verticalBoxes","horizontalBoxes","layoutItem","minPadding","visibleVerticalBoxCount","availableWidth","layoutBoxes","buildStacks","centerHorizontal","centerVertical","concat","vertical","rightAndBottom","getCombinedMax","total","freeze","outerWidth","updatePos","BasePlatform","acquireContext","releaseContext","BasicPlatform","config","touchend","EVENT_TYPES","pointerout","touchmove","pointerenter","pointerdown","pointermove","pointerup","pointerleave","renderHeight","renderWidth","isNullOrEmpty","nodeListContains","nodeList","eventListenerOptions","childList","subtree","observer","trigger","entry","addedNodes","entries","removedNodes","observe","drpListeningCharts","oldDevicePixelRatio","addEventListener","dpr","removeEventListener","onWindowResize","throttled","contentRect","releaseObserver","disconnect","addListener","clientWidth","createProxyAndListen","native","fromNativeEvent","EXPANDO_KEY","getAttribute","displayWidth","displayHeight","readUsedSize","initCanvas","proxies","createAttachObserver","createResizeObserver","getMaximumSize","attach","detach","_detectPlatform","_isDomSupported","OffscreenCanvas","DomPlatform","interpolators","boolean","number","c0","helpersColor","Animation","cfg","currentValue","_loop","_target","_prop","_from","_to","_promises","update","_start","elapsed","promises","Promise","_fn","rej","resolved","Animations","_properties","configure","animationOptions","animatedProps","getOwnPropertyNames","option","_animateOptions","newOptions","$animations","resolveTargetOptions","_createAnimations","$shared","anim","wait","all","awaitAll","then","allowedOverflow","yScale","filterVisible","otherValue","singleMode","dsIndex","convertObjectDataToArray","isStacked","stacked","indexScale","getOrCreateStack","stackKey","indexValue","getLastIndexInStack","vScale","positive","getMatchingVisibleMetas","updateStacks","iAxis","vAxis","_stacks","valueScale","getStackKey","itemStacks","visualValues","_top","_bottom","_visualValues","getFirstScaleId","shift","clearStacks","cloneIfNotShared","getSortedDatasetIndices","cached","shared","DatasetController","static","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","getMeta","datasetElementType","dataElementType","_parsing","_data","_objectData","linkScales","_stacked","addElements","updateIndex","_cachedMeta","isPluginEnabled","dataset","yid","rid","vAxisID","getScaleForId","chooseId","xid","xAxisID","yAxisID","rAxisID","iid","iAxisID","vid","rScale","getDataset","_update","_destroy","adata","oldStacked","listenArrayEvents","stackChanged","_dataCheck","resetNewElements","_resyncElements","parsePrimitiveData","scopeKeys","datasetScopeKeys","_type","getOptionScopes","_cachedDataOpts","sorted","labels","parse","singleScale","parseArrayData","parsedValue","parseObjectData","xAxisKey","otherScale","updateRangeFromParsed","yAxisKey","getParsed","getDataElement","applyStack","NaN","label","toClip","_getOtherScale","canStack","hidden","createStack","NEGATIVE_INFINITY","otherMax","otherMin","_skip","dataIndex","getMaxOverflow","getLabelAndValue","getLabelForValue","elementType","disabled","_drawStart","raw","resolveDataElementOptions","getSharedOptions","firstOpts","updateSharedOptions","sharedOptions","includeOptions","_resolveElementOptions","sharing","removeHoverStyle","setHoverStyle","resolveNamedOptions","arg2","numData","transition","_insertElements","_removeElements","datasetAnimationScopeKeys","move","isDirectUpdateMode","_animationsDisabled","removed","previouslySharedOptions","_setStyle","_resolveAnimations","_removeDatasetHoverStyle","_setDatasetHoverStyle","Element","tooltipPosition","getProps","hasValue","isNumber","final","autoSkip","tickLength","_tickSize","maxScale","_length","_maxLength","maxChart","majorIndices","newTicks","tickOpts","enabled","getMajorIndices","spacing","numMajorIndices","majorStart","ceil","ticksLimit","evenMajorSpacing","getEvenSpacing","factors","determineMaxTicks","avgMajorSpacing","first","majorEnd","diff","offsetFromEdge","edge","getTicksLimit","ticksLength","maxTicksLimit","sample","numItems","increment","validIndex","_startPixel","getPixelForGridLine","offsetGridLines","_endPixel","lineValue","getPixelForTick","getTickMarkLength","drawTicks","positionAxisID","_toLeftRightCenter","reverseAlign","Scale","super","paddingTop","paddingLeft","labelRotation","_margins","paddingBottom","_borderValue","_cache","_dataLimitsCached","_gridLineItems","_labelItems","init","_userMin","_suggestedMax","_userMax","_suggestedMin","_ticksLength","metas","getMinMax","paddingRight","getTicks","getLabels","isHorizontal","xLabels","yLabels","_computeLabelItems","beforeUpdate","samplingEnabled","sampleSize","_convertTicksToLabels","beforeFit","afterFit","afterUpdate","reversePixels","startPixel","endPixel","_labelSizes","beforeSetDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","_range","_addGrace","beforeBuildTicks","buildTicks","afterBuildTicks","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","afterAutoSkip","fit","_callHooks","_alignToPixels","alignToPixels","labelSizes","maxLabelWidth","beforeTickToLabelConversion","afterTickToLabelConversion","titleHeight","titleOpts","minSize","tickPadding","angleRadians","labelHeight","labelWidth","highest","numTicks","getTitleHeight","maxLabelDiagonal","maxLabelHeight","asin","_calculatePadding","gridOpts","widest","_getLabelSizes","_handleMargins","isRotated","labelsBelowTicks","offsetLeft","offsetRight","tickFont","_resolveTickFontOptions","nestedLabel","widths","heights","widestLabelSize","decimal","pixel","_computeLabelSizes","caches","highestLabelSize","fontString","rot","autoSkipPadding","toFont","border","idx","borderOpts","alignBorderValue","y2","tx2","y1","tx1","axisHalfWidth","getDecimalForPixel","step","limit","getBasePixel","optsAtIndexBorder","_alignPixel","alignedLineValue","ty2","titleY","titleX","titleArgs","x1","lineColor","borderDash","tickBorderDashOffset","tickAndPadding","hTickAndPadding","tl","axisWidth","_getYAxisLabelAlignment","borderValue","ty1","lineCount","optsAtIndex","positionAxisID1","value1","textOffset","tickBorderDash","x2","labelPadding","optionTicks","_getXAxisLabelAlignment","tickTextAlign","halfCount","textStrokeColor","textStrokeWidth","getLineWidthForValue","_isVisible","lineDashOffset","drawLine","getLabelItems","renderTextOptions","renderText","titleAlign","findIndex","drawGrid","tz","gz","bz","drawBorder","lastLineWidth","fontSize","isForType","isPrototypeOf","parentScope","register","registerDefaults","propertyParts","sourceName","sourceScope","routes","isIChartComponent","pop","routeDefaults","defaultRoutes","TypedRegistry","plugins","_typedRegistries","controllers","_each","remove","addControllers","addPlugins","getController","_get","getElement","getPlugin","reg","removeElements","removePlugins","component","camelMethod","removeScales","typedRegistry","arg","_getRegistryForType","PluginService","_init","descriptor","_createDescriptors","callCallback","plugin","hook","_oldCache","invalidate","previousDescriptors","localIds","registry","getOpts","local","i1","pluginOpts","allPlugins","createDescriptors","_notifyStateChanges","some","createResolver","getIndexAxis","datasetDefaults","idMatchesAxis","determineAxis","scaleOptions","getAxisFromDataset","mergeScaleConfig","chartDefaults","configScales","chartIndexAxis","scaleConf","error","boundDs","retrieveAxisFromDatasets","defaultId","getDefaultScaleIDFromAxis","defaultScaleOptions","defaultID","getAxisFromDefaultScaleID","initOptions","initData","keyCache","keysCached","cachedKeys","generate","addIfFound","Config","_config","initConfig","_scopeCache","_resolverCache","clearCache","clear","datasetType","datasetElementScopeKeys","additionalOptionScopes","mainScope","keyLists","resetCache","_cachedScopes","needContext","subResolver","chartOptionScopes","subPrefixes","getResolver","hasFunction","KNOWN_POSITIONS","compare2Level","l1","l2","onAnimationsComplete","onComplete","onAnimationProgress","onProgress","getCanvas","getElementById","getChart","instances","intKey","inChartArea","invalidatePlugins","userConfig","existingChart","initialCanvas","updateConfig","_aspectRatio","_lastEvent","_plugins","$proxies","_hiddenIndices","attached","_doResize","_dataChanges","_listeners","_responsiveListeners","animator","listen","_initialize","_options","clearCanvas","notifyPlugins","_resize","_resizeBeforeDraw","newSize","newRatio","axisOptions","axisID","onResize","scaleOpts","updated","render","dposition","buildOrUpdateScales","scaleClass","scaleType","dtype","hasUpdated","positionIsHorizontal","getScale","numMeta","_updateMetasets","_metasets","newControllers","getDatasetMeta","_sortedMetasets","order","isDatasetVisible","_dataset","_removeUnreferencedMetasets","ControllerClass","cancelable","reset","_resetElements","_minPadding","animsDisabled","_updateScales","_checkEventBindings","buildOrUpdateControllers","_updateHoverStyles","buildOrUpdateElements","removeBox","setsEqual","newEvents","_updateDatasets","_getUniformDataChanges","moveNumericKeys","_eventHandler","makeSet","ensureScalesHaveIDs","existingEvents","noArea","changes","datasetCount","changeSet","_updateLayout","ilen1","layers","_drawDataset","useClip","getDatasetArea","z","clip","getElementsAtEventForMode","_clip","toggleDataVisibility","getDataVisibility","modes","_updateVisibility","destroy","getVisibleDatasetCount","setDatasetVisibility","_remove","_destroyDatasetMeta","_stop","_add","detached","unbindEvents","toBase64Image","toDataURL","bindEvents","updateHoverStyle","deactivated","replay","activated","eventFilter","prefix","activeElements","lastActive","notify","lastEvent","isClick","abstract","formats","DateAdapterBase","members","endOf","updateMinAndPrev","$bar","visibleMetas","getAllParsedValues","_arrayUnique","curr","thickness","parseValue","barEnd","barStart","startValue","endValue","_custom","parseArrayOrPrimitive","isFloatBar","borderProps","custom","setBorderSkipped","borderSkipped","parseEdge","swap","startEnd","v2","orig","inflateAmount","setInflateAmount","grouped","DoughnutController","animateRotate","animateScale","circumference","generateLabels","legend","fontColor","legendItem","innerRadius","outerRadius","getter","_getRotation","_getRotationExtents","getMaxBorderWidth","cutout","toPercentage","radiusLength","arcs","getMaxOffset","maxSize","chartWeight","startX","startY","startAngle","endX","endAngle","endY","calcMax","calcMin","maxX","maxY","minX","minY","ratioX","ratioY","getRatioAndOffset","maxRadius","toDimension","updateElements","_getVisibleDatasetWeightTotal","_getRingWeightOffset","animationOpts","centerX","_circumference","centerY","_getSharedOptions","updateElement","metaData","calculateCircumference","calculateTotal","ringWeightOffset","borderAlign","hoverBorderWidth","hoverOffset","PolarAreaController","circular","pointLabels","_parseObjectDataRadialScale","bind","_updateRadius","cutoutPercentage","datasetStartAngle","xCenter","getIndexAngle","defaultAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","categoryPercentage","barPercentage","_value_","vAxisKey","iAxisKey","vpixels","enableBorderRadius","ipixels","skipNull","head","_calculateBarValuePixels","_calculateBarIndexPixels","ruler","bars","pixels","_getStackCount","barSign","getPixelForDecimal","barThickness","computeMinSampleSize","stackCount","halfGrid","baseValue","minBarLength","actualBase","maxBarThickness","rects","percent","chunk","initialize","_scaleRangesChanged","_datasetIndex","_decimated","resolveDatasetElementOptions","animated","maxGapLength","directUpdate","pointsCount","prevParsed","nullData","lastPoint","pointPosition","getPointPositionForValue","parseBorderRadius","angleDelta","innerLimit","halfThickness","computeOuterLimit","outerArcLimit","innerStart","outerStart","innerEnd","outerEnd","rThetaToXY","theta","pathArc","spacingOffset","innerR","outerEndAdjustedRadius","outerStartAdjustedAngle","innerStartAdjustedAngle","avNogSpacingRadius","innerStartAdjustedRadius","innerEndAdjustedRadius","outerMidAdjustedAngle","outerEndAdjustedAngle","angleOffset","outerStartAdjustedRadius","innerEndAdjustedAngle","innerMidAdjustedAngle","pCenter","p8","outerEndY","drawArc","pCenter3","outerStartX","outerStartY","outerEndX","fullCircles","setLineDash","inner","clipArc","lineJoin","borderJoinStyle","ArcElement","pixelMargin","angleMargin","pathVars","segmentStart","paramsEnd","paramsStart","segmentEnd","pathSegment","lineMethod","_bezierCurveTo","_steppedLineTo","tension","cubicInterpolationMode","stepped","fastPathSegment","avgX","countX","pointIndex","drawX","prevX","truncX","lastY","useFastPath","path","usePath2D","_path","Path2D","strokePathWithCache","segmentMethod","_getSegmentMethod","setStyle","strokePathDirect","LineElement","_updateBezierControlPoints","_segments","_pointsUpdated","interpolated","_boundSegments","hitRadius","getBarBounds","bar","half","skipOrLimit","boundingRects","toTRBL","maxH","maxW","enableBorder","topRight","maxR","bottomRight","outer","skipX","hasRadius","skipY","amount","refRect","borderRadius","chartX","chartY","betweenAngles","halfRadius","withinRadius","halfAngle","hoverRadius","mouseX","mouseY","inXRange","drawPoint","addRectPath","inflateRect","addRoundedRectPath","addNormalRectPath","inYRange","findOrAddLabel","addedLabels","unshift","addIfString","lastIndexOf","_getLabelForValue","relativeLabelSize","minSpacing","LinearScaleBase","_endValue","_valueRange","minSign","setMax","handleTickRangeOptions","setMin","maxSign","maxTicks","stepSize","getTickLimit","precision","dataRange","_setMinAndMaxByKey","MIN_SPACING","rmax","unit","maxSpaces","rmin","countDefined","numSpaces","niceMax","niceNum","niceMin","decimalPlaces","includeBounds","generationOptions","_startValue","generateTicks","LinearScale","computeTickLimit","getValueForPixel","log10Floor","changeExponent","isMajor","tickVal","steps","rangeExp","rangeStep","exp","minExp","lastTick","LogarithmicScale","_zero","getTickBackdropHeight","determineLimits","fitWithPointLabels","_padding","valueCount","pointLabelOpts","additionalAngle","centerPointLabels","getPointPosition","plFont","textSize","hLimits","vLimits","setCenterPoint","limits","_pointLabelItems","updateLimits","extra","outerDistance","pointLabelPosition","getTextAlignForAngle","leftForTextAlign","buildPointLabelItems","pathRadiusLine","labelCount","yCenter","drawRadiusLine","RadialLinearScale","angleLines","drawingArea","_pointLabels","generateTickLabels","rightMovement","bottomMovement","angleMultiplier","topMovement","leftMovement","scalingFactor","getPointLabelContext","scaledDistance","pointLabel","distanceFromCenter","getBasePosition","getPointLabelPosition","drawPointLabels","backdropLeft","backdropTop","backdropWidth","backdropHeight","gridLineOpts","drawLabels","second","INTERVALS","common","year","adapter","_adapter","parser","isoWeekday","startOf","minUnit","capacity","UNITS","interval","MAX_SAFE_INTEGER","addTick","majorUnit","timestamps","time","adapters","_normalized","setMajorTicks","_applyBounds","_majorUnit","_offsets","_date","displayFormats","_parseOpts","timeOpts","normalized","initOffsets","getDecimalForValue","_getLabelBounds","getLabelTimestamps","_unit","determineUnitForAutoTicks","_getLabelCapacity","determineUnitForFormatting","determineMajorUnit","ticksFromTimestamps","minorFormat","offsets","_generate","ticksOpts","tickLabelWidth","cosRotation","sinRotation","weekday","hasWeekday","getDataTimestamps","tooltipFormat","fmt","prevSource","nextSource","prevTarget","nextTarget","TimeScale","span","added","_addedLabels","_table","_minPos","_tableRange","BORDER_COLORS","BACKGROUND_COLORS","getBorderColor","getBackgroundColor","getColorizer","colorizeDoughnutDataset","colorizePolarAreaDataset","colorizeDefaultDataset","containsColorsDefinitions","plugin_colors","forceOverride","beforeLayout","_args","chartOptions","colorizer","writable","cleanDecimatedData","cleanDecimatedDataset","algorithm","xAxis","parsing","getStartAndCountOfVisiblePointsSimplified","threshold","decimated","samples","sampledIndex","bucketWidth","endIndex","avgRangeStart","nextA","avgRangeEnd","avgY","avgRangeLength","pointAx","rangeOffs","maxArea","rangeTo","maxAreaPoint","minMaxDecimation","lttbDecimation","minIndex","maxIndex","startIndex","xMax","xMin","lastIndex","intermediateIndex1","intermediateIndex2","_getBounds","_findSegmentEnd","_getEdge","boundary","linePoints","_resolveTarget","propagate","visited","_decodeFill","parseFillOption","firstCh","decodeTargetIndex","sourcePoint","linesBelow","postponed","pointValue","findPoint","simpleArc","_getTarget","getLineByIndex","below","addPointsBelow","sourcePoints","_buildStackLine","computeLinearBoundary","getBaseValue","_getTargetPixel","computeCircularBoundary","_drawfill","lineOpts","fillOption","above","clipVertical","doFill","clipY","lineLoop","tpoints","targetSegments","tgt","subBounds","fillSources","fillSource","src","notShape","clipBounds","interpolatedLineTo","targetLoop","interpolatedPoint","afterDatasetsUpdate","drawTime","updateControlPoints","beforeDatasetsDraw","$filler","_shouldApplyFill","beforeDatasetDraw","labelOpts","boxHeight","boxWidth","pointStyleWidth","itemHeight","itemsEqual","Legend","_added","_hoveredItem","lineWidths","setDimensions","buildLabels","legendItems","labelFont","_fitRows","getBoxSize","_fitCols","legendHitBoxes","row","hitboxes","totalHeight","_itemHeight","columnSizes","heightLimit","totalWidth","currentColHeight","currentColWidth","legendItemText","fontLineHeight","calculateLegendItemHeight","calculateItemHeight","col","rtlHelper","adjustHitBoxes","hitbox","hitbox1","defaultColor","_draw","drawLegendBox","cursor","drawTitle","lineCap","textDirection","realX","SQRT2","lineDash","halfFontSize","drawOptions","yBoxTop","xBoxLeft","titleFont","topPaddingPlusHalfFontSize","titlePadding","_computeTitleHeight","_getLegendItemAt","lh","isListened","hoveredItem","hitBox","onLeave","sameItem","calculateItemSize","calculateItemWidth","_element","ci","handleEvent","usePointStyle","useBorderRadius","_getSortedDatasetMetas","Title","_drawArgs","fontOpts","plugin_title","titleBlock","createTitle","WeakMap","plugin_subtitle","positioners","average","nearest","nearestElement","eventPosition","tp","toPush","bodyFont","footerFont","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","tooltip","getTooltipSize","body","footer","footerMarginTop","maxLineWidth","bodyItem","before","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","footerSpacing","widthPadding","determineYAlign","displayColors","doesNotFitWithAlign","caretSize","determineXAlign","yAlign","xAlign","chartWidth","caret","caretPadding","determineAlignment","alignment","pushOrConcat","paddingAndSize","beforeTitle","tooltipItems","noop","getAlignedX","getBeforeAfterBodyLines","splitNewlines","tooltipItem","defaultCallbacks","formattedValue","labelTextColor","labelPointStyle","beforeFooter","bodyColor","afterLabel","invokeCallbackWithFallback","opacity","_eventPosition","_cachedAnimations","labelPointStyles","labelTextColors","scoped","bodyItems","afterFooter","afterTitle","getBeforeBody","overrideCallbacks","labelColors","_createItems","getBody","itemSort","caretX","caretY","external","drawCaret","getCaretPosition","getTitle","ptX","ptY","tooltipPoint","y3","getFooter","_size","caretPosition","_tooltipItems","x3","pt","colorY","labelColor","innerX","rtlColorX","multiKeyBackground","bodySpacing","bodyAlign","bodyLineHeight","fillLineOfText","xLinePadding","bodyAlignForCalculation","textColor","outerX","drawFooter","tooltipSize","quadraticCurveTo","animX","footerAlign","footerColor","animY","positionAndSize","getBackgroundPoint","drawBackground","drawBody","_updateAnimationTarget","hasTooltipContent","globalAlpha","positionChanged","_positionChanged","Tooltip","afterInit","_ignoreReplayEvents","afterDraw","_getActiveElements","_willRender","afterEvent","Chart","helpers","platforms"],"mappings":"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"}